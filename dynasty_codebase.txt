======================================================================
DynastyVizualizer - Complete Codebase
======================================================================
Generated: 2025-12-14 15:16
Files: 11/94 implemented | 1186 code lines
Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern
Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)
======================================================================

QUICK CONTEXT:
Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,
undo/redo, flexible dates, special char support, DB migration.
Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database

FILE INDEX:
Core: main.py
Database: database\__init__.py, database\db_manager.py, database\person_repository.py
Models: models\__init__.py, models\event.py, models\family.py, models\major_event.py, models\marriage.py, ... (7 total)
Actions: actions\__init__.py, actions\edit_actions.py, actions\file_actions.py, actions\help_actions.py, actions\settings_actions.py, ... (7 total)
Commands: commands\___init__.py, commands\base_command.py, commands\genealogy_commands\__init__.py, commands\genealogy_commands\add_event.py, commands\genealogy_commands\add_marriage.py, ... (28 total)
Dialogs: dialogs\__init__.py, dialogs\about_dialog.py, dialogs\add_event_dialog.py, dialogs\add_person_dialog.py, dialogs\create_child_dialog.py, ... (9 total)
Views: views\__init__.py, views\data_table.py, views\dynasty_view.py, views\stats_view\charts.py, views\stats_view\comparison_widget.py, ... (23 total)
Widgets: widgets\__init__.py, widgets\date_picker.py, widgets\extended_details_panel.py, widgets\person_selector.py, widgets\portrait_gallery.py, ... (6 total)
Utils: utils\__init__.py, utils\color_manager.py, utils\csv_importer.py, utils\generation_calculator.py, utils\relationship_calculator.py, ... (8 total)
Scripts: scripts\create_codebase_summary.py, scripts\migrate_database.py

======================================================================
COMPLETE SOURCE CODE
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… main.py (159 code lines)
import sys

from PySide6.QtWidgets import QApplication, QMainWindow, QMenuBar, QMessageBox
from PySide6.QtGui import QAction

from database.db_manager import DatabaseManager
from actions import FileActions, EditActions, ViewActions, ToolsActions, HelpActions, SettingsActions
from commands.undo_redo_manager import UndoRedoManager
from utils.settings_manager import SettingsManager

class MainWindow(QMainWindow):
    """Main application window for Dynasty Visualizer."""

    def __init__(self) -> None:
        """Initialize the main window and all UI components."""
        super().__init__()

        self.setWindowTitle("Dynasty Visualizer")
        self.resize(1000, 700)

        # Initialize database manager
        self.db = DatabaseManager(self)

        # Initialize undo/redo manager
        self.undo_manager = UndoRedoManager()

        # Initialize settings manager
        self.settings_manager = SettingsManager()

        # Initialize action handlers
        self.file_actions = FileActions(self)
        self.edit_actions = EditActions(self)
        self.view_actions = ViewActions(self)
        self.tools_actions = ToolsActions(self)
        self.settings_actions = SettingsActions(self)
        self.help_actions = HelpActions(self)

        # Create UI elements
        self._create_menus()

        # Connect menu actions to handlers
        self._connect_actions()

        # Update window title and menu states
        self._update_window_title()
        self._update_menu_states()

    # ------------------------------------------------------------------
    # UI Creation
    # ------------------------------------------------------------------

    def _create_menus(self) -> None:
        """Create all menu bars and menu items."""
        menubar = self.menuBar()

        self._create_file_menu(menubar)
        self._create_edit_menu(menubar)
        self._create_view_menu(menubar)
        self._create_tools_menu(menubar)
        self._create_settings_menu(menubar)
        self._create_help_menu(menubar)

    def _create_file_menu(self, menubar: QMenuBar) -> None:
        """Create the File menu with all file operations."""
        file_menu = menubar.addMenu("File")

        self.action_new_dynasty = QAction("New Dynasty", self)
        self.action_new_dynasty.setObjectName("file.new")
        self.action_new_dynasty.setShortcut(self.settings_manager.get_shortcut("file.new"))

        self.action_open_dynasty = QAction("Open Dynasty", self)
        self.action_open_dynasty.setObjectName("file.open")
        self.action_open_dynasty.setShortcut(self.settings_manager.get_shortcut("file.open"))

        self.action_save = QAction("Save", self)
        self.action_save.setObjectName("file.save")
        self.action_save.setShortcut(self.settings_manager.get_shortcut("file.save"))
        
        self.action_save_as = QAction("Save As", self)
        self.action_save_as.setObjectName("file.save_as")
        self.action_save_as.setShortcut(self.settings_manager.get_shortcut("file.save_as"))

        self.action_exit = QAction("Exit", self)
        self.action_exit.setObjectName("file.exit")
        self.action_exit.setShortcut(self.settings_manager.get_shortcut("file.exit"))

        file_menu.addAction(self.action_new_dynasty)
        file_menu.addAction(self.action_open_dynasty)
        file_menu.addSeparator()
        file_menu.addAction(self.action_save)
        file_menu.addAction(self.action_save_as)
        file_menu.addSeparator()
        file_menu.addAction(self.action_exit)

    def _create_edit_menu(self, menubar: QMenuBar) -> None:
        """Create the Edit menu with editing operations."""
        edit_menu = menubar.addMenu("Edit")

        self.action_undo = QAction("Undo", self)
        self.action_undo.setObjectName("edit.undo")
        self.action_undo.setShortcut(self.settings_manager.get_shortcut("edit.undo"))

        self.action_redo = QAction("Redo", self)
        self.action_redo.setObjectName("edit.redo")
        self.action_redo.setShortcut(self.settings_manager.get_shortcut("edit.redo"))
        
        self.action_add_person = QAction("Add Person", self)
        self.action_add_person.setObjectName("edit.add_person")
        self.action_add_person.setShortcut(self.settings_manager.get_shortcut("edit.add_person"))

        self.action_remove_person = QAction("Remove Person", self)
        self.action_remove_person.setObjectName("edit.remove_person")
        self.action_remove_person.setShortcut(self.settings_manager.get_shortcut("edit.remove_person"))

        self.action_add_new_family = QAction("Add New Family", self)
        self.action_add_new_family.setObjectName("edit.add_new_family")
        self.action_add_new_family.setShortcut(self.settings_manager.get_shortcut("edit.add_new_family"))

        edit_menu.addAction(self.action_undo)
        edit_menu.addAction(self.action_redo)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_person)
        edit_menu.addAction(self.action_remove_person)
        edit_menu.addAction(self.action_add_new_family)

        self.edit_actions.undo_action = self.action_undo
        self.edit_actions.redo_action = self.action_redo
        self.edit_actions.update_undo_redo_actions()

    def _create_view_menu(self, menubar: QMenuBar) -> None:
        """Create the View menu with different visualization options."""
        view_menu = menubar.addMenu("View")

        self.action_view_family_trees = QAction("Family Trees", self)
        self.action_view_family_trees.setObjectName("view.family_trees")
        self.action_view_family_trees.setShortcut(self.settings_manager.get_shortcut("view.family_trees"))

        self.action_view_timeline = QAction("Timeline", self)
        self.action_view_timeline.setObjectName("view.timeline")
        self.action_view_timeline.setShortcut(self.settings_manager.get_shortcut("view.timeline"))
        
        self.action_view_dynasty = QAction("Dynasty", self)
        self.action_view_dynasty.setObjectName("view.dynasty")
        self.action_view_dynasty.setShortcut(self.settings_manager.get_shortcut("view.dynasty"))

        self.action_view_data_table = QAction("Data Table", self)
        self.action_view_data_table.setObjectName("view.data_table")
        self.action_view_data_table.setShortcut(self.settings_manager.get_shortcut("view.data_table"))

        view_menu.addAction(self.action_view_family_trees)
        view_menu.addAction(self.action_view_timeline)
        view_menu.addAction(self.action_view_dynasty)
        view_menu.addAction(self.action_view_data_table)

    def _create_tools_menu(self, menubar: QMenuBar) -> None:
        """Create the Tools menu with utility operations."""
        tools_menu = menubar.addMenu("Tools")

        self.action_rebuild_scene = QAction("Rebuild Scene", self)
        self.action_rebuild_scene.setObjectName("tools.rebuild_scene")
        self.action_rebuild_scene.setShortcut(self.settings_manager.get_shortcut("tools.rebuild_scene"))

        self.action_recompute_generations = QAction("Recompute Generations", self)
        self.action_recompute_generations.setObjectName("tools.recompute_generations")
        self.action_recompute_generations.setShortcut(self.settings_manager.get_shortcut("tools.recompute_generations"))
        
        self.action_validate_marriages = QAction("Validate Marriages", self)
        self.action_validate_marriages.setObjectName("tools.validate_marriages")
        self.action_validate_marriages.setShortcut(self.settings_manager.get_shortcut("tools.validate_marriages"))

        self.action_validate_parentage = QAction("Validate Parentage", self)
        self.action_validate_parentage.setObjectName("tools.validate_parentage")
        self.action_validate_parentage.setShortcut(self.settings_manager.get_shortcut("tools.validate_parentage"))

        tools_menu.addAction(self.action_rebuild_scene)
        tools_menu.addAction(self.action_recompute_generations)
        tools_menu.addAction(self.action_validate_marriages)
        tools_menu.addAction(self.action_validate_parentage)

    def _create_settings_menu(self, menubar: QMenuBar) -> None:
        """Create the settings menu with application options."""
        settings_menu = menubar.addMenu("Settings")

        self.action_settings = QAction("Settings", self)
        self.action_settings.setObjectName("settings.settings")
        self.action_settings.setShortcut(self.settings_manager.get_shortcut("settings.settings"))

        self.action_general = QAction("General", self)
        self.action_general.setObjectName("settings.general")
        self.action_general.setShortcut(self.settings_manager.get_shortcut("settings.general"))

        self.action_shortcuts = QAction("Shortcuts", self)
        self.action_shortcuts.setObjectName("settings.shortcuts")
        self.action_shortcuts.setShortcut(self.settings_manager.get_shortcut("settings.shortcuts"))

        self.action_display = QAction("Display", self)
        self.action_display.setObjectName("settings.display")
        self.action_display.setShortcut(self.settings_manager.get_shortcut("settings.display"))

        self.action_appearance = QAction("Appearance", self)
        self.action_appearance.setObjectName("settings.appearance")
        self.action_appearance.setShortcut(self.settings_manager.get_shortcut("settings.appearance"))

        self.action_formats = QAction("Formats", self)
        self.action_formats.setObjectName("settings.formats")
        self.action_formats.setShortcut(self.settings_manager.get_shortcut("settings.formats"))

        settings_menu.addAction(self.action_settings)
        settings_menu.addSeparator()
        settings_menu.addAction(self.action_general)
        settings_menu.addAction(self.action_shortcuts)
        settings_menu.addAction(self.action_display)
        settings_menu.addAction(self.action_appearance)
        settings_menu.addAction(self.action_formats)


    def _create_help_menu(self, menubar: QMenuBar) -> None:
        """Create the Help menu with application information."""
        help_menu = menubar.addMenu("Help")

        self.action_about = QAction("About", self)
        self.action_about.setObjectName("help.about")
        self.action_about.setShortcut(self.settings_manager.get_shortcut("help.about"))
        help_menu.addAction(self.action_about)

    # ------------------------------------------------------------------
    # Action Connections
    # ------------------------------------------------------------------

    def _connect_actions(self) -> None:
        """Connect all menu actions to their handler methods."""
        # File menu connections
        self.action_new_dynasty.triggered.connect(self.file_actions.new_dynasty)
        self.action_open_dynasty.triggered.connect(self.file_actions.open_dynasty)
        self.action_save.triggered.connect(self.file_actions.save)
        self.action_save_as.triggered.connect(self.file_actions.save_as)
        self.action_exit.triggered.connect(self.file_actions.exit_app)

        # Edit menu connections
        self.action_undo.triggered.connect(self.edit_actions.undo)
        self.action_redo.triggered.connect(self.edit_actions.redo)
        self.action_add_person.triggered.connect(self.edit_actions.add_person)
        self.action_remove_person.triggered.connect(self.edit_actions.remove_person)
        self.action_add_new_family.triggered.connect(self.edit_actions.add_new_family)

        # View menu connections
        self.action_view_family_trees.triggered.connect(self.view_actions.family_trees)
        self.action_view_timeline.triggered.connect(self.view_actions.timeline)
        self.action_view_dynasty.triggered.connect(self.view_actions.dynasty)
        self.action_view_data_table.triggered.connect(self.view_actions.data_table)

        # Tools menu connections
        self.action_rebuild_scene.triggered.connect(self.tools_actions.rebuild_scene)
        self.action_recompute_generations.triggered.connect(self.tools_actions.recompute_generations)
        self.action_validate_marriages.triggered.connect(self.tools_actions.validate_marriages)
        self.action_validate_parentage.triggered.connect(self.tools_actions.validate_parentage)

        # Settings menu connections
        self.action_settings.triggered.connect(self.settings_actions.settings)
        self.action_general.triggered.connect(self.settings_actions.general)
        self.action_shortcuts.triggered.connect(self.settings_actions.shortcuts)
        self.action_display.triggered.connect(self.settings_actions.display)
        self.action_appearance.triggered.connect(self.settings_actions.appearance)
        self.action_formats.triggered.connect(self.settings_actions.formats)

        # Help menu connections
        self.action_about.triggered.connect(self.help_actions.about)

    # ------------------------------------------------------------------
    # UI Update Methods
    # ------------------------------------------------------------------

    def _update_window_title(self) -> None:
        """Update the window title to reflect current database state."""
        if self.db.is_open:
            dirty_marker = " *" if self.db.is_dirty else ""
            self.setWindowTitle(f"Dynasty Visualizer - {self.db.database_name}{dirty_marker}")
        else:
            self.setWindowTitle("Dynasty Visualizer")

    def _update_menu_states(self) -> None:
        """Enable or disable menu items based on current state."""
        has_db = self.db.is_open

        # File menu states
        self.action_save.setEnabled(has_db and self.db.is_dirty)
        self.action_save_as.setEnabled(has_db)

        # Edit menu states (disable if no database open)
        self.action_undo.setEnabled(self.undo_manager.can_undo())
        self.action_redo.setEnabled(self.undo_manager.can_redo())
        self.action_add_person.setEnabled(has_db)
        self.action_remove_person.setEnabled(has_db)
        self.action_add_new_family.setEnabled(has_db)

        # View menu states
        self.action_view_family_trees.setEnabled(has_db)
        self.action_view_timeline.setEnabled(has_db)
        self.action_view_dynasty.setEnabled(has_db)
        self.action_view_data_table.setEnabled(has_db)

        # Tools menu states
        self.action_rebuild_scene.setEnabled(has_db)
        self.action_recompute_generations.setEnabled(has_db)
        self.action_validate_marriages.setEnabled(has_db)
        self.action_validate_parentage.setEnabled(has_db)

    # ------------------------------------------------------------------
    # Public Methods
    # ------------------------------------------------------------------

    def refresh_ui(self) -> None:
        """Refresh window title and menu states after database changes."""
        self._update_window_title()
        self._update_menu_states()
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------

    def closeEvent(self, event) -> None:
        """Handle window close event - intercept X button, Alt+F4, etc."""

        if self.db.is_open and self.db.is_dirty:

            msg = QMessageBox(self)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:

                if self.file_actions.save():
                    event.accept()
                else:
                    event.ignore()
            elif choice == QMessageBox.StandardButton.Discard:
                event.accept()
            
            else: 
                event.ignore()
        
        else:
            event.accept()

def main() -> None:
    """Application entry point."""
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ database\__init__.py (3 code lines)
from .db_manager import DatabaseManager
from .person_repository import PersonRepository

__all__ = ['DatabaseManager', 'PersonRepository']

>> âœ… database\db_manager.py (171 code lines)
import sqlite3
import shutil
import os


class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the database manager."""
        self.parent = parent
        self.conn: sqlite3.Connection | None = None
        self.file_path: str | None = None
        self._unsaved_changes: bool = False

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def is_dirty(self) -> bool:
        """Check if there are unsaved changes."""
        return self._unsaved_changes

    @property
    def is_open(self) -> bool:
        """Check if a database is currently open."""
        return self.conn is not None

    @property
    def database_name(self) -> str | None:
        """Get the filename of the current database without path."""
        if self.file_path is None:
            return None
        return os.path.basename(self.file_path)

    @property
    def database_directory(self) -> str | None:
        """Get the directory path of the current database."""
        if self.file_path is None:
            return None
        return os.path.dirname(self.file_path)

    @property
    def has_file_path(self) -> bool:
        """Check if database has an associated file path."""
        return self.file_path is not None

    # ------------------------------------------------------------------
    # Public Methods - Database Lifecycle
    # ------------------------------------------------------------------

    def new_database(self, file_path: str) -> None:
        """Create a brand-new .dyn file with the dynasty schema."""
        if os.path.exists(file_path):
            os.remove(file_path)
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._initialize_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to create database: {e}")

    def open_database(self, file_path: str) -> None:
        """Open an existing .dyn database file."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} does not exist.")
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._migrate_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to open database: {e}")

    def save_database(self, path: str | None = None) -> bool:
        """
        Save the database, optionally to a new path.
        
        If path is provided, saves a copy to that location and switches to it.
        If path is None, commits changes to the current file.
        """
        if self.conn is None:
            return False
        
        # If no path provided, just commit current database
        if path is None:
            self.conn.commit()
            self._unsaved_changes = False
            return True
        
        # Save to new path (save_as behavior)
        if self.file_path is None:
            return False
        
        self.conn.commit()
        self.conn.close()
        
        # Copy database file to new location
        shutil.copy2(self.file_path, path)
        
        # Reopen connection at new path
        self.conn = sqlite3.connect(path)
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.file_path = path
        self._unsaved_changes = False
        return True
    
    def close(self) -> None:
        """Close the current database connection and reset state."""
        if self.conn:
            self.conn.close()
        self.conn = None
        self.file_path = None
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Public Methods - State Management
    # ------------------------------------------------------------------

    def mark_dirty(self) -> None:
        """Mark the database as having unsaved changes."""
        if self.conn is not None:
            self._unsaved_changes = True

    def mark_clean(self) -> None:
        """Mark the database as having no unsaved changes."""
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Private Methods
    # ------------------------------------------------------------------

    def _initialize_schema(self) -> None:
        """Create all required tables for a new dynasty database."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
        
        cursor = self.conn.cursor()

        schema_sql = """
        -- Person table: Core genealogical data
        -- Dates support flexible precision (year, year/month, or year/month/day)
        CREATE TABLE IF NOT EXISTS Person (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            middle_name TEXT DEFAULT '',
            last_name TEXT NOT NULL,
            maiden_name TEXT,
            nickname TEXT DEFAULT '',
            gender TEXT,
            birth_year INTEGER,
            birth_month INTEGER,
            birth_day INTEGER,
            death_year INTEGER,
            death_month INTEGER,
            death_day INTEGER,
            arrival_year INTEGER,
            arrival_month INTEGER,
            arrival_day INTEGER,
            moved_out_year INTEGER,
            moved_out_month INTEGER,
            moved_out_day INTEGER,
            father_id INTEGER,
            mother_id INTEGER,
            family_id INTEGER,
            dynasty_id INTEGER DEFAULT 1,
            is_founder INTEGER DEFAULT 0,
            education INTEGER DEFAULT 0,
            notes TEXT,
            FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
        );

        -- Event table: Life events (jobs, illnesses, moves, etc.)
        CREATE TABLE IF NOT EXISTS Event (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            event_title TEXT NOT NULL,
            start_year INTEGER,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            notes TEXT,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Marriage table: Relationships between people
        CREATE TABLE IF NOT EXISTS Marriage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            spouse1_id INTEGER,
            spouse2_id INTEGER,
            marriage_year INTEGER,
            marriage_month INTEGER,
            marriage_day INTEGER,
            dissolution_year INTEGER,
            dissolution_month INTEGER,
            dissolution_day INTEGER,
            dissolution_reason TEXT,
            marriage_type TEXT DEFAULT 'spouse',
            FOREIGN KEY(spouse1_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL,
            FOREIGN KEY(spouse2_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL
        );

        -- Portrait table: Multiple images per person with date ranges
        CREATE TABLE IF NOT EXISTS Portrait (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            image_path TEXT NOT NULL,
            valid_from_year INTEGER,
            valid_from_month INTEGER,
            valid_from_day INTEGER,
            valid_to_year INTEGER,
            valid_to_month INTEGER,
            valid_to_day INTEGER,
            is_primary INTEGER DEFAULT 0,
            display_order INTEGER DEFAULT 0,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Family table: Dynasty/family groupings
        CREATE TABLE IF NOT EXISTS Family (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            surname TEXT NOT NULL,
            move_in_year INTEGER,
            move_in_month INTEGER,
            move_in_day INTEGER,
            coat_of_arms_path TEXT,
            family_color TEXT,
            is_extinct INTEGER DEFAULT 0,
            notes TEXT
        );

        -- MajorEvent table: Historical events affecting multiple families
        CREATE TABLE IF NOT EXISTS MajorEvent (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT NOT NULL,
            event_type TEXT NOT NULL,
            start_year INTEGER NOT NULL,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            description TEXT,
            color TEXT
        );

        -- PersonPosition table: Custom positions for draggable UI
        CREATE TABLE IF NOT EXISTS PersonPosition (
            person_id INTEGER PRIMARY KEY,
            view_type TEXT NOT NULL,
            x_position REAL NOT NULL,
            y_position REAL NOT NULL,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );
        """
        cursor.executescript(schema_sql)
        self.conn.commit()
    
    def _migrate_schema(self) -> None:
        """Migrate existing database schema to latest version."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
            
        cursor = self.conn.cursor()

        cursor.execute("PRAGMA table_info(Person)")
        existing_columns = {row[1] for row in cursor.fetchall()}

        migrations = [
            # Dec/10/2025 - Person Model updates
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
            ]
        for column_name, sql in migrations:
            if column_name not in existing_columns:
                cursor.execute(sql)



>> âœ… database\person_repository.py (104 code lines)
"""Database repository for Person entity operations."""

from __future__ import annotations
import sqlite3
from typing import TYPE_CHECKING

from models.person import Person

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class PersonRepository:
    """Handles all database operations for Person objects."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize repository with database manager."""
        self.db = db_manager
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _row_to_person(self, row: sqlite3.Row) -> Person:
        """Convert database row to Person object using named column access."""
        return Person(
            id=row['id'],
            first_name=row['first_name'],
            middle_name=row['middle_name'],
            last_name=row['last_name'],
            maiden_name=row['maiden_name'],
            nickname=row['nickname'],
            gender=row['gender'],
            birth_year=row['birth_year'],
            birth_month=row['birth_month'],
            birth_day=row['birth_day'],
            death_year=row['death_year'],
            death_month=row['death_month'],
            death_day=row['death_day'],
            arrival_year=row['arrival_year'],
            arrival_month=row['arrival_month'],
            arrival_day=row['arrival_day'],
            moved_out_year=row['moved_out_year'],
            moved_out_month=row['moved_out_month'],
            moved_out_day=row['moved_out_day'],
            father_id=row['father_id'],
            mother_id=row['mother_id'],
            family_id=row['family_id'],
            dynasty_id=row['dynasty_id'] or 1,
            is_founder=bool(row['is_founder']),
            education=row['education'] or 0,
            notes=row['notes'] or ""
        )
    
    def _cursor(self):
        if self.db.conn is None:
            raise RuntimeError("DB connection not established.")
        return self.db.conn.cursor()
    
    # ------------------------------------------------------------------
    # Create Operations
    # ------------------------------------------------------------------
    
    def insert(self, person: Person) -> int:
        """Insert new person into database and return assigned ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            INSERT INTO Person (
                first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        person_id = cursor.lastrowid
        
        self.db.mark_dirty()
        return person_id if person_id is not None else -1
       
    def insert_with_id(self, person: Person) -> None:
        """Insert person with specific ID (for redo operations)"""
        if self.db.conn is None:
            raise RuntimeError("Database connection not establish.")
        
        if person.id is None:
            raise ValueError("Person must have an ID for insert_with_id")
        
        cursor = self.db.conn.cursor()

        sql = """
            INSERT INTO Person (
                id, first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.id,  # Explicitly set the ID
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
        

    # ------------------------------------------------------------------
    # Read Operations
    # ------------------------------------------------------------------
    
    def get_by_id(self, person_id: int) -> Person | None:
        """Retrieve person by ID, return None if not found."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person WHERE id = ?", (person_id,))
        row = cursor.fetchone()
        
        if row is None:
            return None
        
        return self._row_to_person(row)
    
    def get_all(self) -> list[Person]:
        """Retrieve all people from database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person ORDER BY last_name, first_name")
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_by_name(self, first_name: str, last_name: str) -> list[Person]:
        """Find people by first and last name."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE first_name = ? AND last_name = ?
            ORDER BY birth_year
        """
        cursor.execute(sql, (first_name, last_name))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_children(self, parent_id: int) -> list[Person]:
        """Retrieve all children of a given parent."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE father_id = ? OR mother_id = ?
            ORDER BY birth_year, birth_month, birth_day
        """
        cursor.execute(sql, (parent_id, parent_id))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_alive_in_year(self, year: int) -> list[Person]:
        """Retrieve all people alive in a given year."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person
            WHERE birth_year <= ? 
            AND (death_year IS NULL OR death_year >= ?)
            ORDER BY birth_year
        """
        cursor.execute(sql, (year, year))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    # ------------------------------------------------------------------
    # Update Operations
    # ------------------------------------------------------------------
    
    def update(self, person: Person) -> None:
        """Update existing person in database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        if person.id is None:
            raise ValueError("Cannot update person without ID.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            UPDATE Person SET
                first_name = ?, middle_name = ?, last_name = ?,
                maiden_name = ?, nickname = ?,
                gender = ?, birth_year = ?, birth_month = ?, birth_day = ?,
                death_year = ?, death_month = ?, death_day = ?,
                arrival_year = ?, arrival_month = ?, arrival_day = ?,
                moved_out_year = ?, moved_out_month = ?, moved_out_day = ?,
                father_id = ?, mother_id = ?, family_id = ?,
                dynasty_id = ?, is_founder = ?, education = ?, notes = ?
            WHERE id = ?
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes,
            person.id
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
    
    # ------------------------------------------------------------------
    # Delete Operations
    # ------------------------------------------------------------------
    
    def delete(self, person_id: int) -> None:
        """Delete person from database by ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Person WHERE id = ?", (person_id,))
        self.db.mark_dirty()



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MODELS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ models\__init__.py (0 code lines)


>> ðŸ“‹ models\event.py (15 code lines)
"""Data model for Event entities."""


class Event:
    """Represents a life event for a person."""

    def __init__(
        self,
        event_id: int,
        person_id: int,
        event_type: str,
        event_title: str,
        start_year: int | None = None,
        start_month: int | None = None,
        start_day: int | None = None,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
        notes: str | None = None,
    ) -> None:
        """Initialize an event."""
        self.id = event_id
        self.person_id = person_id
        self.event_type = event_type
        self.event_title = event_title
        self.start_year = start_year
        self.start_month = start_month
        self.start_day = start_day
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.notes = notes

    @property
    def is_ongoing(self) -> bool:
        """Check if the event is ongoing."""
        return self.end_year is None

    # TODO: Add duration property
    # TODO: Add start_date_string property
    # TODO: Add end_date_string property


>> ðŸ“‹ models\family.py (12 code lines)
"""Data model for Family dynasties."""


class Family:
    """Represents a family dynasty grouping."""

    def __init__(
        self,
        family_id: int,
        surname: str,
        move_in_year: int | None = None,
        move_in_month: int | None = None,
        move_in_day: int | None = None,
        coat_of_arms_path: str | None = None,
        family_color: str | None = None,
        is_extinct: bool = False,
        notes: str | None = None,
    ) -> None:
        """Initialize a family dynasty."""
        self.id = family_id
        self.surname = surname
        self.move_in_year = move_in_year
        self.move_in_month = move_in_month
        self.move_in_day = move_in_day
        self.coat_of_arms_path = coat_of_arms_path
        self.family_color = family_color
        self.is_extinct = is_extinct
        self.notes = notes

    # TODO: Add move_in_date_string property
    # TODO: Add member_count property (requires database query)
    # TODO: Add founding_date property
    # TODO: Add end_date property
    # TODO: Add longest_lived_member property


>> ðŸ“‹ models\major_event.py (15 code lines)
"""Data model for MajorEvent entities."""


class MajorEvent:
    """Represents a major historical event affecting multiple families."""

    def __init__(
        self,
        event_id: int,
        event_name: str,
        event_type: str,
        start_year: int,
        start_month: int | None = None,
        start_day: int | None = None,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
        description: str | None = None,
        color: str | None = None,
    ) -> None:
        """Initialize a major historical event."""
        self.id = event_id
        self.event_name = event_name
        self.event_type = event_type
        self.start_year = start_year
        self.start_month = start_month
        self.start_day = start_day
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.description = description
        self.color = color

    @property
    def is_ongoing(self) -> bool:
        """Check if the event is ongoing."""
        return self.end_year is None

    # TODO: Add duration property
    # TODO: Add start_date_string property
    # TODO: Add end_date_string property


>> ðŸ“‹ models\marriage.py (15 code lines)
"""Data model for Marriage relationships."""


class Marriage:
    """Represents a marriage relationship between two people."""

    def __init__(
        self,
        marriage_id: int,
        spouse1_id: int,
        spouse2_id: int,
        marriage_year: int | None = None,
        marriage_month: int | None = None,
        marriage_day: int | None = None,
        dissolution_year: int | None = None,
        dissolution_month: int | None = None,
        dissolution_day: int | None = None,
        dissolution_reason: str | None = None,
        marriage_type: str = "spouse",
    ) -> None:
        """Initialize a marriage relationship."""
        self.id = marriage_id
        self.spouse1_id = spouse1_id
        self.spouse2_id = spouse2_id
        self.marriage_year = marriage_year
        self.marriage_month = marriage_month
        self.marriage_day = marriage_day
        self.dissolution_year = dissolution_year
        self.dissolution_month = dissolution_month
        self.dissolution_day = dissolution_day
        self.dissolution_reason = dissolution_reason
        self.marriage_type = marriage_type

    @property
    def is_active(self) -> bool:
        """Check if the marriage is currently active."""
        return self.dissolution_year is None

    # TODO: Add duration property
    # TODO: Add marriage_date_string property
    # TODO: Add dissolution_date_string property


>> âœ… models\person.py (50 code lines)
"""Data model for Person entities."""

from __future__ import annotations
from dataclasses import dataclass


@dataclass
class Person:
    """Represents a person in a dynasty with flexible date precision."""
    
    # Database identity
    id: int | None = None  # None until saved to database
    dynasty_id: int = 1
    family_id: int | None = None
    
    # Name fields (full structure for flexibility)
    first_name: str = ""
    middle_name: str = ""
    last_name: str = ""
    maiden_name: str = ""
    nickname: str = ""
    
    # Biological information
    gender: str = "Unknown"  # "Male", "Female", "Unknown", "Other"
    
    # Birth date (year should be provided, month/day optional)
    birth_year: int | None = None
    birth_month: int | None = None
    birth_day: int | None = None
    
    # Death date (all optional - None if alive)
    death_year: int | None = None
    death_month: int | None = None
    death_day: int | None = None
    
    # Arrival/departure dates (tracking when joined/left settlement)
    arrival_year: int | None = None
    arrival_month: int | None = None
    arrival_day: int | None = None
    moved_out_year: int | None = None
    moved_out_month: int | None = None
    moved_out_day: int | None = None
    
    # Relationships (parent IDs link to database)
    father_id: int | None = None
    mother_id: int | None = None
    
    # Game-specific fields
    is_founder: bool = False
    education: int = 0  # 0-5 scale from Ostriv
    
    # User notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties
    # ------------------------------------------------------------------
    
    @property
    def full_name(self) -> str:
        """Get full name with optional middle name and nickname."""
        parts = [self.first_name]
        
        if self.middle_name:
            parts.append(self.middle_name)
        
        parts.append(self.last_name)

        name = " ".join(parts)
        
        if self.nickname:
            name += f' "{self.nickname}"'

        return name
    
    @property
    def display_name(self) -> str:
        """Get display name (first + last, no middle or nickname)."""
        return f"{self.first_name} {self.last_name}"
    
    @property
    def is_deceased(self) -> bool:
        """Check if person is deceased."""
        return self.death_year is not None
    
    def get_age(self, current_year: int) -> int | None:
        """
        Calculate age at a given year.
        
        Returns None if birth year unknown or if person died before current year.
        """
        if self.birth_year is None:
            return None
        
        # If person died, use death year as upper bound
        if self.death_year is not None and current_year > self.death_year:
            return None
        
        return current_year - self.birth_year
    
    def is_alive_in_year(self, year: int) -> bool:
        """Check if person was alive in a given year."""
        # Must have been born by that year
        if self.birth_year is None or year < self.birth_year:
            return False
        
        # If no death year, assume still alive
        if self.death_year is None:
            return True
        
        # Check if year is before death
        return year <= self.death_year
    
    def get_age_at_death(self) -> int | None:
        """Calculate age at death, or None if not deceased or birth year unknown."""
        if not self.is_deceased or self.birth_year is None or self.death_year is None:
            return None
        
        return self.death_year - self.birth_year
    
    def get_birth_date_string(self) -> str:
        """Format birth date as string with available precision (European format)."""
        if self.birth_year is None:
            return "Unknown"
        
        if self.birth_day and self.birth_month:
            return f"{self.birth_day:02d}/{self.birth_month:02d}/{self.birth_year}"
        
        if self.birth_month:
            return f"{self.birth_month:02d}/{self.birth_year}"
        
        return str(self.birth_year)
    
    def get_death_date_string(self) -> str:
        """Format death date as string with available precision (European format)."""
        if self.death_year is None:
            return "Alive"
        
        if self.death_day and self.death_month:
            return f"{self.death_day:02d}/{self.death_month:02d}/{self.death_year}"
        
        if self.death_month:
            return f"{self.death_month:02d}/{self.death_year}"
        
        return str(self.death_year)
    
    def get_lifespan_string(self) -> str:
        """Get lifespan as formatted string (e.g., '1420-1475' or '1450-')."""
        birth = str(self.birth_year) if self.birth_year else "?"
        death = str(self.death_year) if self.death_year else ""
        return f"{birth}-{death}"

>> ðŸ“‹ models\portrait.py (14 code lines)
"""Data model for Portrait entities."""


class Portrait:
    """Represents a portrait image for a person."""

    def __init__(
        self,
        portrait_id: int,
        person_id: int,
        image_path: str,
        valid_from_year: int | None = None,
        valid_from_month: int | None = None,
        valid_from_day: int | None = None,
        valid_to_year: int | None = None,
        valid_to_month: int | None = None,
        valid_to_day: int | None = None,
        is_primary: bool = False,
        display_order: int = 0,
    ) -> None:
        """Initialize a portrait."""
        self.id = portrait_id
        self.person_id = person_id
        self.image_path = image_path
        self.valid_from_year = valid_from_year
        self.valid_from_month = valid_from_month
        self.valid_from_day = valid_from_day
        self.valid_to_year = valid_to_year
        self.valid_to_month = valid_to_month
        self.valid_to_day = valid_to_day
        self.is_primary = is_primary
        self.display_order = display_order

    # TODO: Add valid_from_date_string property
    # TODO: Add valid_to_date_string property
    # TODO: Add is_valid_for_date method



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ actions\__init__.py (7 code lines)
from .file_actions import FileActions
from .edit_actions import EditActions
from .view_actions import ViewActions
from .tools_actions import ToolsActions
from .help_actions import HelpActions
from .settings_actions import SettingsActions

__all__ = ['FileActions', 'EditActions', 'ViewActions', 'ToolsActions', 'HelpActions', 'SettingsActions']

>> âœ… actions\edit_actions.py (25 code lines)
from PySide6.QtWidgets import QDialog
from PySide6.QtGui import QAction

from dialogs.add_person_dialog import AddPersonDialog
from commands.genealogy_commands import AddPersonCommand
        

class EditActions:
    """Handles edit menu actions (Undo, Redo, Add/Remove operations)."""
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize edit actions handler."""
        self.parent = parent
        
        # Store references to the menu actions so we can update their text
        # These will be set by MainWindow after it creates the menu
        self.undo_action: QAction | None = None
        self.redo_action: QAction | None = None
    
    def update_undo_redo_actions(self) -> None:
        """Update Undo/Redo menu items with current action descriptions."""
        if self.undo_action is None or self.redo_action is None:
            return 
        
        undo_manager = self.parent.undo_manager
        
        # Update Undo action
        if undo_manager.can_undo():
            next_undo = undo_manager.peek_undo()
            if next_undo:
                self.undo_action.setText(f"Undo {next_undo.description()}")
                self.undo_action.setEnabled(True)
        else:
            self.undo_action.setText("Undo")
            self.undo_action.setEnabled(False)
        
        # Update Redo action
        if undo_manager.can_redo():
            next_redo = undo_manager.peek_redo()
            if next_redo:
                self.redo_action.setText(f"Redo {next_redo.description()}")
                self.redo_action.setEnabled(True)
        else:
            self.redo_action.setText("Redo")
            self.redo_action.setEnabled(False)
    
    def undo(self) -> None:
        """Undo the last action."""
        if self.parent.undo_manager.undo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after undo
    
    def redo(self) -> None:
        """Redo the last undone action."""
        if self.parent.undo_manager.redo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after redo
    
    def add_person(self) -> None:
        """Open dialog to add a new person to the database."""

        dialog = AddPersonDialog(self.parent)
        result = dialog.exec()
        
        if result == 1:  # QDialog.accepted
            person = dialog.get_person()
            if person:
                command = AddPersonCommand(self.parent.db, person)
                self.parent.undo_manager.execute(command)
                self.parent.refresh_ui()
                self.update_undo_redo_actions()  # Update menu after adding person
    
    def remove_person(self) -> None:
        """Remove the selected person from the database."""
        pass  # TODO: Implement with confirmation dialog
    
    def add_new_family(self) -> None:
        """Create a new family branch in the dynasty."""
        pass  # TODO: Implement family creation

>> âœ… actions\file_actions.py (52 code lines)
from PySide6.QtWidgets import QFileDialog, QMessageBox


class FileActions:
    """Handles file menu actions (New, Open, Save, Exit)."""
    
    FILE_FILTER = "Dynasty Files (*.dyn)"
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize file actions handler."""
        self.parent = parent
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _ensure_db(self) -> bool:
        """Check if a database is currently open."""
        if not hasattr(self.parent, 'db') or not self.parent.db.is_open:
            self._show_error("Error", "No database is currently open.")
            return False
        return True
    
    def _get_save_path(self, title: str, default_name: str = "") -> str | None:
        """Show a save file dialog and return the chosen path."""
        default_path = ""
        if default_name:
            default_path = default_name
        elif self.parent.db.database_directory:
            default_path = self.parent.db.database_directory
        
        path, _ = QFileDialog.getSaveFileName(
            self.parent,
            title,
            default_path,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _get_open_path(self, title: str) -> str | None:
        """Show an open file dialog and return the chosen path."""
        default_dir = ""
        if self.parent.db.is_open and self.parent.db.database_directory:
            default_dir = self.parent.db.database_directory
        
        path, _ = QFileDialog.getOpenFileName(
            self.parent,
            title,
            default_dir,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _show_error(self, title: str, message: str) -> None:
        """Display an error message dialog."""
        QMessageBox.critical(self.parent, title, message)
    
    # ------------------------------------------------------------------
    # File Operations
    # ------------------------------------------------------------------
    
    def new_dynasty(self) -> None:
        """Prompt user to create a new dynasty database file."""
        path = self._get_save_path("Create New Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.new_database(path)
            self.parent.refresh_ui()
        except Exception as e:
            self._show_error(
                "Error Creating Database",
                f"Failed to create dynasty file:\n{str(e)}"
            )
    
    def open_dynasty(self) -> None:
        """Prompt user to open an existing dynasty database file."""
        path = self._get_open_path("Open Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.open_database(path)
            self.parent.refresh_ui()
        except FileNotFoundError:
            self._show_error(
                "File Not Found",
                f"The file '{path}' does not exist."
            )
        except Exception as e:
            self._show_error(
                "Error Opening Database",
                f"Failed to open dynasty file:\n{str(e)}"
            )
    
    def save(self) -> bool:
        """Save current database, falling back to save_as if no path set."""
        if not self._ensure_db():
            return False
        
        if not self.parent.db.has_file_path:
            return self.save_as()
        
        try:
            result = self.parent.db.save_database()
            if result:
                self.parent.refresh_ui()
            return result
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def save_as(self) -> bool:
        """Prompt user to save database to a new file."""
        if not self._ensure_db():
            return False
        
        # Suggest current filename if it exists
        default_name = self.parent.db.database_name or ""
        path = self._get_save_path("Save Dynasty File As", default_name)
        if not path:
            return False
        
        try:
            self.parent.db.save_database(path)
            return True
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def exit_app(self) -> None:
        """Prompt to save unsaved changes before closing application."""
        db = self.parent.db
        
        if db.is_open and db.is_dirty:
            msg = QMessageBox(self.parent)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:
                if not self.save():
                    return
            elif choice == QMessageBox.StandardButton.Cancel:
                return
        
        self.parent.close()


>> ðŸ“‹ actions\help_actions.py (3 code lines)
class HelpActions:
    """Handles help menu actions for application information."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize help actions handler."""
        self.parent = parent

    def about(self) -> None:
        """Display the about dialog with application information."""
        pass  # TODO: Implement about dialog


>> ðŸ“‹ actions\settings_actions.py (8 code lines)
class SettingsActions:
    """Handles settings menu actions for various configuration options."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize settings actions handler."""
        self.parent = parent

    def settings(self) -> None:
        """Open settings dialog to modify application settings."""
        pass  # TODO: Implement settings dialog interaction

    def general(self) -> None:
        """Open general settings tab."""
        pass  # TODO: Implement general settings tab

    def shortcuts(self) -> None:
        """Open shortcuts settings tab."""
        pass  # TODO: Implement shortcuts settings tab

    def display(self) -> None:
        """Open display settings tab."""
        pass  # TODO: Implement display settings tab

    def appearance(self) -> None:
        """Open appearance settings tab."""
        pass  # TODO: Implement appearance settings tab

    def formats(self) -> None:
        """Open formats settings tab."""
        pass  # TODO: Implement formats settings tab

>> ðŸ“‹ actions\tools_actions.py (6 code lines)
class ToolsActions:
    """Handles tools menu actions for validation and scene utilities."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize tools actions handler."""
        self.parent = parent

    def rebuild_scene(self) -> None:
        """Rebuild the current visualization scene from scratch."""
        pass  # TODO: Implement scene rebuild

    def recompute_generations(self) -> None:
        """Recalculate generation levels for all persons."""
        pass  # TODO: Implement generation computation

    def validate_marriages(self) -> None:
        """Check for inconsistencies in marriage records."""
        pass  # TODO: Implement marriage validation

    def validate_parentage(self) -> None:
        """Check for inconsistencies in parent-child relationships."""
        pass  # TODO: Implement parentage validation


>> ðŸ“‹ actions\view_actions.py (6 code lines)
class ViewActions:
    """Handles view menu actions for switching between visualizations."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize view actions handler."""
        self.parent = parent

    def family_trees(self) -> None:
        """Switch to family trees visualization view."""
        pass  # TODO: Implement family trees view

    def timeline(self) -> None:
        """Switch to timeline visualization view."""
        pass  # TODO: Implement timeline view

    def dynasty(self) -> None:
        """Switch to dynasty visualization view."""
        pass  # TODO: Implement dynasty view

    def data_table(self) -> None:
        """Switch to data table view."""
        pass  # TODO: Implement data table view



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ commands\___init__.py (0 code lines)


>> ðŸ“‹ commands\base_command.py (9 code lines)
import re

class BaseCommand:
    """Base class for all undoable commands."""
    
    def __init__(self):
        self._executed = False  
    
    def description(self) -> str:
        """Return human-readable description for UI display."""
        class_name = self.__class__.__name__
        if class_name.endswith("Command"):
            class_name = class_name[:-7]

        spaced = re.sub(r'([a-z])([A-Z])', r'\1 \2', class_name)
        
        return spaced
    
    def run(self) -> None:
        """Execute the command."""
        raise NotImplementedError("Subclasses must implement run()")
    
    def undo(self) -> None:
        """Reverse the command's effects."""
        raise NotImplementedError("Subclasses must implement undo()")


>> âœ… commands\genealogy_commands\__init__.py (26 code lines)
from .add_event import AddEventCommand
from .add_marriage import CreateMarriageCommand
from .add_person import AddPersonCommand
from .assign_parent import AssignParentCommand
from .create_child import CreateChildCommand
from .delete_event import DeleteEventCommand
from .edit_event import EditEventCommand
from .edit_marriage import EditMarriageCommand
from .edit_person import EditPersonCommand
from .end_marriage import EndMarriageCommand
from .delete_person import DeletePersonCommand
from .unassign_parent import UnassignParentCommand

__all__ = [
    "AddEventCommand",
    "CreateMarriageCommand",
    "AddPersonCommand",
    "AssignParentCommand",
    "CreateChildCommand",
    "DeleteEventCommand",
    "EditEventCommand",
    "EditMarriageCommand",
    "EditPersonCommand",
    "EndMarriageCommand",
    "DeletePersonCommand",
    "UnassignParentCommand"
]

>> ðŸ“‹ commands\genealogy_commands\add_event.py (3 code lines)
"""Command for adding an event to a person."""

from commands.base_command import BaseCommand


class AddEventCommand(BaseCommand):
    """Add a life event to a person."""

    def __init__(self, event_data: dict) -> None:
        """Initialize the add event command."""
        self.event_data = event_data
        self.event_id: int | None = None

    def run(self) -> None:
        """Insert the event into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated event_id for undo
        pass

    def undo(self) -> None:
        """Remove the event from the database."""
        # TODO: Implement database DELETE using stored event_id
        pass


>> ðŸ“‹ commands\genealogy_commands\add_marriage.py (3 code lines)
"""Command for creating a marriage between two people."""

from commands.base_command import BaseCommand


class CreateMarriageCommand(BaseCommand):
    """Create a marriage relationship between two people."""

    def __init__(self, marriage_data: dict) -> None:
        """Initialize the create marriage command."""
        self.marriage_data = marriage_data
        self.marriage_id: int | None = None

    def run(self) -> None:
        """Insert the marriage into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated marriage_id for undo
        # TODO: Handle surname changes if configured
        pass

    def undo(self) -> None:
        """Remove the marriage from the database."""
        # TODO: Implement database DELETE
        # TODO: Revert surname changes if applicable
        pass


>> ðŸ“‹ commands\genealogy_commands\add_person.py (8 code lines)
"""Command for adding a new person to the database."""

from __future__ import annotations
from typing import TYPE_CHECKING

from models.person import Person
from commands.base_command import BaseCommand
from database.person_repository import PersonRepository

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class AddPersonCommand(BaseCommand):
    """Add a new person to the dynasty database with undo support."""

    def __init__(self, db_manager: DatabaseManager, person: Person) -> None:
        """Initialize the add person command."""
        self.person = person
        self.person_id: int | None = None
        self.repo = PersonRepository(db_manager)

    def run(self) -> None:
        """Insert the person into the database and store the assigned ID."""
        if self.person_id is None:
            self.person_id = self.repo.insert(self.person)
            self.person.id = self.person_id

        else:
            self.person.id = self.person_id
            self.repo.insert_with_id(self.person)

    def undo(self) -> None:
        """Remove the person from the database."""
        if self.person_id is not None:
            self.repo.delete(self.person_id)

>> ðŸ“‹ commands\genealogy_commands\assign_parent.py (9 code lines)
"""Command for assigning a parent to a person."""

from commands.base_command import BaseCommand


class AssignParentCommand(BaseCommand):
    """Set or change a person's father or mother."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the assign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_id = parent_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Assign the parent relationship in database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Update father_id or mother_id based on parent_type
        pass

    def undo(self) -> None:
        """Restore original parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\genealogy_commands\create_child.py (11 code lines)
"""Command for creating a child with automatic parent assignment."""

from commands.base_command import BaseCommand


class CreateChildCommand(BaseCommand):
    """Create a new person as child of specified parents."""

    def __init__(
        self,
        database_connection,
        first_name: str,
        last_name: str,
        father_id: int | None = None,
        mother_id: int | None = None,
        **kwargs,
    ) -> None:
        """Initialize the create child command."""
        self.db = database_connection
        self.first_name = first_name
        self.last_name = last_name
        self.father_id = father_id
        self.mother_id = mother_id
        self.additional_data = kwargs
        self.created_person_id: int | None = None
        # TODO: Store created person ID for undo

    def run(self) -> None:
        """Create new person with parent relationships."""
        # TODO: Insert new person into database
        # TODO: Set father_id and mother_id
        # TODO: Store created_person_id
        pass

    def undo(self) -> None:
        """Delete the created child."""
        # TODO: Delete person record using created_person_id
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_event.py (3 code lines)
"""Command for deleting an event from the database."""

from commands.base_command import BaseCommand


class DeleteEventCommand(BaseCommand):
    """Remove an event from the database."""

    def __init__(self, database_connection, event_id: int) -> None:
        """Initialize the delete event command."""
        self.db = database_connection
        self.event_id = event_id
        self.deleted_data: dict = {}
        # TODO: Store complete event data for undo

    def run(self) -> None:
        """Delete the event from database."""
        # TODO: Fetch and save complete event data to deleted_data
        # TODO: Delete event record from database
        pass

    def undo(self) -> None:
        """Restore the deleted event."""
        # TODO: Re-insert event record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_marriage.py (3 code lines)
"""Command for deleting a marriage from the database."""

from commands.base_command import BaseCommand


class DeleteMarriageCommand(BaseCommand):
    """Remove a marriage relationship from the database."""

    def __init__(self, database_connection, marriage_id: int) -> None:
        """Initialize the delete marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.deleted_data: dict = {}
        # TODO: Store complete marriage data for undo

    def run(self) -> None:
        """Delete the marriage from database."""
        # TODO: Fetch and save complete marriage data to deleted_data
        # TODO: Delete marriage record from database
        pass

    def undo(self) -> None:
        """Restore the deleted marriage."""
        # TODO: Re-insert marriage record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_person.py (3 code lines)
"""Command for removing a person from the database."""

from commands.base_command import BaseCommand


class DeletePersonCommand(BaseCommand):
    """Delete a person from the dynasty database."""

    def __init__(self, person_id: int) -> None:
        """Initialize the delete person command."""
        self.person_id = person_id
        self.person_data: dict | None = None

    def run(self) -> None:
        """Remove the person from the database."""
        # TODO: Fetch and store all person data for undo
        # TODO: Implement database DELETE
        # TODO: Handle cascade effects (orphaned children, etc.)
        pass

    def undo(self) -> None:
        """Restore the deleted person."""
        # TODO: Implement database INSERT with stored person_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_event.py (3 code lines)
"""Command for editing an existing event."""

from commands.base_command import BaseCommand


class EditEventCommand(BaseCommand):
    """Edit details of an existing event."""

    def __init__(self, database_connection, event_id: int, **kwargs) -> None:
        """Initialize the edit event command."""
        self.db = database_connection
        self.event_id = event_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original event data for undo

    def run(self) -> None:
        """Update event details in database."""
        # TODO: Save current state to old_data
        # TODO: Update event record with new_data
        pass

    def undo(self) -> None:
        """Restore original event details."""
        # TODO: Restore event record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_marriage.py (3 code lines)
"""Command for editing an existing marriage."""

from commands.base_command import BaseCommand


class EditMarriageCommand(BaseCommand):
    """Edit details of an existing marriage relationship."""

    def __init__(self, database_connection, marriage_id: int, **kwargs) -> None:
        """Initialize the edit marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original marriage data for undo

    def run(self) -> None:
        """Update marriage details in database."""
        # TODO: Save current state to old_data
        # TODO: Update marriage record with new_data
        pass

    def undo(self) -> None:
        """Restore original marriage details."""
        # TODO: Restore marriage record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_person.py (3 code lines)
"""Command for editing an existing person."""

from commands.base_command import BaseCommand


class EditPersonCommand(BaseCommand):
    """Edit an existing person in the database."""

    def __init__(self, person_id: int, new_data: dict) -> None:
        """Initialize the edit person command."""
        self.person_id = person_id
        self.new_data = new_data
        self.old_data: dict | None = None

    def run(self) -> None:
        """Update the person in the database."""
        # TODO: Fetch and store old data for undo
        # TODO: Implement database UPDATE
        pass

    def undo(self) -> None:
        """Restore the person's original data."""
        # TODO: Implement database UPDATE with old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\end_marriage.py (10 code lines)
"""Command for ending a marriage with divorce or death."""

from commands.base_command import BaseCommand


class EndMarriageCommand(BaseCommand):
    """Mark a marriage as ended with a specific date."""

    def __init__(
        self,
        database_connection,
        marriage_id: int,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
    ) -> None:
        """Initialize the end marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.old_end_date: tuple[int | None, int | None, int | None] = (None, None, None)
        # TODO: Store original end date for undo

    def run(self) -> None:
        """Set the marriage end date in database."""
        # TODO: Save current end date to old_end_date
        # TODO: Update marriage end_year, end_month, end_day
        pass

    def undo(self) -> None:
        """Restore original marriage end date."""
        # TODO: Restore end date from old_end_date
        pass


>> ðŸ“‹ commands\genealogy_commands\unassign_parent.py (8 code lines)
"""Command for removing a parent assignment from a person."""

from commands.base_command import BaseCommand


class UnassignParentCommand(BaseCommand):
    """Remove a person's father or mother relationship."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the unassign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Remove the parent relationship from database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Set father_id or mother_id to NULL based on parent_type
        pass

    def undo(self) -> None:
        """Restore the parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\GUI_commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\change_skin.py (3 code lines)
"""Command for changing the application color scheme."""

from commands.base_command import BaseCommand


class ChangeSkinCommand(BaseCommand):
    """Switch between different UI color schemes."""

    def __init__(self, new_skin: str, old_skin: str) -> None:
        """Initialize the change skin command."""
        self.new_skin = new_skin
        self.old_skin = old_skin
        # TODO: Add reference to skin manager

    def run(self) -> None:
        """Apply the new color scheme."""
        # TODO: Load new skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass

    def undo(self) -> None:
        """Restore previous color scheme."""
        # TODO: Load old skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass


>> ðŸ“‹ commands\GUI_commands\change_view.py (3 code lines)
"""Command for switching between different visualization views."""

from commands.base_command import BaseCommand


class ChangeViewCommand(BaseCommand):
    """Switch between tree, timeline, table, and stats views."""

    def __init__(self, new_view: str, old_view: str) -> None:
        """Initialize the change view command."""
        self.new_view = new_view  # "tree", "timeline", "table", "stats"
        self.old_view = old_view
        # TODO: Add reference to main window

    def run(self) -> None:
        """Switch to the new visualization view."""
        # TODO: Hide current view widget
        # TODO: Show new view widget
        # TODO: Update menu checkmarks
        pass

    def undo(self) -> None:
        """Switch back to the previous view."""
        # TODO: Hide current view widget
        # TODO: Show old view widget
        # TODO: Update menu checkmarks
        pass


>> ðŸ“‹ commands\GUI_commands\move_node.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\move_person.py (10 code lines)
"""Command for moving a person box in the tree view."""

from commands.base_command import BaseCommand


class MovePersonCommand(BaseCommand):
    """Move a person's visual position in the tree canvas."""

    def __init__(
        self,
        person_id: int,
        new_x: float,
        new_y: float,
        old_x: float,
        old_y: float,
    ) -> None:
        """Initialize the move person command."""
        self.person_id = person_id
        self.new_x = new_x
        self.new_y = new_y
        self.old_x = old_x
        self.old_y = old_y
        # TODO: Add reference to canvas/scene for visual updates

    def run(self) -> None:
        """Move person box to new position."""
        # TODO: Update PersonPosition table in database
        # TODO: Update visual position on canvas
        pass

    def undo(self) -> None:
        """Restore person box to original position."""
        # TODO: Update PersonPosition table with old coordinates
        # TODO: Update visual position on canvas
        pass


>> ðŸ“‹ commands\GUI_commands\preference_changes.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\rebuild_scene.py (3 code lines)
"""Command for rebuilding the entire visualization scene."""

from commands.base_command import BaseCommand


class RebuildSceneCommand(BaseCommand):
    """Rebuild the current view from database state."""

    def __init__(self, database_connection, view_type: str) -> None:
        """Initialize the rebuild scene command."""
        self.db = database_connection
        self.view_type = view_type  # "tree", "timeline", "table", "stats"
        # TODO: Store current scene state for undo

    def run(self) -> None:
        """Clear and rebuild the visualization scene."""
        # TODO: Clear current scene/view
        # TODO: Reload all data from database
        # TODO: Recreate all visual elements
        pass

    def undo(self) -> None:
        """Restore previous scene state."""
        # TODO: Restore from saved scene state
        pass


>> ðŸ“‹ commands\GUI_commands\recompute_generation.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\recompute_generations.py (3 code lines)
"""Command for recalculating generation levels for all people."""

from commands.base_command import BaseCommand


class RecomputeGenerationsCommand(BaseCommand):
    """Recalculate generation numbers for entire family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the recompute generations command."""
        self.db = database_connection
        self.old_generations: dict[int, int] = {}
        # TODO: Store original generation assignments for undo

    def run(self) -> None:
        """Calculate and update generation levels."""
        # TODO: Use GenerationCalculator to compute levels
        # TODO: Update Person table with new generation values
        # TODO: Update tree view layout
        pass

    def undo(self) -> None:
        """Restore original generation assignments."""
        # TODO: Restore generation values from old_generations
        # TODO: Update tree view layout
        pass


>> ðŸ“‹ commands\GUI_commands\timeline_scroll.py (0 code lines)


>> ðŸ“‹ commands\undo_redo_manager.py (19 code lines)
from __future__ import annotations

from commands.base_command import BaseCommand


class UndoRedoManager:
    """Manages undo and redo stacks for command pattern operations."""
    
    def __init__(self) -> None:
        """Initialize the undo/redo manager with empty stacks."""
        self.undo_stack: list[BaseCommand] = []
        self.redo_stack: list[BaseCommand] = []
    
    def execute(self, command: BaseCommand) -> None:  
        """Execute a command and add it to the undo stack."""
        command.run()
        self.undo_stack.append(command)
        self.redo_stack.clear()
    
    def undo(self) -> bool:
        """Undo the last executed command."""
        if not self.undo_stack:
            return False
        cmd = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
        return True
    
    def redo(self) -> bool:
        """Redo the last undone command."""
        if not self.redo_stack:
            return False
        cmd = self.redo_stack.pop()
        cmd.run()
        self.undo_stack.append(cmd)
        return True
    
    def can_undo(self) -> bool:
        """Check if there are commands available to undo."""
        return len(self.undo_stack) > 0
    
    def can_redo(self) -> bool:
        """Check if there are commands available to redo."""
        return len(self.redo_stack) > 0
    
    def peek_undo(self) -> BaseCommand | None:
        """Get the next command that would be undone without executing it."""
        if self.can_undo():
            return self.undo_stack[-1]
        return None
    
    def peek_redo(self) -> BaseCommand | None:
        """Get the next command that would be redone without executing it."""
        if self.can_redo():
            return self.redo_stack[-1]
        return None

>> ðŸ“‹ commands\view_changes.py (0 code lines)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIALOGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ dialogs\__init__.py (0 code lines)
"""Dialog implementations for user interactions."""

from .add_person_dialog import AddPersonDialog

__all__ = ['AddPersonDialog']

>> ðŸ“‹ dialogs\about_dialog.py (1 code lines)
"""About dialog showing application information."""

from PySide6.QtWidgets import QDialog


class AboutDialog(QDialog):
    """Dialog displaying application information and credits."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the about dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add application name, version, credits
        # TODO: Add license information
        # TODO: Add GitHub link
        pass


>> ðŸ“‹ dialogs\add_event_dialog.py (1 code lines)
"""Dialog for adding a new event to a person."""

from PySide6.QtWidgets import QDialog


class AddEventDialog(QDialog):
    """Dialog for creating a new event entry."""

    def __init__(self, parent: 'MainWindow', person_id: int | None = None) -> None:  # type: ignore
        """Initialize the add event dialog."""
        super().__init__(parent)
        self.person_id = person_id
        # TODO: Implement dialog UI
        # TODO: Add PersonSelector widget (pre-filled if person_id provided)
        # TODO: Add event type dropdown
        # TODO: Add DatePicker for event date
        # TODO: Add description text field
        # TODO: Add validation logic
        # TODO: Connect to AddEventCommand
        pass


>> âœ… dialogs\add_person_dialog.py (47 code lines)
"""Dialog for adding a new person to the dynasty."""

from __future__ import annotations
from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QSpinBox, QComboBox, QTextEdit,
    QPushButton, QDialogButtonBox, QLabel, QMessageBox
)
from PySide6.QtCore import Qt

from models.person import Person

if TYPE_CHECKING:
    from PySide6.QtWidgets import QWidget


class AddPersonDialog(QDialog):
    """Dialog for adding a new person with essential information."""
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the add person dialog."""
        super().__init__(parent)
        
        self.setWindowTitle("Add New Person")
        self.setMinimumWidth(400)
        
        self._person: Person | None = None
        
        self._setup_ui()
        self._connect_signals()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create and arrange all dialog widgets."""
        layout = QVBoxLayout(self)
        
        # Special character toolbar
        layout.addLayout(self._create_special_char_toolbar())
        
        # Add separator line
        separator = QLabel()
        separator.setFrameShape(QLabel.Shape.HLine)
        separator.setFrameShadow(QLabel.Shadow.Sunken)
        layout.addWidget(separator)
        
        # Form fields
        layout.addLayout(self._create_form_layout())
        
        # OK/Cancel buttons
        layout.addWidget(self._create_button_box())
    
    def _create_special_char_toolbar(self) -> QHBoxLayout:
        """Create toolbar with special character buttons."""
        toolbar = QHBoxLayout()
        
        # Label
        label = QLabel("Special Characters:")
        toolbar.addWidget(label)
        
        # Character buttons
        special_chars = ['Ã¡', 'Ã½', 'Ã³', 'Ã©', 'Ã­']
        
        for char in special_chars:
            btn = QPushButton(char)
            btn.setMaximumWidth(40)
            btn.setToolTip(f"Insert '{char}' at cursor")
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.clicked.connect(lambda checked, c=char: self._insert_special_char(c))
            toolbar.addWidget(btn)
        
        # Info label
        info = QLabel("(Inserts into focused name field)")
        info.setStyleSheet("color: gray; font-size: 10px;")
        toolbar.addWidget(info)
        
        toolbar.addStretch()
        return toolbar
    
    def _create_form_layout(self) -> QFormLayout:
        """Create form with input fields."""
        form = QFormLayout()
        
        # First Name (required)
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        form.addRow("First Name: *", self.first_name_input)
        
        # Last Name (required)
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        form.addRow("Last Name: *", self.last_name_input)
        
        # Birth Year (required)
        self.birth_year_input = QSpinBox()
        self.birth_year_input.setRange(1000, 2100)
        self.birth_year_input.setValue(1700)
        self.birth_year_input.setSpecialValueText("Unknown")
        form.addRow("Birth Year: *", self.birth_year_input)
        
        # Gender (optional)
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        form.addRow("Gender:", self.gender_input)
        
        # Notes (optional)
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this person...")
        self.notes_input.setMaximumHeight(80)
        form.addRow("Notes:", self.notes_input)
        
        return form
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create OK/Cancel button box."""
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        return button_box
    
    # ------------------------------------------------------------------
    # Signal Handlers
    # ------------------------------------------------------------------
    
    def _connect_signals(self) -> None:
        """Connect widget signals to handlers."""
        # Enter key in line edits should not close dialog accidentally
        self.first_name_input.returnPressed.connect(self.last_name_input.setFocus)
        self.last_name_input.returnPressed.connect(self.birth_year_input.setFocus)
    
    def _insert_special_char(self, char: str) -> None:
        """Insert special character into currently focused name field."""
        focused = self.focusWidget()
        
        # Only insert into line edit fields (name fields)
        if isinstance(focused, QLineEdit):
            focused.insert(char)
    
    def _handle_accept(self) -> None:
        """Validate inputs and create Person object before accepting."""
        if not self._validate_inputs():
            return
        
        # Create Person object from form data
        self._person = Person(
            first_name=self.first_name_input.text().strip(),
            last_name=self.last_name_input.text().strip(),
            birth_year=self.birth_year_input.value(),
            gender=self.gender_input.currentText(),
            notes=self.notes_input.toPlainText().strip()
        )
        
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate that required fields are filled."""
        # Check first name
        if not self.first_name_input.text().strip():
            self._show_error("First name is required.")
            self.first_name_input.setFocus()
            return False
        
        # Check last name
        if not self.last_name_input.text().strip():
            self._show_error("Last name is required.")
            self.last_name_input.setFocus()
            return False
        
        # Check birth year (0 is the special "Unknown" value)
        if self.birth_year_input.value() == 0:
            self._show_error("Birth year is required.")
            self.birth_year_input.setFocus()
            return False
        
        return True
    
    def _show_error(self, message: str) -> None:
        """Display validation error message."""
        QMessageBox.warning(self, "Validation Error", message)
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_person(self) -> Person | None:
        """Return the created Person object, or None if dialog was cancelled."""
        return self._person

>> ðŸ“‹ dialogs\create_child_dialog.py (1 code lines)
"""Dialog for creating a new child with parent selection."""

from PySide6.QtWidgets import QDialog


class CreateChildDialog(QDialog):
    """Dialog for creating a child of selected parents."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the create child dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add name input fields
        # TODO: Add PersonSelector widgets for father/mother
        # TODO: Add DatePicker for birth date
        # TODO: Add gender selection
        # TODO: Add validation logic
        # TODO: Connect to CreateChildCommand
        pass


>> ðŸ“‹ dialogs\create_marriage_dialog.py (1 code lines)
"""Dialog for creating a new marriage between two people."""

from PySide6.QtWidgets import QDialog


class CreateMarriageDialog(QDialog):
    """Dialog for creating a marriage relationship."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the create marriage dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add PersonSelector widgets for husband/wife
        # TODO: Add DatePicker for marriage date
        # TODO: Add marriage_type dropdown (optional)
        # TODO: Add validation logic
        # TODO: Connect to CreateMarriageCommand
        pass


>> ðŸ“‹ dialogs\edit_person_dialog.py (1 code lines)
"""Dialog for editing an existing person."""

from PySide6.QtWidgets import QDialog


class EditPersonDialog(QDialog):
    """Dialog for editing an existing person's data."""

    def __init__(self, parent: 'MainWindow', person_id: int) -> None:  # type: ignore
        """Initialize the edit person dialog."""
        super().__init__(parent)
        self.person_id = person_id
        # TODO: Implement dialog UI
        # TODO: Load existing person data
        # TODO: Add form fields
        # TODO: Add validation logic
        pass


>> ðŸ“‹ dialogs\import_csv_dialog.py (1 code lines)
"""Dialog for importing genealogy data from CSV files."""

from PySide6.QtWidgets import QDialog


class ImportCSVDialog(QDialog):
    """Dialog for CSV import configuration and mapping."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the CSV import dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add file picker for CSV selection
        # TODO: Add column mapping controls
        # TODO: Add preview table
        # TODO: Add import mode selection (replace/merge)
        # TODO: Add progress bar
        # TODO: Connect to CSVImporter utility
        pass


>> ðŸ“‹ dialogs\settings_dialog.py (1 code lines)
"""Dialog for application preferences and settings."""

from PySide6.QtWidgets import QDialog


class PreferencesDialog(QDialog):
    """Dialog for configuring application settings."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the preferences dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI with tabs
        # TODO: Add appearance settings (skin selection)
        # TODO: Add default view selection
        # TODO: Add date format preferences
        # TODO: Add auto-save settings
        # TODO: Load current settings from database
        # TODO: Save settings on OK button
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VIEWS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ views\__init__.py (0 code lines)


>> ðŸ“‹ views\data_table.py (0 code lines)


>> ðŸ“‹ views\dynasty_view.py (0 code lines)


>> ðŸ“‹ views\stats_view\charts.py (2 code lines)
"""Chart widgets for statistical visualizations."""

from PySide6.QtWidgets import QWidget


class Charts(QWidget):
    """Container for various statistical charts and graphs."""

    def __init__(self, database_connection) -> None:
        """Initialize the charts widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add population over time chart
        # TODO: Add birth/death rate chart
        # TODO: Add age distribution histogram
        # TODO: Add family size comparison chart
        # TODO: Use matplotlib or QtCharts for rendering
        # TODO: Add export chart buttons
        pass

    def refresh_charts(self) -> None:
        """Reload data and redraw all charts."""
        # TODO: Reload statistics from database
        # TODO: Regenerate all chart data
        # TODO: Redraw all visualizations
        pass


>> ðŸ“‹ views\stats_view\comparison_widget.py (2 code lines)
"""Widget for comparing statistics between families or people."""

from PySide6.QtWidgets import QWidget


class ComparisonWidget(QWidget):
    """Side-by-side comparison of selected entities."""

    def __init__(self, database_connection) -> None:
        """Initialize the comparison widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add selectors for entities to compare
        # TODO: Display side-by-side statistics
        # TODO: Show comparison charts
        # TODO: Highlight differences
        # TODO: Support comparing families, people, or generations
        pass

    def set_comparison(self, entity1_id: int, entity2_id: int, entity_type: str) -> None:
        """Set which entities to compare."""
        # TODO: Load data for both entities
        # TODO: Calculate comparison metrics
        # TODO: Update display
        pass


>> ðŸ“‹ views\stats_view\family_dashboard.py (2 code lines)
"""Dashboard widget showing dynasty statistics."""

from PySide6.QtWidgets import QWidget


class FamilyDashboard(QWidget):
    """Dashboard displaying key statistics about the dynasty."""

    def __init__(self, database_connection) -> None:
        """Initialize the family dashboard widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Calculate total people count
        # TODO: Calculate total marriages count
        # TODO: Calculate average lifespan
        # TODO: Calculate generation count
        # TODO: Display statistics in grid layout
        # TODO: Add Charts widget for visualizations
        # TODO: Add refresh button
        pass

    def refresh_stats(self) -> None:
        """Recalculate and update all statistics."""
        # TODO: Reload data from database
        # TODO: Recalculate all metrics
        # TODO: Update display widgets
        pass


>> ðŸ“‹ views\table_view\event_table.py (2 code lines)
"""Table view for listing all events in the database."""

from PySide6.QtWidgets import QTableWidget


class EventTable(QTableWidget):
    """Sortable, filterable table of all events."""

    def __init__(self, database_connection) -> None:
        """Initialize the event table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Person, Event Type, Date, Description)
        # TODO: Load all events from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show event details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all events
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\family_table.py (2 code lines)
"""Table view for listing all families in the database."""

from PySide6.QtWidgets import QTableWidget


class FamilyTable(QTableWidget):
    """Sortable, filterable table of all families."""

    def __init__(self, database_connection) -> None:
        """Initialize the family table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Family Name, Member Count, Start Year, etc.)
        # TODO: Load all families from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add double-click handler to show family details
        # TODO: Add right-click menu (edit/view members)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all families
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\marriage_table.py (2 code lines)
"""Table view for listing all marriages in the database."""

from PySide6.QtWidgets import QTableWidget


class MarriageTable(QTableWidget):
    """Sortable, filterable table of all marriages."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Husband, Wife, Start Date, End Date, Type)
        # TODO: Load all marriages from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all marriages
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\person_table.py (2 code lines)
"""Table view for listing all people in the database."""

from PySide6.QtWidgets import QTableWidget


class PersonTable(QTableWidget):
    """Sortable, filterable table of all people."""

    def __init__(self, database_connection) -> None:
        """Initialize the person table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Name, Gender, Birth, Death, etc.)
        # TODO: Load all people from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add row selection highlighting
        # TODO: Add double-click handler to show person details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all people
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\timeline_view\event_marker.py (1 code lines)
"""Visual marker for person events on timeline."""

from PySide6.QtWidgets import QGraphicsWidget


class EventMarker(QGraphicsWidget):
    """Small marker showing an event on a person's timeline bar."""

    def __init__(self, event_id: int) -> None:
        """Initialize the event marker widget."""
        super().__init__()
        self.event_id = event_id
        # TODO: Load event data from database
        # TODO: Draw small icon/shape at event year
        # TODO: Use different colors for event types
        # TODO: Add tooltip showing event details
        # TODO: Add click handler for event editing
        pass


>> ðŸ“‹ views\timeline_view\family_bar.py (1 code lines)
"""Horizontal bar representing a family's timespan."""

from PySide6.QtWidgets import QGraphicsWidget


class FamilyBar(QGraphicsWidget):
    """Visual bar showing family existence over time."""

    def __init__(self, family_id: int) -> None:
        """Initialize the family bar widget."""
        super().__init__()
        self.family_id = family_id
        # TODO: Calculate family start year (earliest member birth)
        # TODO: Calculate family end year (latest member death or current)
        # TODO: Draw horizontal bar spanning timespan
        # TODO: Add family name label
        # TODO: Add click handler to show family details
        # TODO: Add PersonBar widgets for each family member
        pass


>> ðŸ“‹ views\timeline_view\major_event_marker.py (1 code lines)
"""Visual marker for major historical events."""

from PySide6.QtWidgets import QGraphicsWidget


class MajorEventMarker(QGraphicsWidget):
    """Vertical line showing major events across all families."""

    def __init__(self, major_event_id: int) -> None:
        """Initialize the major event marker widget."""
        super().__init__()
        self.major_event_id = major_event_id
        # TODO: Load major event data from database
        # TODO: Draw vertical line at event year
        # TODO: Add event name label
        # TODO: Use distinctive color/style
        # TODO: Add tooltip with event description
        # TODO: Add click handler for editing
        pass


>> ðŸ“‹ views\timeline_view\person_bar.py (1 code lines)
"""Horizontal bar representing a person's lifespan."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBar(QGraphicsWidget):
    """Visual bar showing person's life from birth to death."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person bar widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load person data from database
        # TODO: Calculate x position from birth_year
        # TODO: Calculate width from birth_year to death_year (or current)
        # TODO: Draw horizontal bar with portrait thumbnail
        # TODO: Add name label
        # TODO: Add event markers along bar
        # TODO: Add click handler to show person details
        pass


>> ðŸ“‹ views\timeline_view\timeline_canvas.py (2 code lines)
"""Main canvas for the timeline visualization view."""

from PySide6.QtWidgets import QGraphicsView


class TimelineCanvas(QGraphicsView):
    """Scrollable canvas displaying families and events over time."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the timeline canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Add horizontal time axis (year scale)
        # TODO: Add vertical scrolling for families
        # TODO: Implement zoom for time scale
        # TODO: Add major event markers
        # TODO: Load all families and events from database
        pass

    def refresh_timeline(self) -> None:
        """Reload and redraw entire timeline from database."""
        # TODO: Clear scene
        # TODO: Reload all data
        # TODO: Recreate all visual elements
        pass


>> ðŸ“‹ views\timeline_view.py (0 code lines)


>> ðŸ“‹ views\tree_view\__init__.py (0 code lines)
"""Tree view components for family tree visualization."""


>> ðŸ“‹ views\tree_view\generation_band.py (2 code lines)
"""Horizontal band showing a generation level in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class GenerationBand(QGraphicsWidget):
    """Background band for highlighting a generation level."""

    def __init__(self, generation: int, y_position: float, height: float) -> None:
        """Initialize the generation band widget."""
        super().__init__()
        self.generation = generation
        self.y_position = y_position
        self.height = height
        # TODO: Draw horizontal background rectangle
        # TODO: Use alternating colors for visual separation
        # TODO: Add generation label on left side
        # TODO: Update position when tree layout changes
        pass

    def update_position(self, new_y: float, new_height: float) -> None:
        """Adjust band position and height."""
        # TODO: Update y_position and height
        # TODO: Redraw band
        pass


>> ðŸ“‹ views\tree_view\layout_engine.py (2 code lines)
"""Automatic layout engine for positioning people in the tree."""


class TreeLayoutEngine:
    """Calculate automatic positions for people in the family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the layout engine."""
        self.db = database_connection

    def calculate_positions(self) -> dict[int, tuple[float, float]]:
        """Calculate x,y positions for all people."""
        # TODO: Implement generational hierarchy algorithm
        # TODO: Group siblings together
        # TODO: Consider cohort positioning (move-in dates)
        # TODO: Return dict: person_id -> (x, y)
        pass


>> ðŸ“‹ views\tree_view\marriage_node.py (1 code lines)
"""Visual representation of a marriage in the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class MarriageNode(QGraphicsWidget):
    """Node connecting spouses in the family tree."""

    def __init__(self, marriage_id: int) -> None:
        """Initialize the marriage node widget."""
        super().__init__()
        self.marriage_id = marriage_id
        # TODO: Draw small connector shape (circle/diamond)
        # TODO: Display marriage date on hover
        # TODO: Connect to both spouse PersonBox widgets
        # TODO: Add click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete marriage)
        pass


>> ðŸ“‹ views\tree_view\person_box.py (1 code lines)
"""Person box widget for the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBox(QGraphicsWidget):
    """Visual representation of a person in the family tree."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person box widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Add portrait display
        # TODO: Add name label
        # TODO: Add dates label
        # TODO: Add gear icon button
        # TODO: Implement drag functionality
        # TODO: Implement click handlers
        pass


>> ðŸ“‹ views\tree_view\relationship_line.py (7 code lines)
"""Visual line connecting related people in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class RelationshipLine(QGraphicsWidget):
    """Line connecting parent to child or spouse to spouse."""

    def __init__(
        self,
        start_person_id: int,
        end_person_id: int,
        line_type: str,  # "parent", "marriage", "sibling"
    ) -> None:
        """Initialize the relationship line widget."""
        super().__init__()
        self.start_person_id = start_person_id
        self.end_person_id = end_person_id
        self.line_type = line_type
        # TODO: Draw line between two PersonBox widgets
        # TODO: Use different styles for different line types
        # TODO: Update position when PersonBox moves
        # TODO: Add hover highlighting
        pass

    def update_endpoints(self) -> None:
        """Recalculate line position based on connected boxes."""
        # TODO: Get current positions of connected PersonBox widgets
        # TODO: Redraw line with new coordinates
        pass


>> ðŸ“‹ views\tree_view\tree_canvas.py (1 code lines)
"""Main canvas for displaying the family tree."""

from PySide6.QtWidgets import QGraphicsView


class TreeCanvas(QGraphicsView):
    """Scrollable, zoomable canvas for displaying the family tree."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the tree canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Implement zoom functionality
        # TODO: Implement pan functionality
        # TODO: Add minimap (optional)
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WIDGETS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ widgets\__init__.py (0 code lines)


>> ðŸ“‹ widgets\date_picker.py (1 code lines)
"""Custom date picker widget supporting flexible precision."""

from PySide6.QtWidgets import QWidget


class DatePicker(QWidget):
    """Widget for entering dates with flexible precision."""

    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the date picker widget."""
        super().__init__(parent)
        # TODO: Add year spinbox
        # TODO: Add month combobox (with None option)
        # TODO: Add day spinbox (with None option)
        # TODO: Implement date validation logic
        # TODO: Add get_date() method
        # TODO: Add set_date() method
        pass


>> ðŸ“‹ widgets\extended_details_panel.py (2 code lines)
"""Panel widget for displaying detailed person information."""

from PySide6.QtWidgets import QWidget


class ExtendedDetailsPanel(QWidget):
    """Panel showing comprehensive person details and relationships."""

    def __init__(self, person_id: int | None = None) -> None:
        """Initialize the extended details panel."""
        super().__init__()
        self.person_id = person_id
        # TODO: Display full person information
        # TODO: Show all marriages with dates
        # TODO: Show all children with clickable links
        # TODO: Show all events in chronological order
        # TODO: Show portrait gallery
        # TODO: Add edit button for each section
        # TODO: Add relationship path calculator
        pass

    def set_person(self, person_id: int) -> None:
        """Update panel to show different person."""
        # TODO: Clear current display
        # TODO: Load new person data
        # TODO: Refresh all sections
        pass


>> ðŸ“‹ widgets\person_selector.py (1 code lines)
"""Widget for selecting a person from the database."""

from PySide6.QtWidgets import QWidget


class PersonSelector(QWidget):
    """Searchable dropdown widget for selecting a person."""

    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the person selector widget."""
        super().__init__(parent)
        # TODO: Add search field
        # TODO: Add dropdown list
        # TODO: Implement real-time filtering
        # TODO: Load people from database
        # TODO: Add get_selected_person() method
        pass


>> ðŸ“‹ widgets\portrait_gallery.py (1 code lines)
"""Widget for displaying and managing person portraits."""

from PySide6.QtWidgets import QWidget


class PortraitGallery(QWidget):
    """Gallery widget for viewing and selecting portraits."""

    def __init__(self, person_id: int) -> None:
        """Initialize the portrait gallery widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load portraits from Portrait table
        # TODO: Display portraits in grid layout
        # TODO: Add portrait selection highlighting
        # TODO: Add upload new portrait button
        # TODO: Add delete portrait button
        # TODO: Emit signal on portrait selection
        pass


>> ðŸ“‹ widgets\search_bar.py (2 code lines)
"""Search bar widget for finding people by name."""

from PySide6.QtWidgets import QWidget


class SearchBar(QWidget):
    """Search widget with autocomplete for finding people."""

    def __init__(self) -> None:
        """Initialize the search bar widget."""
        super().__init__()
        # TODO: Add QLineEdit for search input
        # TODO: Implement autocomplete using QCompleter
        # TODO: Load all person names from database
        # TODO: Add search icon/button
        # TODO: Add clear button
        # TODO: Emit signal when person is selected
        # TODO: Support fuzzy matching (optional)
        pass

    def update_completions(self) -> None:
        """Refresh autocomplete list from database."""
        # TODO: Reload all person names
        # TODO: Update QCompleter model
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UTILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ utils\__init__.py (0 code lines)
"""Utility modules for calculations and helpers."""


>> ðŸ“‹ utils\color_manager.py (5 code lines)
"""Color utilities for UI elements."""

from PySide6.QtGui import QColor


class ColorManager:
    """Manage colors for various UI elements."""

    def __init__(self) -> None:
        """Initialize the color manager."""
        # TODO: Define color palettes
        # TODO: Define gender-specific colors
        # TODO: Define generation band colors
        # TODO: Define event type colors
        pass

    def get_person_color(self, gender: str | None) -> QColor: # type: ignore 
        """Get color for person based on gender."""
        # TODO: Return blue for male
        # TODO: Return pink for female
        # TODO: Return gray for unknown
        pass

    def get_generation_color(self, generation: int) -> QColor: # type: ignore 
        """Get alternating color for generation bands."""
        # TODO: Return alternating colors based on generation number
        pass

    def get_event_color(self, event_type: str) -> QColor: # type: ignore 
        """Get color for event type."""
        # TODO: Return different colors for different event types
        # TODO: Birth, death, marriage, arrival, etc.
        pass

    def interpolate_color(self, color1: QColor, color2: QColor, ratio: float) -> QColor: # type: ignore 
        """Blend two colors together."""
        # TODO: Calculate intermediate color
        # TODO: Return blended QColor
        pass


>> ðŸ“‹ utils\csv_importer.py (4 code lines)
"""CSV import utility for bulk data loading."""

import csv


class CSVImporter:
    """Import genealogy data from CSV files."""

    def __init__(self, database_connection) -> None:
        """Initialize the CSV importer."""
        self.db = database_connection

    def import_people(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import people from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert people into database
        # TODO: Return count of imported people
        pass

    def import_marriages(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import marriages from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data (check person IDs exist)
        # TODO: Insert marriages into database
        # TODO: Return count of imported marriages
        pass

    def import_events(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import events from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert events into database
        # TODO: Return count of imported events
        pass


>> ðŸ“‹ utils\generation_calculator.py (2 code lines)
"""Calculate generation levels for all people."""


class GenerationCalculator:
    """Compute generation levels for genealogical hierarchy."""

    def __init__(self, database_connection) -> None:
        """Initialize the generation calculator."""
        self.db = database_connection

    def recompute_all_generations(self) -> None:
        """Recalculate generation levels for all people."""
        # TODO: Find all founders (no parents)
        # TODO: Run BFS from founders
        # TODO: Assign generation numbers
        # TODO: Handle edge cases (adoptions, step-relations)
        pass


>> ðŸ“‹ utils\relationship_calculator.py (3 code lines)
"""Calculate relationships between people using graph traversal."""


class RelationshipCalculator:
    """Calculate familial relationships between two people."""

    def __init__(self, database_connection) -> None:
        """Initialize the relationship calculator."""
        self.db = database_connection

    def find_relationship_path(self, person1_id: int, person2_id: int) -> list[int] | None:
        """Find the shortest relationship path between two people."""
        # TODO: Implement BFS graph traversal
        # TODO: Return list of person IDs in the path
        pass

    def describe_relationship(self, person1_id: int, person2_id: int) -> str:
        """Return a human-readable relationship description."""
        # TODO: Implement relationship naming logic
        # TODO: Handle parents, siblings, cousins, etc.
        # TODO: Handle "removed" relationships
        pass


>> âœ… utils\settings_manager.py (81 code lines)
"""User preferences and settings management."""

from __future__ import annotations
from typing import Any
from PySide6.QtCore import QSettings

class SettingsManager:
    """Manages user preferences and disk persistence."""

    DEFAULTS = {
        "shortcuts": {
            # File Menu shortcuts
            "file.new": "Ctrl+N",
            "file.open": "Ctrl+O",
            "file.save": "Ctrl+S",
            "file.save_as": "Ctrl+Shift+S",
            "file.exit": "Ctrl+Q",

            # Edit Menu shortcuts
            "edit.undo": "Ctrl+Z",
            "edit.redo": "Ctrl+Y",
            "edit.add_person": "Ctrl+P",
            "edit.remove_person": "Del",
            "edit.add_new_family": "Ctrl+F",

            # View Menu shortcuts
            "view.family_trees": "Ctrl+1",
            "view.timeline": "Ctrl+2",
            "view.dynasty": "Ctrl+3",
            "view.data_table": "Ctrl+4",

            # Tools Menu shortcuts
            "tools.rebuild_scene": "F5",
            "tools.recompute_generations": "Ctrl+R",
            "tools.validate_marriages": "Ctrl+M",
            "tools.validate_parentage": "Ctrl+Shift+P",

            # Settings Menu shortcuts
            "settings.settings": "Ctrl+,",
            "settings.general": "",
            "settings.shortcuts": "",
            "settings.display": "",
            "settings.appearance": "",
            "settings.formats": "",

            # Help Menu shortcuts
            "help.about": "F1",
        },

        "general": {
            # TODO: Define general settings defaults
            # e.g., autosave interval, default file paths, etc.
            # including different header sections as above
        },

        "display": {
            # TODO: Define display settings defaults
            # e.g., default zoom level, layout preferences, etc.
            # including different header sections as above
            # window size, position, maximized state, fonts, themes etc.
        },

        "appearance": {
            # TODO: Define appearance settings defaults
            # e.g., color schemes, node styles, edge styles, Colorblindness modes,
            # Male/Female/Unknown color preferences, generation band colors, genetic line styles, etc.
            # including different header sections as above to keep things organized
        },

        "formats": {
            # TODO: Define format settings defaults
            # e.g., date formats, name display formats, event display formats, etc.
            # Undo/Redo stack size, autosave file format, import/export preferences, etc.
            # including different header sections as above
        },
    }

    def __init__(self) -> None:
        """Initialize settings manager and load user settings."""
        
        self.qsettings = QSettings("DynastyVizualizer", "DynastyVisualizer")

        self.custom_shortcuts: dict[str, str | None] = {}
        self.custom_general: dict[str, Any] = {}
        self.custom_display: dict[str, Any] = {}
        self.custom_appearance: dict[str, Any] = {}
        self.custom_formats: dict[str, Any] = {}
    
        self._load_from_disk()

    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------

    def _get_custom_dict(self, category: str) -> dict[str, Any]:
        """Get the custom dictionary for a given category."""
        category_map = {
            "shortcuts": self.custom_shortcuts,
            "general": self.custom_general,
            "display": self.custom_display,
            "appearance": self.custom_appearance,
            "formats": self.custom_formats,
        }
        return category_map.get(category, {})

    def _load_from_disk(self) -> None:
        """Load user's saved settings from disk."""
        for category in self.DEFAULTS.keys():
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if self.qsettings.contains(key):
                    value = self.qsettings.value(key)
                    custom_dict[key] = value if value else None
            
            self.qsettings.endGroup()
    def _save_to_disk(self) -> None:
        """Save user's custom settings to disk."""
        for category in self.DEFAULTS.keys():
            # Clear existing category on disk
            self.qsettings.beginGroup(category)
            self.qsettings.remove("")
            self.qsettings.endGroup()
            
            # Save only settings that exist in current DEFAULTS
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if key in custom_dict:  
                    value = custom_dict[key]
                    default = self.DEFAULTS[category][key]

                    if value != default:
                        self.qsettings.setValue(key, value if value else "")
            
            self.qsettings.endGroup()
        
        self.qsettings.sync()

    # ------------------------------------------------------------------
    # Shortcut Operations (Specific, Type-Safe)
    # ------------------------------------------------------------------

    def get_shortcut(self, action_name: str) -> str:
        """Get the shortcut for a given action, falling back to default if not customized."""
        return self.get_setting("shortcuts", action_name)

    def set_shortcut(self, action_name: str, shortcut: str) -> None:
        """Set custom shortcut in memory without saving to disk."""
        self.set_setting("shortcuts", action_name, shortcut)

        if shortcut:
            for other_action in list(self.custom_shortcuts.keys()):
                if other_action != action_name:
                    if self.custom_shortcuts[other_action] == shortcut:
                        self.custom_shortcuts[other_action] = None


    # ------------------------------------------------------------------
    # Generic Settings Operations
    # ------------------------------------------------------------------

    def get_setting(self, category: str, key: str) -> Any:
        """Get setting from any category, checking custom then default."""
        # Check custom value first
        custom_dict = self._get_custom_dict(category)
        if key in custom_dict:
            value = custom_dict[key]
            return value if value is not None else ""
        
        # Fall back to default
        if category in self.DEFAULTS and key in self.DEFAULTS[category]:
            return self.DEFAULTS[category][key]
        
        return ""
    
    def set_setting(self, category: str, key: str, value: Any) -> None:
        """Set setting in any category (memory only, not saved to disk)."""
        custom_dict = self._get_custom_dict(category)
        custom_dict[key] = value if value else None

    # ------------------------------------------------------------------
    # Save/Discard/Reset Operations
    # ------------------------------------------------------------------

    def save(self) -> None:
        """Save all custom settings to disk."""
        self._save_to_disk()

    def discard_changes(self) -> None:
        """Discard unsaved changes by reloading from disk."""
        self.custom_shortcuts.clear()
        self.custom_general.clear()
        self.custom_display.clear()
        self.custom_appearance.clear()
        self.custom_formats.clear()
        self._load_from_disk()

    def reset_category_to_defaults(self, category: str) -> None:
        """Reset one category to defaults and save to disk."""
        custom_dict = self._get_custom_dict(category)
        custom_dict.clear()
        self._save_to_disk()

    def reset_all_to_defaults(self) -> None:
        """Reset all categories to defaults and save to disk."""
        for category in self.DEFAULTS.keys():
            self.reset_category_to_defaults(category)

>> ðŸ“‹ utils\skin_manager.py (4 code lines)
"""Skin/theme management for UI customization."""

from PySide6.QtWidgets import QApplication


class SkinManager:
    """Manage application color schemes and themes."""

    def __init__(self) -> None:
        """Initialize the skin manager with built-in themes."""
        self.skins: dict[str, dict[str, str]] = {}
        # TODO: Define default skin
        # TODO: Define dark mode skin
        # TODO: Define light mode skin
        # TODO: Define custom color schemes
        pass

    def load_skin(self, skin_name: str) -> None:
        """Apply a color scheme to the application."""
        # TODO: Get color definitions for skin_name
        # TODO: Generate QSS stylesheet
        # TODO: Apply to QApplication
        pass

    def get_available_skins(self) -> list[str]:
        """Get list of available skin names."""
        # TODO: Return list of skin keys
        pass

    def create_custom_skin(self, name: str, colors: dict[str, str]) -> None:
        """Create a new custom color scheme."""
        # TODO: Validate color values
        # TODO: Store in skins dictionary
        # TODO: Optionally save to Settings table
        pass


>> ðŸ“‹ utils\validators.py (5 code lines)
"""Data validation tools for detecting inconsistencies."""


class MarriageValidator:
    """Validate marriage data for inconsistencies."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all marriages for issues."""
        # TODO: Check for overlapping marriages
        # TODO: Check for invalid dates
        # TODO: Check for self-marriages
        # TODO: Return list of issues
        pass


class ParentageValidator:
    """Validate parent-child relationships."""

    def __init__(self, database_connection) -> None:
        """Initialize the parentage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all parentage relationships for issues."""
        # TODO: Check for circular parentage
        # TODO: Check for impossible dates
        # TODO: Return list of issues
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCRIPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… scripts\create_codebase_summary.py (119 code lines)
"""
Generate dynasty_codebase.txt - Complete codebase snapshot optimized for LLMs.

Creates a token-efficient snapshot of ALL source code that LLMs can use to
understand the complete project state in a single context window.

Usage:
    python scripts/create_codebase_summary.py

Output:
    dynasty_codebase.txt - Complete codebase, LLM-optimized

Features:
    - Token-efficient: Minimal headers, maximum code density
    - Complete: ALL Python files included
    - Organized: Grouped by category for easy parsing
    - Compact: No visual trees, just clean code listings
    - Smart encoding: Handles UTF-8, UTF-16
"""

import os
from pathlib import Path
from datetime import datetime
from typing import List, Tuple


# Configuration
OUTPUT_FILE = "dynasty_codebase.txt"
PROJECT_NAME = "DynastyVizualizer"

# Files/directories to ignore
IGNORE_PATTERNS = {
    "__pycache__", ".git", ".pytest_cache", ".venv", "venv", "env",
    ".env", "*.pyc", "*.pyo", "*.pyd", ".DS_Store", "*.egg-info",
    "dist", "build", ".idea", ".vscode", "*.dyn", "*.backup",
    "node_modules", "*.md", "dynasty_codebase.txt"
}

# File extensions to include
SOURCE_EXTENSIONS = {".py"}

# Config files to include
CONFIG_FILES = {"requirements.txt"}


def should_ignore(path: Path) -> bool:
    """Check if path or any parent should be ignored."""
    path_str = str(path)
    
    # Check if any part of the path matches ignore patterns
    for part in path.parts:
        if part in IGNORE_PATTERNS:
            return True
    
    # Check filename patterns
    name = path.name
    for pattern in IGNORE_PATTERNS:
        if "*" in pattern:
            ext = pattern.replace("*", "")
            if path_str.endswith(ext):
                return True
    
    if name == OUTPUT_FILE:
        return True
    
    return False

def count_code_lines(filepath: Path) -> int:
    """Count non-empty, non-comment lines."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            count = 0
            in_multiline = False

            for line in f:
                stripped = line.strip()
                if not stripped:
                    continue

                if '"""' in stripped or "'''" in stripped:
                    in_multiline = not in_multiline
                    continue

                if in_multiline or stripped.startswith('#'):
                    continue

                count += 1

            return count
    except Exception:
        return 0


def discover_files(root_dir: Path) -> Tuple[List[Path], List[Path]]:
    """Discover all source and config files."""
    source_files = []
    config_files = []

    for path in sorted(root_dir.rglob("*")):
        if path.is_dir() or should_ignore(path):
            continue

        if path.suffix in SOURCE_EXTENSIONS:
            source_files.append(path)
        elif path.name in CONFIG_FILES:
            config_files.append(path)

    return source_files, config_files


def get_relative_path(filepath: Path, root: Path) -> str:
    """Get path relative to project root."""
    try:
        return str(filepath.relative_to(root))
    except ValueError:
        return str(filepath)


def read_file_content(filepath: Path) -> str:
    """Read file content with multiple encoding support."""
    for encoding in ['utf-8', 'utf-16', 'utf-16-le', 'latin-1']:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                content = f.read()
                if '\x00' not in content or encoding.startswith('utf-16'):
                    return content
        except (UnicodeDecodeError, Exception):
            continue

    try:
        with open(filepath, 'rb') as f:
            return f.read().decode('utf-8', errors='replace')
    except Exception as e:
        return f"[Error: {e}]"


def categorize_files(source_files: List[Path], root: Path) -> dict:
    """Organize files by category."""
    categories = {
        "Core": [], "Database": [], "Models": [], "Actions": [],
        "Commands": [], "Dialogs": [], "Views": [], "Widgets": [],
        "Utils": [], "Scripts": []
    }

    for f in source_files:
        rel_path = get_relative_path(f, root)
        parent = str(Path(rel_path).parent)

        if rel_path == "main.py":
            categories["Core"].append(f)
        elif "database" in parent:
            categories["Database"].append(f)
        elif "models" in parent:
            categories["Models"].append(f)
        elif "actions" in parent:
            categories["Actions"].append(f)
        elif "commands" in parent:
            categories["Commands"].append(f)
        elif "dialogs" in parent:
            categories["Dialogs"].append(f)
        elif "views" in parent:
            categories["Views"].append(f)
        elif "widgets" in parent:
            categories["Widgets"].append(f)
        elif "utils" in parent:
            categories["Utils"].append(f)
        elif "scripts" in parent:
            categories["Scripts"].append(f)
        else:
            categories["Core"].append(f)

    return categories


def generate_summary(root_dir: Path) -> None:
    """Generate the token-efficient codebase snapshot."""

    print(f"ðŸ” Discovering files in {PROJECT_NAME}...")
    source_files, config_files = discover_files(root_dir)

    total_files = len(source_files)
    implemented = sum(1 for f in source_files if count_code_lines(f) > 20)
    code_lines = sum(count_code_lines(f) for f in source_files)

    print(f"ðŸ“Š Found {total_files} files ({implemented} implemented, {code_lines} code lines)")

    categories = categorize_files(source_files, root_dir)
    output_path = root_dir / OUTPUT_FILE

    with open(output_path, 'w', encoding='utf-8') as out:
        # Compact header
        out.write(f"{'='*70}\n")
        out.write(f"{PROJECT_NAME} - Complete Codebase\n")
        out.write(f"{'='*70}\n")
        out.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        out.write(f"Files: {implemented}/{total_files} implemented | {code_lines} code lines\n")
        out.write(f"Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern\n")
        out.write(f"Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)\n")
        out.write(f"{'='*70}\n\n")

        # Quick context
        out.write("QUICK CONTEXT:\n")
        out.write("Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,\n")
        out.write("undo/redo, flexible dates, special char support, DB migration.\n")
        out.write("Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database\n\n")

        # File index (compact)
        out.write("FILE INDEX:\n")
        for category, files in categories.items():
            if files:
                out.write(f"{category}: ")
                file_names = [get_relative_path(f, root_dir) for f in sorted(files)]
                out.write(", ".join(file_names[:5]))
                if len(files) > 5:
                    out.write(f", ... ({len(files)} total)")
                out.write("\n")
        out.write(f"\n{'='*70}\n")
        out.write("COMPLETE SOURCE CODE\n")
        out.write(f"{'='*70}\n\n")

        # Output code by category (compact format)
        for category, files in categories.items():
            if not files:
                continue

            out.write(f"\n{'â”€'*70}\n")
            out.write(f"{category.upper()}\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in sorted(files):
                rel_path = get_relative_path(filepath, root_dir)
                lines = count_code_lines(filepath)
                status = "âœ…" if lines > 20 else "ðŸ“‹"

                # Compact file header
                out.write(f">> {status} {rel_path} ({lines} code lines)\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

                print(f"âœ… {rel_path} ({lines} lines)")

        # Config files
        if config_files:
            out.write(f"\n{'â”€'*70}\n")
            out.write("CONFIGURATION\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in config_files:
                rel_path = get_relative_path(filepath, root_dir)
                out.write(f">> {rel_path}\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

        # Compact footer
        out.write(f"\n{'='*70}\n")
        out.write(f"END - {implemented}/{total_files} files, {code_lines} code lines\n")
        out.write(f"{'='*70}\n")

    print(f"\nâœ… Generated {OUTPUT_FILE}")
    print(f"ðŸ“Š {implemented}/{total_files} files, {code_lines:,} code lines")
    print(f"ðŸ“„ Output: {output_path}")
    print(f"ðŸ¤– Token-optimized for LLM consumption!\n")


if __name__ == "__main__":
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)

    print(f"{'='*60}")
    print(f"  {PROJECT_NAME} - Codebase Generator")
    print(f"{'='*60}\n")

    generate_summary(project_root)


>> âœ… scripts\migrate_database.py (57 code lines)
"""
Migration script to upgrade existing .dyn files to the new schema.

This script safely adds:
1. Day fields to all date columns (birth, death, arrival, etc.)
2. New tables (Portrait, Family, MajorEvent, PersonPosition, Settings)
3. Additional Person fields (maiden_name, family_id, notes)
4. Marriage type field

Usage:
    python scripts/migrate_database.py <path_to_dynasty_file.dyn>

Example:
    python scripts/migrate_database.py "MyDynasty.dyn"

This migration is SAFE:
- Existing data is preserved (new columns are NULL)
- No data is deleted or modified
- Backup is created before migration
"""

import sqlite3
import shutil
import sys
from pathlib import Path


def backup_database(file_path: str) -> str:
    """Create a backup of the database before migration."""
    backup_path = f"{file_path}.backup"
    shutil.copy2(file_path, backup_path)
    print(f"âœ… Backup created: {backup_path}")
    return backup_path


def get_existing_columns(cursor: sqlite3.Cursor, table_name: str) -> list[str]:
    """Get list of existing columns in a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return [row[1] for row in cursor.fetchall()]


def migrate_database(file_path: str) -> None:
    """Migrate an existing .dyn database to the new schema."""

    if not Path(file_path).exists():
        print(f"âŒ Error: File '{file_path}' not found")
        sys.exit(1)

    print(f"Migrating database: {file_path}")
    print("=" * 60)

    # Create backup
    backup_path = backup_database(file_path)

    try:
        # Connect to database
        conn = sqlite3.connect(file_path)
        conn.execute("PRAGMA foreign_keys = ON;")
        cursor = conn.cursor()

        # Migrate Person table
        print("\nðŸ“ Migrating Person table...")
        person_columns = get_existing_columns(cursor, "Person")

        person_migrations = [
            ("birth_day", "ALTER TABLE Person ADD COLUMN birth_day INTEGER"),
            ("death_day", "ALTER TABLE Person ADD COLUMN death_day INTEGER"),
            ("arrival_day", "ALTER TABLE Person ADD COLUMN arrival_day INTEGER"),
            ("moved_out_day", "ALTER TABLE Person ADD COLUMN moved_out_day INTEGER"),
            ("maiden_name", "ALTER TABLE Person ADD COLUMN maiden_name TEXT"),
            ("family_id", "ALTER TABLE Person ADD COLUMN family_id INTEGER REFERENCES Family(id) ON DELETE SET NULL"),
            ("notes", "ALTER TABLE Person ADD COLUMN notes TEXT"),
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
        ]

        for col_name, sql in person_migrations:
            if col_name not in person_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Event table
        print("\nðŸ“ Migrating Event table...")
        event_columns = get_existing_columns(cursor, "Event")

        event_migrations = [
            ("start_day", "ALTER TABLE Event ADD COLUMN start_day INTEGER"),
            ("end_day", "ALTER TABLE Event ADD COLUMN end_day INTEGER"),
        ]

        for col_name, sql in event_migrations:
            if col_name not in event_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Marriage table
        print("\nðŸ“ Migrating Marriage table...")
        marriage_columns = get_existing_columns(cursor, "Marriage")

        marriage_migrations = [
            ("marriage_day", "ALTER TABLE Marriage ADD COLUMN marriage_day INTEGER"),
            ("dissolution_day", "ALTER TABLE Marriage ADD COLUMN dissolution_day INTEGER"),
            ("marriage_type", "ALTER TABLE Marriage ADD COLUMN marriage_type TEXT DEFAULT 'spouse'"),
        ]

        for col_name, sql in marriage_migrations:
            if col_name not in marriage_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Create new tables
        print("\nðŸ“ Creating new tables...")

        new_tables = {
            "Portrait": """
                CREATE TABLE IF NOT EXISTS Portrait (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    person_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    valid_from_year INTEGER,
                    valid_from_month INTEGER,
                    valid_from_day INTEGER,
                    valid_to_year INTEGER,
                    valid_to_month INTEGER,
                    valid_to_day INTEGER,
                    is_primary INTEGER DEFAULT 0,
                    display_order INTEGER DEFAULT 0,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Family": """
                CREATE TABLE IF NOT EXISTS Family (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    surname TEXT NOT NULL,
                    move_in_year INTEGER,
                    move_in_month INTEGER,
                    move_in_day INTEGER,
                    coat_of_arms_path TEXT,
                    family_color TEXT,
                    is_extinct INTEGER DEFAULT 0,
                    notes TEXT
                )
            """,
            "MajorEvent": """
                CREATE TABLE IF NOT EXISTS MajorEvent (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_name TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    start_year INTEGER NOT NULL,
                    start_month INTEGER,
                    start_day INTEGER,
                    end_year INTEGER,
                    end_month INTEGER,
                    end_day INTEGER,
                    description TEXT,
                    color TEXT
                )
            """,
            "PersonPosition": """
                CREATE TABLE IF NOT EXISTS PersonPosition (
                    person_id INTEGER PRIMARY KEY,
                    view_type TEXT NOT NULL,
                    x_position REAL NOT NULL,
                    y_position REAL NOT NULL,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Settings": """
                CREATE TABLE IF NOT EXISTS Settings (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL
                )
            """
        }

        for table_name, create_sql in new_tables.items():
            # Check if table exists
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (table_name,)
            )
            if cursor.fetchone():
                print(f"  â­ï¸  Table already exists: {table_name}")
            else:
                cursor.execute(create_sql)
                print(f"  âœ… Created table: {table_name}")

        # Commit all changes
        conn.commit()
        conn.close()

        print("\n" + "=" * 60)
        print("âœ… Migration completed successfully!")
        print(f"âœ… Original database backed up to: {backup_path}")
        print(f"âœ… Migrated database: {file_path}")
        print("\nYour database is now ready for the full feature set!")
        print("All existing data has been preserved.")

    except Exception as e:
        print(f"\nâŒ Migration failed: {e}")
        print(f"Restoring from backup: {backup_path}")
        shutil.copy2(backup_path, file_path)
        print("âœ… Database restored to original state")
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/migrate_database.py <path_to_dynasty_file.dyn>")
        print("\nExample:")
        print('  python scripts/migrate_database.py "MyDynasty.dyn"')
        sys.exit(1)

    dynasty_file = sys.argv[1]
    migrate_database(dynasty_file)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONFIGURATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> requirements.txt
packaging==25.0
PySide6==6.10.1
PySide6_Addons==6.10.1
PySide6_Essentials==6.10.1
QtPy==2.4.3
shiboken6==6.10.1



======================================================================
END - 11/94 files, 1186 code lines
======================================================================
