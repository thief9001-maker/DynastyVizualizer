======================================================================
DynastyVizualizer - Complete Codebase
======================================================================
Generated: 2025-12-29 01:29
Files: 23/100 implemented | 2013 code lines
Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern
Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)
======================================================================

QUICK CONTEXT:
Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,
undo/redo, flexible dates, special char support, DB migration.
Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database

FILE INDEX:
Core: main.py, test_edit_person_dialog.py
Database: database\__init__.py, database\db_manager.py, database\marriage_repository.py, database\person_repository.py
Models: models\__init__.py, models\event.py, models\family.py, models\major_event.py, models\marriage.py, ... (7 total)
Actions: actions\__init__.py, actions\edit_actions.py, actions\file_actions.py, actions\help_actions.py, actions\settings_actions.py, ... (7 total)
Commands: commands\__init__.py, commands\base_command.py, commands\genealogy_commands\__init__.py, commands\genealogy_commands\add_event.py, commands\genealogy_commands\add_marriage.py, ... (28 total)
Dialogs: dialogs\__init__.py, dialogs\about_dialog.py, dialogs\add_person_dialog.py, dialogs\create_child_dialog.py, dialogs\create_marriage_dialog.py, ... (13 total)
Views: views\__init__.py, views\data_table.py, views\dynasty_view.py, views\stats_view\charts.py, views\stats_view\comparison_widget.py, ... (23 total)
Widgets: widgets\__init__.py, widgets\date_picker.py, widgets\extended_details_panel.py, widgets\person_selector.py, widgets\portrait_gallery.py, ... (6 total)
Utils: utils\__init__.py, utils\color_manager.py, utils\csv_importer.py, utils\generation_calculator.py, utils\relationship_calculator.py, ... (8 total)
Scripts: scripts\create_codebase_summary.py, scripts\migrate_database.py

======================================================================
COMPLETE SOURCE CODE
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… main.py (159 code lines)
import sys

from PySide6.QtWidgets import QApplication, QMainWindow, QMenuBar, QMessageBox
from PySide6.QtGui import QAction

from database.db_manager import DatabaseManager
from actions import FileActions, EditActions, ViewActions, ToolsActions, HelpActions, SettingsActions
from commands.undo_redo_manager import UndoRedoManager
from utils.settings_manager import SettingsManager

class MainWindow(QMainWindow):
    """Main application window for Dynasty Visualizer."""

    def __init__(self) -> None:
        """Initialize the main window and all UI components."""
        super().__init__()

        self.setWindowTitle("Dynasty Visualizer")
        self.resize(1000, 700)

        # Initialize database manager
        self.db = DatabaseManager(self)

        # Initialize undo/redo manager
        self.undo_manager = UndoRedoManager()

        # Initialize settings manager
        self.settings_manager = SettingsManager()

        # Initialize action handlers
        self.file_actions = FileActions(self)
        self.edit_actions = EditActions(self)
        self.view_actions = ViewActions(self)
        self.tools_actions = ToolsActions(self)
        self.settings_actions = SettingsActions(self)
        self.help_actions = HelpActions(self)

        # Create UI elements
        self._create_menus()

        # Connect menu actions to handlers
        self._connect_actions()

        # Update window title and menu states
        self._update_window_title()
        self._update_menu_states()

    # ------------------------------------------------------------------
    # UI Creation
    # ------------------------------------------------------------------

    def _create_menus(self) -> None:
        """Create all menu bars and menu items."""
        menubar = self.menuBar()

        self._create_file_menu(menubar)
        self._create_edit_menu(menubar)
        self._create_view_menu(menubar)
        self._create_tools_menu(menubar)
        self._create_settings_menu(menubar)
        self._create_help_menu(menubar)

    def _create_file_menu(self, menubar: QMenuBar) -> None:
        """Create the File menu with all file operations."""
        file_menu = menubar.addMenu("File")

        self.action_new_dynasty = QAction("New Dynasty", self)
        self.action_new_dynasty.setObjectName("file.new")
        self.action_new_dynasty.setShortcut(self.settings_manager.get_shortcut("file.new"))

        self.action_open_dynasty = QAction("Open Dynasty", self)
        self.action_open_dynasty.setObjectName("file.open")
        self.action_open_dynasty.setShortcut(self.settings_manager.get_shortcut("file.open"))

        self.action_save = QAction("Save", self)
        self.action_save.setObjectName("file.save")
        self.action_save.setShortcut(self.settings_manager.get_shortcut("file.save"))
        
        self.action_save_as = QAction("Save As", self)
        self.action_save_as.setObjectName("file.save_as")
        self.action_save_as.setShortcut(self.settings_manager.get_shortcut("file.save_as"))

        self.action_exit = QAction("Exit", self)
        self.action_exit.setObjectName("file.exit")
        self.action_exit.setShortcut(self.settings_manager.get_shortcut("file.exit"))

        file_menu.addAction(self.action_new_dynasty)
        file_menu.addAction(self.action_open_dynasty)
        file_menu.addSeparator()
        file_menu.addAction(self.action_save)
        file_menu.addAction(self.action_save_as)
        file_menu.addSeparator()
        file_menu.addAction(self.action_exit)

    def _create_edit_menu(self, menubar: QMenuBar) -> None:
        """Create the Edit menu with editing operations."""
        edit_menu = menubar.addMenu("Edit")

        self.action_undo = QAction("Undo", self)
        self.action_undo.setObjectName("edit.undo")
        self.action_undo.setShortcut(self.settings_manager.get_shortcut("edit.undo"))

        self.action_redo = QAction("Redo", self)
        self.action_redo.setObjectName("edit.redo")
        self.action_redo.setShortcut(self.settings_manager.get_shortcut("edit.redo"))
        
        self.action_add_person = QAction("Add Person", self)
        self.action_add_person.setObjectName("edit.add_person")
        self.action_add_person.setShortcut(self.settings_manager.get_shortcut("edit.add_person"))

        self.action_remove_person = QAction("Remove Person", self)
        self.action_remove_person.setObjectName("edit.remove_person")
        self.action_remove_person.setShortcut(self.settings_manager.get_shortcut("edit.remove_person"))

        self.action_add_new_family = QAction("Add New Family", self)
        self.action_add_new_family.setObjectName("edit.add_new_family")
        self.action_add_new_family.setShortcut(self.settings_manager.get_shortcut("edit.add_new_family"))

        edit_menu.addAction(self.action_undo)
        edit_menu.addAction(self.action_redo)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_person)
        edit_menu.addAction(self.action_remove_person)
        edit_menu.addAction(self.action_add_new_family)

        self.edit_actions.undo_action = self.action_undo
        self.edit_actions.redo_action = self.action_redo
        self.edit_actions.update_undo_redo_actions()

    def _create_view_menu(self, menubar: QMenuBar) -> None:
        """Create the View menu with different visualization options."""
        view_menu = menubar.addMenu("View")

        self.action_view_family_trees = QAction("Family Trees", self)
        self.action_view_family_trees.setObjectName("view.family_trees")
        self.action_view_family_trees.setShortcut(self.settings_manager.get_shortcut("view.family_trees"))

        self.action_view_timeline = QAction("Timeline", self)
        self.action_view_timeline.setObjectName("view.timeline")
        self.action_view_timeline.setShortcut(self.settings_manager.get_shortcut("view.timeline"))
        
        self.action_view_dynasty = QAction("Dynasty", self)
        self.action_view_dynasty.setObjectName("view.dynasty")
        self.action_view_dynasty.setShortcut(self.settings_manager.get_shortcut("view.dynasty"))

        self.action_view_data_table = QAction("Data Table", self)
        self.action_view_data_table.setObjectName("view.data_table")
        self.action_view_data_table.setShortcut(self.settings_manager.get_shortcut("view.data_table"))

        view_menu.addAction(self.action_view_family_trees)
        view_menu.addAction(self.action_view_timeline)
        view_menu.addAction(self.action_view_dynasty)
        view_menu.addAction(self.action_view_data_table)

    def _create_tools_menu(self, menubar: QMenuBar) -> None:
        """Create the Tools menu with utility operations."""
        tools_menu = menubar.addMenu("Tools")

        self.action_rebuild_scene = QAction("Rebuild Scene", self)
        self.action_rebuild_scene.setObjectName("tools.rebuild_scene")
        self.action_rebuild_scene.setShortcut(self.settings_manager.get_shortcut("tools.rebuild_scene"))

        self.action_recompute_generations = QAction("Recompute Generations", self)
        self.action_recompute_generations.setObjectName("tools.recompute_generations")
        self.action_recompute_generations.setShortcut(self.settings_manager.get_shortcut("tools.recompute_generations"))
        
        self.action_validate_marriages = QAction("Validate Marriages", self)
        self.action_validate_marriages.setObjectName("tools.validate_marriages")
        self.action_validate_marriages.setShortcut(self.settings_manager.get_shortcut("tools.validate_marriages"))

        self.action_validate_parentage = QAction("Validate Parentage", self)
        self.action_validate_parentage.setObjectName("tools.validate_parentage")
        self.action_validate_parentage.setShortcut(self.settings_manager.get_shortcut("tools.validate_parentage"))

        tools_menu.addAction(self.action_rebuild_scene)
        tools_menu.addAction(self.action_recompute_generations)
        tools_menu.addAction(self.action_validate_marriages)
        tools_menu.addAction(self.action_validate_parentage)

    def _create_settings_menu(self, menubar: QMenuBar) -> None:
        """Create the settings menu with application options."""
        settings_menu = menubar.addMenu("Settings")

        self.action_settings = QAction("Settings", self)
        self.action_settings.setObjectName("settings.settings")
        self.action_settings.setShortcut(self.settings_manager.get_shortcut("settings.settings"))

        self.action_general = QAction("General", self)
        self.action_general.setObjectName("settings.general")
        self.action_general.setShortcut(self.settings_manager.get_shortcut("settings.general"))

        self.action_shortcuts = QAction("Shortcuts", self)
        self.action_shortcuts.setObjectName("settings.shortcuts")
        self.action_shortcuts.setShortcut(self.settings_manager.get_shortcut("settings.shortcuts"))

        self.action_display = QAction("Display", self)
        self.action_display.setObjectName("settings.display")
        self.action_display.setShortcut(self.settings_manager.get_shortcut("settings.display"))

        self.action_appearance = QAction("Appearance", self)
        self.action_appearance.setObjectName("settings.appearance")
        self.action_appearance.setShortcut(self.settings_manager.get_shortcut("settings.appearance"))

        self.action_formats = QAction("Formats", self)
        self.action_formats.setObjectName("settings.formats")
        self.action_formats.setShortcut(self.settings_manager.get_shortcut("settings.formats"))

        settings_menu.addAction(self.action_settings)
        settings_menu.addSeparator()
        settings_menu.addAction(self.action_general)
        settings_menu.addAction(self.action_shortcuts)
        settings_menu.addAction(self.action_display)
        settings_menu.addAction(self.action_appearance)
        settings_menu.addAction(self.action_formats)


    def _create_help_menu(self, menubar: QMenuBar) -> None:
        """Create the Help menu with application information."""
        help_menu = menubar.addMenu("Help")

        self.action_about = QAction("About", self)
        self.action_about.setObjectName("help.about")
        self.action_about.setShortcut(self.settings_manager.get_shortcut("help.about"))
        help_menu.addAction(self.action_about)

    # ------------------------------------------------------------------
    # Action Connections
    # ------------------------------------------------------------------

    def _connect_actions(self) -> None:
        """Connect all menu actions to their handler methods."""
        # File menu connections
        self.action_new_dynasty.triggered.connect(self.file_actions.new_dynasty)
        self.action_open_dynasty.triggered.connect(self.file_actions.open_dynasty)
        self.action_save.triggered.connect(self.file_actions.save)
        self.action_save_as.triggered.connect(self.file_actions.save_as)
        self.action_exit.triggered.connect(self.file_actions.exit_app)

        # Edit menu connections
        self.action_undo.triggered.connect(self.edit_actions.undo)
        self.action_redo.triggered.connect(self.edit_actions.redo)
        self.action_add_person.triggered.connect(self.edit_actions.add_person)
        self.action_remove_person.triggered.connect(self.edit_actions.remove_person)
        self.action_add_new_family.triggered.connect(self.edit_actions.add_new_family)

        # View menu connections
        self.action_view_family_trees.triggered.connect(self.view_actions.family_trees)
        self.action_view_timeline.triggered.connect(self.view_actions.timeline)
        self.action_view_dynasty.triggered.connect(self.view_actions.dynasty)
        self.action_view_data_table.triggered.connect(self.view_actions.data_table)

        # Tools menu connections
        self.action_rebuild_scene.triggered.connect(self.tools_actions.rebuild_scene)
        self.action_recompute_generations.triggered.connect(self.tools_actions.recompute_generations)
        self.action_validate_marriages.triggered.connect(self.tools_actions.validate_marriages)
        self.action_validate_parentage.triggered.connect(self.tools_actions.validate_parentage)

        # Settings menu connections
        self.action_settings.triggered.connect(self.settings_actions.settings)
        self.action_general.triggered.connect(self.settings_actions.general)
        self.action_shortcuts.triggered.connect(self.settings_actions.shortcuts)
        self.action_display.triggered.connect(self.settings_actions.display)
        self.action_appearance.triggered.connect(self.settings_actions.appearance)
        self.action_formats.triggered.connect(self.settings_actions.formats)

        # Help menu connections
        self.action_about.triggered.connect(self.help_actions.about)

    # ------------------------------------------------------------------
    # UI Update Methods
    # ------------------------------------------------------------------

    def _update_window_title(self) -> None:
        """Update the window title to reflect current database state."""
        if self.db.is_open:
            dirty_marker = " *" if self.db.is_dirty else ""
            self.setWindowTitle(f"Dynasty Visualizer - {self.db.database_name}{dirty_marker}")
        else:
            self.setWindowTitle("Dynasty Visualizer")

    def _update_menu_states(self) -> None:
        """Enable or disable menu items based on current state."""
        has_db = self.db.is_open

        # File menu states
        self.action_save.setEnabled(has_db and self.db.is_dirty)
        self.action_save_as.setEnabled(has_db)

        # Edit menu states (disable if no database open)
        self.action_undo.setEnabled(self.undo_manager.can_undo())
        self.action_redo.setEnabled(self.undo_manager.can_redo())
        self.action_add_person.setEnabled(has_db)
        self.action_remove_person.setEnabled(has_db)
        self.action_add_new_family.setEnabled(has_db)

        # View menu states
        self.action_view_family_trees.setEnabled(has_db)
        self.action_view_timeline.setEnabled(has_db)
        self.action_view_dynasty.setEnabled(has_db)
        self.action_view_data_table.setEnabled(has_db)

        # Tools menu states
        self.action_rebuild_scene.setEnabled(has_db)
        self.action_recompute_generations.setEnabled(has_db)
        self.action_validate_marriages.setEnabled(has_db)
        self.action_validate_parentage.setEnabled(has_db)

    # ------------------------------------------------------------------
    # Public Methods
    # ------------------------------------------------------------------

    def refresh_ui(self) -> None:
        """Refresh window title and menu states after database changes."""
        self._update_window_title()
        self._update_menu_states()
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------

    def closeEvent(self, event) -> None:
        """Handle window close event - intercept X button, Alt+F4, etc."""

        if self.db.is_open and self.db.is_dirty:

            msg = QMessageBox(self)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:

                if self.file_actions.save():
                    event.accept()
                else:
                    event.ignore()
            elif choice == QMessageBox.StandardButton.Discard:
                event.accept()
            
            else: 
                event.ignore()
        
        else:
            event.accept()

def main() -> None:
    """Application entry point."""
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()

>> âœ… test_edit_person_dialog.py (21 code lines)
import sys
from PySide6.QtWidgets import QApplication

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from dialogs.edit_person_dialog import EditPersonDialog

app = QApplication(sys.argv)

# Open database
db = DatabaseManager(None)
db.open_database("Struggberg Family Tree 1.dyn")  # Use your actual .dyn file

# Get a person to edit
repo = PersonRepository(db)
people = repo.get_all()

if people:
    person = people[0]  # Edit the first person
    
    dialog = EditPersonDialog(db, person)
    result = dialog.exec()
    
    if result:
        print("User clicked Save")
    else:
        print("User clicked Cancel")
else:
    print("No people in database!")

sys.exit(0)


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ database\__init__.py (3 code lines)
from .db_manager import DatabaseManager
from .person_repository import PersonRepository

__all__ = ['DatabaseManager', 'PersonRepository']

>> âœ… database\db_manager.py (181 code lines)
import sqlite3
import shutil
import os


class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the database manager."""
        self.parent = parent
        self.conn: sqlite3.Connection | None = None
        self.file_path: str | None = None
        self._unsaved_changes: bool = False

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def is_dirty(self) -> bool:
        """Check if there are unsaved changes."""
        return self._unsaved_changes

    @property
    def is_open(self) -> bool:
        """Check if a database is currently open."""
        return self.conn is not None

    @property
    def database_name(self) -> str | None:
        """Get the filename of the current database without path."""
        if self.file_path is None:
            return None
        return os.path.basename(self.file_path)

    @property
    def database_directory(self) -> str | None:
        """Get the directory path of the current database."""
        if self.file_path is None:
            return None
        return os.path.dirname(self.file_path)

    @property
    def has_file_path(self) -> bool:
        """Check if database has an associated file path."""
        return self.file_path is not None

    # ------------------------------------------------------------------
    # Public Methods - Database Lifecycle
    # ------------------------------------------------------------------

    def new_database(self, file_path: str) -> None:
        """Create a brand-new .dyn file with the dynasty schema."""
        if os.path.exists(file_path):
            os.remove(file_path)
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._initialize_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to create database: {e}")

    def open_database(self, file_path: str) -> None:
        """Open an existing .dyn database file."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} does not exist.")
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._migrate_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to open database: {e}")

    def save_database(self, path: str | None = None) -> bool:
        """
        Save the database, optionally to a new path.
        
        If path is provided, saves a copy to that location and switches to it.
        If path is None, commits changes to the current file.
        """
        if self.conn is None:
            return False
        
        # If no path provided, just commit current database
        if path is None:
            self.conn.commit()
            self._unsaved_changes = False
            return True
        
        # Save to new path (save_as behavior)
        if self.file_path is None:
            return False
        
        self.conn.commit()
        self.conn.close()
        
        # Copy database file to new location
        shutil.copy2(self.file_path, path)
        
        # Reopen connection at new path
        self.conn = sqlite3.connect(path)
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.file_path = path
        self._unsaved_changes = False
        return True
    
    def close(self) -> None:
        """Close the current database connection and reset state."""
        if self.conn:
            self.conn.close()
        self.conn = None
        self.file_path = None
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Public Methods - State Management
    # ------------------------------------------------------------------

    def mark_dirty(self) -> None:
        """Mark the database as having unsaved changes."""
        if self.conn is not None:
            self._unsaved_changes = True

    def mark_clean(self) -> None:
        """Mark the database as having no unsaved changes."""
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Private Methods
    # ------------------------------------------------------------------

    def _initialize_schema(self) -> None:
        """Create all required tables for a new dynasty database."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
        
        cursor = self.conn.cursor()

        schema_sql = """
        -- Person table: Core genealogical data
        -- Dates support flexible precision (year, year/month, or year/month/day)
        CREATE TABLE IF NOT EXISTS Person (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            middle_name TEXT DEFAULT '',
            last_name TEXT NOT NULL,
            maiden_name TEXT,
            nickname TEXT DEFAULT '',
            gender TEXT,
            birth_year INTEGER,
            birth_month INTEGER,
            birth_day INTEGER,
            death_year INTEGER,
            death_month INTEGER,
            death_day INTEGER,
            arrival_year INTEGER,
            arrival_month INTEGER,
            arrival_day INTEGER,
            moved_out_year INTEGER,
            moved_out_month INTEGER,
            moved_out_day INTEGER,
            father_id INTEGER,
            mother_id INTEGER,
            family_id INTEGER,
            dynasty_id INTEGER DEFAULT 1,
            is_founder INTEGER DEFAULT 0,
            education INTEGER DEFAULT 0,
            notes TEXT,
            FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
        );

        -- Event table: Life events (jobs, illnesses, moves, etc.)
        CREATE TABLE IF NOT EXISTS Event (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            event_title TEXT NOT NULL,
            start_year INTEGER,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            notes TEXT,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Marriage table: Relationships between people
        CREATE TABLE IF NOT EXISTS Marriage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            spouse1_id INTEGER,
            spouse2_id INTEGER,
            marriage_year INTEGER,
            marriage_month INTEGER,
            marriage_day INTEGER,
            dissolution_year INTEGER,
            dissolution_month INTEGER,
            dissolution_day INTEGER,
            dissolution_reason TEXT,
            marriage_type TEXT DEFAULT 'spouse',
            notes TEST,
            FOREIGN KEY(spouse1_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL,
            FOREIGN KEY(spouse2_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL
        );

        -- Portrait table: Multiple images per person with date ranges
        CREATE TABLE IF NOT EXISTS Portrait (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            image_path TEXT NOT NULL,
            valid_from_year INTEGER,
            valid_from_month INTEGER,
            valid_from_day INTEGER,
            valid_to_year INTEGER,
            valid_to_month INTEGER,
            valid_to_day INTEGER,
            is_primary INTEGER DEFAULT 0,
            display_order INTEGER DEFAULT 0,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Family table: Dynasty/family groupings
        CREATE TABLE IF NOT EXISTS Family (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            surname TEXT NOT NULL,
            move_in_year INTEGER,
            move_in_month INTEGER,
            move_in_day INTEGER,
            coat_of_arms_path TEXT,
            family_color TEXT,
            is_extinct INTEGER DEFAULT 0,
            notes TEXT
        );

        -- MajorEvent table: Historical events affecting multiple families
        CREATE TABLE IF NOT EXISTS MajorEvent (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT NOT NULL,
            event_type TEXT NOT NULL,
            start_year INTEGER NOT NULL,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            description TEXT,
            color TEXT
        );

        -- PersonPosition table: Custom positions for draggable UI
        CREATE TABLE IF NOT EXISTS PersonPosition (
            person_id INTEGER PRIMARY KEY,
            view_type TEXT NOT NULL,
            x_position REAL NOT NULL,
            y_position REAL NOT NULL,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );
        """
        cursor.executescript(schema_sql)
        self.conn.commit()
    
    def _migrate_schema(self) -> None:
        """Migrate existing database schema to latest version."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
            
        cursor = self.conn.cursor()

        # Person table migrations
        cursor.execute("PRAGMA table_info(Person)")
        existing_person_columns = {row[1] for row in cursor.fetchall()}

        person_migrations = [
            # Dec/10/2025 - Person Model updates
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
        ]
        
        for column_name, sql in person_migrations:
            if column_name not in existing_person_columns:
                cursor.execute(sql)
        
        # Marriage table migrations
        cursor.execute("PRAGMA table_info(Marriage)")
        existing_marriage_columns = {row[1] for row in cursor.fetchall()}
        
        marriage_migrations = [
            # Dec/20/2025 - Marriage notes field
            ("notes", "ALTER TABLE Marriage ADD COLUMN notes TEXT"),
        ]
        
        for column_name, sql in marriage_migrations:
            if column_name not in existing_marriage_columns:
                cursor.execute(sql)
        
        self.conn.commit()



>> âœ… database\marriage_repository.py (85 code lines)
"""Repository for Marriage database operations."""

from database.db_manager import DatabaseManager
from models.marriage import Marriage


class MarriageRepository:
    """Handle database operations for marriages."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize the marriage repository."""
        self.db = db_manager
    
    def insert(self, marriage: Marriage) -> int:
        """Insert a new marriage into the database.
        
        Returns the new marriage ID, or -1 if database not open.
        """
        if not self.db.conn:
            return -1
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            INSERT INTO Marriage (
                spouse1_id, spouse2_id,
                marriage_year, marriage_month, marriage_day,
                dissolution_year, dissolution_month, dissolution_day,
                dissolution_reason, marriage_type, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes
        ))
        
        self.db.conn.commit()
        return cursor.lastrowid or -1
    
    def insert_with_id(self, marriage: Marriage) -> None:
        """Insert marriage with explicit ID (for undo/redo)."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            INSERT INTO Marriage (
                id, spouse1_id, spouse2_id,
                marriage_year, marriage_month, marriage_day,
                dissolution_year, dissolution_month, dissolution_day,
                dissolution_reason, marriage_type, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            marriage.id, marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes
        ))
        
        self.db.conn.commit()
    
    def get_by_id(self, marriage_id: int) -> Marriage | None:
        """Get a marriage by ID."""
        if not self.db.conn:
            return None
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE id = ?
        """, (marriage_id,))
        
        row = cursor.fetchone()
        if row:
            return self._row_to_marriage(row)
        return None
    
    def get_by_person(self, person_id: int) -> list[Marriage]:
        """Get all marriages for a person (as either spouse)."""
        if not self.db.conn:
            return []
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE spouse1_id = ? OR spouse2_id = ?
            ORDER BY marriage_year, marriage_month
        """, (person_id, person_id))
        
        return [self._row_to_marriage(row) for row in cursor.fetchall()]
    
    def get_active_marriages(self, person_id: int) -> list[Marriage]:
        """Get all active (not ended) marriages for a person."""
        if not self.db.conn:
            return []
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE (spouse1_id = ? OR spouse2_id = ?)
              AND dissolution_year IS NULL
            ORDER BY marriage_year, marriage_month
        """, (person_id, person_id))
        
        return [self._row_to_marriage(row) for row in cursor.fetchall()]
    
    def get_spouse_id(self, marriage: Marriage, person_id: int) -> int | None:
        """Get the spouse ID for a given person in a marriage."""
        if marriage.spouse1_id == person_id:
            return marriage.spouse2_id
        elif marriage.spouse2_id == person_id:
            return marriage.spouse1_id
        return None
    
    def update(self, marriage: Marriage) -> None:
        """Update an existing marriage."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            UPDATE Marriage SET
                spouse1_id = ?,
                spouse2_id = ?,
                marriage_year = ?,
                marriage_month = ?,
                marriage_day = ?,
                dissolution_year = ?,
                dissolution_month = ?,
                dissolution_day = ?,
                dissolution_reason = ?,
                marriage_type = ?,
                notes = ?
            WHERE id = ?
        """, (
            marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes,
            marriage.id
        ))
        
        self.db.conn.commit()
    
    def delete(self, marriage_id: int) -> None:
        """Delete a marriage by ID."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Marriage WHERE id = ?", (marriage_id,))
        self.db.conn.commit()
    
    def end_marriage(self, marriage_id: int, dissolution_year: int, 
                     dissolution_month: int | None = None, 
                     dissolution_day: int | None = None, 
                     reason: str = "") -> None:
        """End a marriage by setting dissolution date and reason."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            UPDATE Marriage SET
                dissolution_year = ?,
                dissolution_month = ?,
                dissolution_day = ?,
                dissolution_reason = ?
            WHERE id = ?
        """, (dissolution_year, dissolution_month, dissolution_day, reason, marriage_id))
        
        self.db.conn.commit()
    
    def _row_to_marriage(self, row: tuple) -> Marriage:
        """Convert database row to Marriage object."""
        return Marriage(
            id=row[0],
            spouse1_id=row[1],
            spouse2_id=row[2],
            marriage_year=row[3],
            marriage_month=row[4],
            marriage_day=row[5],
            dissolution_year=row[6],
            dissolution_month=row[7],
            dissolution_day=row[8],
            dissolution_reason=row[9] or "",
            marriage_type=row[10] or "spouse",
            notes=row[11] or ""
        )

>> âœ… database\person_repository.py (104 code lines)
"""Database repository for Person entity operations."""

from __future__ import annotations
import sqlite3
from typing import TYPE_CHECKING

from models.person import Person

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class PersonRepository:
    """Handles all database operations for Person objects."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize repository with database manager."""
        self.db = db_manager
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _row_to_person(self, row: sqlite3.Row) -> Person:
        """Convert database row to Person object using named column access."""
        return Person(
            id=row['id'],
            first_name=row['first_name'],
            middle_name=row['middle_name'],
            last_name=row['last_name'],
            maiden_name=row['maiden_name'],
            nickname=row['nickname'],
            gender=row['gender'],
            birth_year=row['birth_year'],
            birth_month=row['birth_month'],
            birth_day=row['birth_day'],
            death_year=row['death_year'],
            death_month=row['death_month'],
            death_day=row['death_day'],
            arrival_year=row['arrival_year'],
            arrival_month=row['arrival_month'],
            arrival_day=row['arrival_day'],
            moved_out_year=row['moved_out_year'],
            moved_out_month=row['moved_out_month'],
            moved_out_day=row['moved_out_day'],
            father_id=row['father_id'],
            mother_id=row['mother_id'],
            family_id=row['family_id'],
            dynasty_id=row['dynasty_id'] or 1,
            is_founder=bool(row['is_founder']),
            education=row['education'] or 0,
            notes=row['notes'] or ""
        )
    
    def _cursor(self):
        if self.db.conn is None:
            raise RuntimeError("DB connection not established.")
        return self.db.conn.cursor()
    
    # ------------------------------------------------------------------
    # Create Operations
    # ------------------------------------------------------------------
    
    def insert(self, person: Person) -> int:
        """Insert new person into database and return assigned ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            INSERT INTO Person (
                first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        person_id = cursor.lastrowid
        
        self.db.mark_dirty()
        return person_id if person_id is not None else -1
       
    def insert_with_id(self, person: Person) -> None:
        """Insert person with specific ID (for redo operations)"""
        if self.db.conn is None:
            raise RuntimeError("Database connection not establish.")
        
        if person.id is None:
            raise ValueError("Person must have an ID for insert_with_id")
        
        cursor = self.db.conn.cursor()

        sql = """
            INSERT INTO Person (
                id, first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.id,  # Explicitly set the ID
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
        

    # ------------------------------------------------------------------
    # Read Operations
    # ------------------------------------------------------------------
    
    def get_by_id(self, person_id: int) -> Person | None:
        """Retrieve person by ID, return None if not found."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person WHERE id = ?", (person_id,))
        row = cursor.fetchone()
        
        if row is None:
            return None
        
        return self._row_to_person(row)
    
    def get_all(self) -> list[Person]:
        """Retrieve all people from database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person ORDER BY last_name, first_name")
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_by_name(self, first_name: str, last_name: str) -> list[Person]:
        """Find people by first and last name."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE first_name = ? AND last_name = ?
            ORDER BY birth_year
        """
        cursor.execute(sql, (first_name, last_name))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_children(self, parent_id: int) -> list[Person]:
        """Retrieve all children of a given parent."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE father_id = ? OR mother_id = ?
            ORDER BY birth_year, birth_month, birth_day
        """
        cursor.execute(sql, (parent_id, parent_id))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_alive_in_year(self, year: int) -> list[Person]:
        """Retrieve all people alive in a given year."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person
            WHERE birth_year <= ? 
            AND (death_year IS NULL OR death_year >= ?)
            ORDER BY birth_year
        """
        cursor.execute(sql, (year, year))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    # ------------------------------------------------------------------
    # Update Operations
    # ------------------------------------------------------------------
    
    def update(self, person: Person) -> None:
        """Update existing person in database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        if person.id is None:
            raise ValueError("Cannot update person without ID.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            UPDATE Person SET
                first_name = ?, middle_name = ?, last_name = ?,
                maiden_name = ?, nickname = ?,
                gender = ?, birth_year = ?, birth_month = ?, birth_day = ?,
                death_year = ?, death_month = ?, death_day = ?,
                arrival_year = ?, arrival_month = ?, arrival_day = ?,
                moved_out_year = ?, moved_out_month = ?, moved_out_day = ?,
                father_id = ?, mother_id = ?, family_id = ?,
                dynasty_id = ?, is_founder = ?, education = ?, notes = ?
            WHERE id = ?
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes,
            person.id
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
    
    # ------------------------------------------------------------------
    # Delete Operations
    # ------------------------------------------------------------------
    
    def delete(self, person_id: int) -> None:
        """Delete person from database by ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Person WHERE id = ?", (person_id,))
        self.db.mark_dirty()



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MODELS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ models\__init__.py (0 code lines)


>> âœ… models\event.py (32 code lines)
"""Data model for Event entities."""

from dataclasses import dataclass


@dataclass
class Event:
    """Represents a life event for a person."""
    
    # Database identity
    id: int | None = None
    
    # Associated person
    person_id: int | None = None
    
    # Event details
    event_type: str = ""  # "Birth", "Marriage", "Death", "Job", "Move", etc.
    event_title: str = ""  # "Became Blacksmith", "Moved to Town", etc.
    
    # Start date (flexible precision)
    start_year: int | None = None
    start_month: int | None = None
    start_day: int | None = None
    
    # End date (for ongoing events like jobs)
    end_year: int | None = None
    end_month: int | None = None
    end_day: int | None = None
    
    # Notes
    notes: str = ""
    
    @property
    def is_ongoing(self) -> bool:
        """Check if the event is currently ongoing (no end date)."""
        return self.end_year is None
    
    @property
    def start_date_string(self) -> str:
        """Format start date as readable string."""
        if not self.start_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.start_month and self.start_day:
            # Full date
            return f"{month_names[self.start_month]} {self.start_day}, {self.start_year}"
        elif self.start_month:
            # Year and month
            return f"{month_names[self.start_month]} {self.start_year}"
        else:
            # Year only
            return str(self.start_year)
    
    @property
    def end_date_string(self) -> str:
        """Format end date as readable string."""
        if not self.end_year:
            return "Ongoing" if self.start_year else ""
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.end_month and self.end_day:
            # Full date
            return f"{month_names[self.end_month]} {self.end_day}, {self.end_year}"
        elif self.end_month:
            # Year and month
            return f"{month_names[self.end_month]} {self.end_year}"
        else:
            # Year only
            return str(self.end_year)
    
    @property
    def duration_years(self) -> int | None:
        """Calculate event duration in years (None if ongoing or no dates)."""
        if not self.start_year:
            return None
        
        if self.end_year:
            return self.end_year - self.start_year
        
        return None  # Ongoing, no duration yet
    
    @property
    def date_range_string(self) -> str:
        """Get formatted date range for display."""
        if self.is_ongoing:
            return f"{self.start_date_string} - Present"
        elif self.end_year:
            return f"{self.start_date_string} - {self.end_date_string}"
        else:
            return self.start_date_string

>> ðŸ“‹ models\family.py (12 code lines)
"""Data model for Family dynasties."""

from dataclasses import dataclass


@dataclass
class Family:
    """Represents a family dynasty grouping."""
    
    # Database identity
    id: int | None = None
    
    # Family identification
    surname: str = ""
    
    # Move-in date (when family arrived in settlement)
    move_in_year: int | None = None
    move_in_month: int | None = None
    move_in_day: int | None = None
    
    # Visual representation
    coat_of_arms_path: str = ""  # Path to coat of arms image
    family_color: str = ""  # Hex color for UI display
    
    # Status
    is_extinct: bool = False  # True if no living members
    
    # Notes
    notes: str = ""
    
    @property
    def move_in_date_string(self) -> str:
        """Format move-in date as readable string."""
        if not self.move_in_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.move_in_month and self.move_in_day:
            # Full date
            return f"{month_names[self.move_in_month]} {self.move_in_day}, {self.move_in_year}"
        elif self.move_in_month:
            # Year and month
            return f"{month_names[self.move_in_month]} {self.move_in_year}"
        else:
            # Year only
            return str(self.move_in_year)
    
    @property
    def display_name(self) -> str:
        """Get family display name."""
        return f"{self.surname} Family" if self.surname else "Unknown Family"
    
    # Note: member_count, founding_date, end_date, longest_lived_member
    # require database queries, so they'll be methods in FamilyRepository

>> ðŸ“‹ models\major_event.py (15 code lines)
"""Data model for MajorEvent entities."""


class MajorEvent:
    """Represents a major historical event affecting multiple families."""

    def __init__(
        self,
        event_id: int,
        event_name: str,
        event_type: str,
        start_year: int,
        start_month: int | None = None,
        start_day: int | None = None,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
        description: str | None = None,
        color: str | None = None,
    ) -> None:
        """Initialize a major historical event."""
        self.id = event_id
        self.event_name = event_name
        self.event_type = event_type
        self.start_year = start_year
        self.start_month = start_month
        self.start_day = start_day
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.description = description
        self.color = color

    @property
    def is_ongoing(self) -> bool:
        """Check if the event is ongoing."""
        return self.end_year is None

    # TODO: Add duration property
    # TODO: Add start_date_string property
    # TODO: Add end_date_string property


>> âœ… models\marriage.py (62 code lines)
"""Data model for Marriage relationships."""

from dataclasses import dataclass


@dataclass
class Marriage:
    """Represents a marriage relationship between two people."""
    
    # Database identity
    id: int | None = None
    
    # Spouses (person IDs)
    spouse1_id: int | None = None
    spouse2_id: int | None = None
    
    # Marriage date (flexible precision)
    marriage_year: int | None = None
    marriage_month: int | None = None
    marriage_day: int | None = None
    
    # Dissolution/End date (flexible precision)
    dissolution_year: int | None = None
    dissolution_month: int | None = None
    dissolution_day: int | None = None
    
    # Dissolution details
    dissolution_reason: str = ""  # "Death", "Divorce", "Annulment", etc.
    
    # Marriage type (for different cultures/eras)
    marriage_type: str = "spouse"  # "spouse", "partner", "common-law", etc.
    
    # Notes
    notes: str = ""
    
    @property
    def is_active(self) -> bool:
        """Check if the marriage is currently active (not dissolved)."""
        return self.dissolution_year is None
    
    @property
    def marriage_date_string(self) -> str:
        """Format marriage date as readable string."""
        if not self.marriage_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.marriage_month and self.marriage_day:
            # Full date: "January 15, 1675"
            return f"{month_names[self.marriage_month]} {self.marriage_day}, {self.marriage_year}"
        elif self.marriage_month:
            # Year and month: "January 1675"
            return f"{month_names[self.marriage_month]} {self.marriage_year}"
        else:
            # Year only
            return str(self.marriage_year)
    
    @property
    def dissolution_date_string(self) -> str:
        """Format dissolution date as readable string."""
        if not self.dissolution_year:
            return ""
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.dissolution_month and self.dissolution_day:
            # Full date
            return f"{month_names[self.dissolution_month]} {self.dissolution_day}, {self.dissolution_year}"
        elif self.dissolution_month:
            # Year and month
            return f"{month_names[self.dissolution_month]} {self.dissolution_year}"
        else:
            # Year only
            return str(self.dissolution_year)
    
    @property
    def duration_string(self) -> str:
        """Calculate marriage duration as readable string with years, months, days."""
        if not self.marriage_year:
            return "Unknown duration"
        
        # If still active (no dissolution date), can't calculate
        if self.is_active or not self.dissolution_year:
            return "Ongoing"
        
        # Calculate duration
        start_year = self.marriage_year
        start_month = self.marriage_month or 1  # Default to January if unknown
        start_day = self.marriage_day or 1  # Default to 1st if unknown
        
        end_year = self.dissolution_year  # Now guaranteed to be int, not None
        end_month = self.dissolution_month or 1
        end_day = self.dissolution_day or 1
        
        # Calculate differences
        years = end_year - start_year
        months = end_month - start_month
        days = end_day - start_day
        
        # Adjust for negative days
        if days < 0:
            months -= 1
            # Days in previous month (approximate as 30)
            days += 30
        
        # Adjust for negative months
        if months < 0:
            years -= 1
            months += 12
        
        # Build string
        parts = []
        if years > 0:
            parts.append(f"{years} year{'s' if years != 1 else ''}")
        if months > 0:
            parts.append(f"{months} month{'s' if months != 1 else ''}")
        if days > 0 and self.marriage_day and self.dissolution_day:
            # Only show days if both dates have day precision
            parts.append(f"{days} day{'s' if days != 1 else ''}")
        
        if not parts:
            return "Less than 1 month"
        
        return ", ".join(parts)

    @property
    def duration_years(self) -> int | None:
        """Calculate marriage duration in years only (for sorting/filtering)."""
        if not self.marriage_year or self.is_active or not self.dissolution_year:
            return None
        
        return self.dissolution_year - self.marriage_year
    
    @property
    def status_string(self) -> str:
        """Get marriage status as readable string."""
        if self.is_active:
            return "Active"
        
        if self.dissolution_reason:
            return f"Ended ({self.dissolution_reason})"
        
        return "Ended"

>> âœ… models\person.py (50 code lines)
"""Data model for Person entities."""

from __future__ import annotations
from dataclasses import dataclass


@dataclass
class Person:
    """Represents a person in a dynasty with flexible date precision."""
    
    # Database identity
    id: int | None = None  # None until saved to database
    dynasty_id: int = 1
    family_id: int | None = None
    
    # Name fields (full structure for flexibility)
    first_name: str = ""
    middle_name: str = ""
    last_name: str = ""
    maiden_name: str = ""
    nickname: str = ""
    
    # Biological information
    gender: str = "Unknown"  # "Male", "Female", "Unknown", "Other"
    
    # Birth date (year should be provided, month/day optional)
    birth_year: int | None = None
    birth_month: int | None = None
    birth_day: int | None = None
    
    # Death date (all optional - None if alive)
    death_year: int | None = None
    death_month: int | None = None
    death_day: int | None = None
    
    # Arrival/departure dates (tracking when joined/left settlement)
    arrival_year: int | None = None
    arrival_month: int | None = None
    arrival_day: int | None = None
    moved_out_year: int | None = None
    moved_out_month: int | None = None
    moved_out_day: int | None = None
    
    # Relationships (parent IDs link to database)
    father_id: int | None = None
    mother_id: int | None = None
    
    # Game-specific fields
    is_founder: bool = False
    education: int = 0  # 0-5 scale from Ostriv
    
    # User notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties
    # ------------------------------------------------------------------
    
    @property
    def full_name(self) -> str:
        """Get full name with optional middle name and nickname."""
        parts = [self.first_name]
        
        if self.middle_name:
            parts.append(self.middle_name)
        
        parts.append(self.last_name)

        name = " ".join(parts)
        
        if self.nickname:
            name += f' "{self.nickname}"'

        return name
    
    @property
    def display_name(self) -> str:
        """Get display name (first + last, no middle or nickname)."""
        return f"{self.first_name} {self.last_name}"
    
    @property
    def is_deceased(self) -> bool:
        """Check if person is deceased."""
        return self.death_year is not None
    
    def get_age(self, current_year: int) -> int | None:
        """
        Calculate age at a given year.
        
        Returns None if birth year unknown or if person died before current year.
        """
        if self.birth_year is None:
            return None
        
        # If person died, use death year as upper bound
        if self.death_year is not None and current_year > self.death_year:
            return None
        
        return current_year - self.birth_year
    
    def is_alive_in_year(self, year: int) -> bool:
        """Check if person was alive in a given year."""
        # Must have been born by that year
        if self.birth_year is None or year < self.birth_year:
            return False
        
        # If no death year, assume still alive
        if self.death_year is None:
            return True
        
        # Check if year is before death
        return year <= self.death_year
    
    def get_age_at_death(self) -> int | None:
        """Calculate age at death, or None if not deceased or birth year unknown."""
        if not self.is_deceased or self.birth_year is None or self.death_year is None:
            return None
        
        return self.death_year - self.birth_year
    
    def get_birth_date_string(self) -> str:
        """Format birth date as string with available precision (European format)."""
        if self.birth_year is None:
            return "Unknown"
        
        if self.birth_day and self.birth_month:
            return f"{self.birth_day:02d}/{self.birth_month:02d}/{self.birth_year}"
        
        if self.birth_month:
            return f"{self.birth_month:02d}/{self.birth_year}"
        
        return str(self.birth_year)
    
    def get_death_date_string(self) -> str:
        """Format death date as string with available precision (European format)."""
        if self.death_year is None:
            return "Alive"
        
        if self.death_day and self.death_month:
            return f"{self.death_day:02d}/{self.death_month:02d}/{self.death_year}"
        
        if self.death_month:
            return f"{self.death_month:02d}/{self.death_year}"
        
        return str(self.death_year)
    
    def get_lifespan_string(self) -> str:
        """Get lifespan as formatted string (e.g., '1420-1475' or '1450-')."""
        birth = str(self.birth_year) if self.birth_year else "?"
        death = str(self.death_year) if self.death_year else ""
        return f"{birth}-{death}"

>> ðŸ“‹ models\portrait.py (14 code lines)
"""Data model for Portrait entities."""


class Portrait:
    """Represents a portrait image for a person."""

    def __init__(
        self,
        portrait_id: int,
        person_id: int,
        image_path: str,
        valid_from_year: int | None = None,
        valid_from_month: int | None = None,
        valid_from_day: int | None = None,
        valid_to_year: int | None = None,
        valid_to_month: int | None = None,
        valid_to_day: int | None = None,
        is_primary: bool = False,
        display_order: int = 0,
    ) -> None:
        """Initialize a portrait."""
        self.id = portrait_id
        self.person_id = person_id
        self.image_path = image_path
        self.valid_from_year = valid_from_year
        self.valid_from_month = valid_from_month
        self.valid_from_day = valid_from_day
        self.valid_to_year = valid_to_year
        self.valid_to_month = valid_to_month
        self.valid_to_day = valid_to_day
        self.is_primary = is_primary
        self.display_order = display_order

    # TODO: Add valid_from_date_string property
    # TODO: Add valid_to_date_string property
    # TODO: Add is_valid_for_date method



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ actions\__init__.py (7 code lines)
from .file_actions import FileActions
from .edit_actions import EditActions
from .view_actions import ViewActions
from .tools_actions import ToolsActions
from .help_actions import HelpActions
from .settings_actions import SettingsActions

__all__ = ['FileActions', 'EditActions', 'ViewActions', 'ToolsActions', 'HelpActions', 'SettingsActions']

>> âœ… actions\edit_actions.py (25 code lines)
from PySide6.QtWidgets import QDialog
from PySide6.QtGui import QAction

from dialogs.add_person_dialog import AddPersonDialog
from commands.genealogy_commands import AddPersonCommand
        

class EditActions:
    """Handles edit menu actions (Undo, Redo, Add/Remove operations)."""
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize edit actions handler."""
        self.parent = parent
        
        # Store references to the menu actions so we can update their text
        # These will be set by MainWindow after it creates the menu
        self.undo_action: QAction | None = None
        self.redo_action: QAction | None = None
    
    def update_undo_redo_actions(self) -> None:
        """Update Undo/Redo menu items with current action descriptions."""
        if self.undo_action is None or self.redo_action is None:
            return 
        
        undo_manager = self.parent.undo_manager
        
        # Update Undo action
        if undo_manager.can_undo():
            next_undo = undo_manager.peek_undo()
            if next_undo:
                self.undo_action.setText(f"Undo {next_undo.description()}")
                self.undo_action.setEnabled(True)
        else:
            self.undo_action.setText("Undo")
            self.undo_action.setEnabled(False)
        
        # Update Redo action
        if undo_manager.can_redo():
            next_redo = undo_manager.peek_redo()
            if next_redo:
                self.redo_action.setText(f"Redo {next_redo.description()}")
                self.redo_action.setEnabled(True)
        else:
            self.redo_action.setText("Redo")
            self.redo_action.setEnabled(False)
    
    def undo(self) -> None:
        """Undo the last action."""
        if self.parent.undo_manager.undo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after undo
    
    def redo(self) -> None:
        """Redo the last undone action."""
        if self.parent.undo_manager.redo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after redo
    
    def add_person(self) -> None:
        """Open dialog to add a new person to the database."""

        dialog = AddPersonDialog(self.parent)
        result = dialog.exec()
        
        if result == 1:  # QDialog.accepted
            person = dialog.get_person()
            if person:
                command = AddPersonCommand(self.parent.db, person)
                self.parent.undo_manager.execute(command)
                self.parent.refresh_ui()
                self.update_undo_redo_actions()  # Update menu after adding person
    
    def remove_person(self) -> None:
        """Remove the selected person from the database."""
        pass  # TODO: Implement with confirmation dialog
    
    def add_new_family(self) -> None:
        """Create a new family branch in the dynasty."""
        pass  # TODO: Implement family creation

>> âœ… actions\file_actions.py (52 code lines)
from PySide6.QtWidgets import QFileDialog, QMessageBox


class FileActions:
    """Handles file menu actions (New, Open, Save, Exit)."""
    
    FILE_FILTER = "Dynasty Files (*.dyn)"
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize file actions handler."""
        self.parent = parent
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _ensure_db(self) -> bool:
        """Check if a database is currently open."""
        if not hasattr(self.parent, 'db') or not self.parent.db.is_open:
            self._show_error("Error", "No database is currently open.")
            return False
        return True
    
    def _get_save_path(self, title: str, default_name: str = "") -> str | None:
        """Show a save file dialog and return the chosen path."""
        default_path = ""
        if default_name:
            default_path = default_name
        elif self.parent.db.database_directory:
            default_path = self.parent.db.database_directory
        
        path, _ = QFileDialog.getSaveFileName(
            self.parent,
            title,
            default_path,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _get_open_path(self, title: str) -> str | None:
        """Show an open file dialog and return the chosen path."""
        default_dir = ""
        if self.parent.db.is_open and self.parent.db.database_directory:
            default_dir = self.parent.db.database_directory
        
        path, _ = QFileDialog.getOpenFileName(
            self.parent,
            title,
            default_dir,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _show_error(self, title: str, message: str) -> None:
        """Display an error message dialog."""
        QMessageBox.critical(self.parent, title, message)
    
    # ------------------------------------------------------------------
    # File Operations
    # ------------------------------------------------------------------
    
    def new_dynasty(self) -> None:
        """Prompt user to create a new dynasty database file."""
        path = self._get_save_path("Create New Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.new_database(path)
            self.parent.refresh_ui()
        except Exception as e:
            self._show_error(
                "Error Creating Database",
                f"Failed to create dynasty file:\n{str(e)}"
            )
    
    def open_dynasty(self) -> None:
        """Prompt user to open an existing dynasty database file."""
        path = self._get_open_path("Open Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.open_database(path)
            self.parent.refresh_ui()
        except FileNotFoundError:
            self._show_error(
                "File Not Found",
                f"The file '{path}' does not exist."
            )
        except Exception as e:
            self._show_error(
                "Error Opening Database",
                f"Failed to open dynasty file:\n{str(e)}"
            )
    
    def save(self) -> bool:
        """Save current database, falling back to save_as if no path set."""
        if not self._ensure_db():
            return False
        
        if not self.parent.db.has_file_path:
            return self.save_as()
        
        try:
            result = self.parent.db.save_database()
            if result:
                self.parent.refresh_ui()
            return result
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def save_as(self) -> bool:
        """Prompt user to save database to a new file."""
        if not self._ensure_db():
            return False
        
        # Suggest current filename if it exists
        default_name = self.parent.db.database_name or ""
        path = self._get_save_path("Save Dynasty File As", default_name)
        if not path:
            return False
        
        try:
            self.parent.db.save_database(path)
            return True
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def exit_app(self) -> None:
        """Prompt to save unsaved changes before closing application."""
        db = self.parent.db
        
        if db.is_open and db.is_dirty:
            msg = QMessageBox(self.parent)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:
                if not self.save():
                    return
            elif choice == QMessageBox.StandardButton.Cancel:
                return
        
        self.parent.close()


>> ðŸ“‹ actions\help_actions.py (3 code lines)
class HelpActions:
    """Handles help menu actions for application information."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize help actions handler."""
        self.parent = parent

    def about(self) -> None:
        """Display the about dialog with application information."""
        pass  # TODO: Implement about dialog


>> ðŸ“‹ actions\settings_actions.py (8 code lines)
class SettingsActions:
    """Handles settings menu actions for various configuration options."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize settings actions handler."""
        self.parent = parent

    def settings(self) -> None:
        """Open settings dialog to modify application settings."""
        pass  # TODO: Implement settings dialog interaction

    def general(self) -> None:
        """Open general settings tab."""
        pass  # TODO: Implement general settings tab

    def shortcuts(self) -> None:
        """Open shortcuts settings tab."""
        pass  # TODO: Implement shortcuts settings tab

    def display(self) -> None:
        """Open display settings tab."""
        pass  # TODO: Implement display settings tab

    def appearance(self) -> None:
        """Open appearance settings tab."""
        pass  # TODO: Implement appearance settings tab

    def formats(self) -> None:
        """Open formats settings tab."""
        pass  # TODO: Implement formats settings tab

>> ðŸ“‹ actions\tools_actions.py (6 code lines)
class ToolsActions:
    """Handles tools menu actions for validation and scene utilities."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize tools actions handler."""
        self.parent = parent

    def rebuild_scene(self) -> None:
        """Rebuild the current visualization scene from scratch."""
        pass  # TODO: Implement scene rebuild

    def recompute_generations(self) -> None:
        """Recalculate generation levels for all persons."""
        pass  # TODO: Implement generation computation

    def validate_marriages(self) -> None:
        """Check for inconsistencies in marriage records."""
        pass  # TODO: Implement marriage validation

    def validate_parentage(self) -> None:
        """Check for inconsistencies in parent-child relationships."""
        pass  # TODO: Implement parentage validation


>> ðŸ“‹ actions\view_actions.py (6 code lines)
class ViewActions:
    """Handles view menu actions for switching between visualizations."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize view actions handler."""
        self.parent = parent

    def family_trees(self) -> None:
        """Switch to family trees visualization view."""
        pass  # TODO: Implement family trees view

    def timeline(self) -> None:
        """Switch to timeline visualization view."""
        pass  # TODO: Implement timeline view

    def dynasty(self) -> None:
        """Switch to dynasty visualization view."""
        pass  # TODO: Implement dynasty view

    def data_table(self) -> None:
        """Switch to data table view."""
        pass  # TODO: Implement data table view



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\base_command.py (9 code lines)
import re

class BaseCommand:
    """Base class for all undoable commands."""
    
    def __init__(self):
        self._executed = False  
    
    def description(self) -> str:
        """Return human-readable description for UI display."""
        class_name = self.__class__.__name__
        if class_name.endswith("Command"):
            class_name = class_name[:-7]

        spaced = re.sub(r'([a-z])([A-Z])', r'\1 \2', class_name)
        
        return spaced
    
    def run(self) -> None:
        """Execute the command."""
        raise NotImplementedError("Subclasses must implement run()")
    
    def undo(self) -> None:
        """Reverse the command's effects."""
        raise NotImplementedError("Subclasses must implement undo()")


>> âœ… commands\genealogy_commands\__init__.py (26 code lines)
from .add_event import AddEventCommand
from .add_marriage import CreateMarriageCommand
from .add_person import AddPersonCommand
from .assign_parent import AssignParentCommand
from .create_child import CreateChildCommand
from .delete_event import DeleteEventCommand
from .edit_event import EditEventCommand
from .edit_marriage import EditMarriageCommand
from .edit_person import EditPersonCommand
from .end_marriage import EndMarriageCommand
from .delete_person import DeletePersonCommand
from .unassign_parent import UnassignParentCommand

__all__ = [
    "AddEventCommand",
    "CreateMarriageCommand",
    "AddPersonCommand",
    "AssignParentCommand",
    "CreateChildCommand",
    "DeleteEventCommand",
    "EditEventCommand",
    "EditMarriageCommand",
    "EditPersonCommand",
    "EndMarriageCommand",
    "DeletePersonCommand",
    "UnassignParentCommand"
]

>> ðŸ“‹ commands\genealogy_commands\add_event.py (3 code lines)
"""Command for adding an event to a person."""

from commands.base_command import BaseCommand


class AddEventCommand(BaseCommand):
    """Add a life event to a person."""

    def __init__(self, event_data: dict) -> None:
        """Initialize the add event command."""
        self.event_data = event_data
        self.event_id: int | None = None

    def run(self) -> None:
        """Insert the event into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated event_id for undo
        pass

    def undo(self) -> None:
        """Remove the event from the database."""
        # TODO: Implement database DELETE using stored event_id
        pass


>> ðŸ“‹ commands\genealogy_commands\add_marriage.py (3 code lines)
"""Command for creating a marriage between two people."""

from commands.base_command import BaseCommand


class CreateMarriageCommand(BaseCommand):
    """Create a marriage relationship between two people."""

    def __init__(self, marriage_data: dict) -> None:
        """Initialize the create marriage command."""
        self.marriage_data = marriage_data
        self.marriage_id: int | None = None

    def run(self) -> None:
        """Insert the marriage into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated marriage_id for undo
        # TODO: Handle surname changes if configured
        pass

    def undo(self) -> None:
        """Remove the marriage from the database."""
        # TODO: Implement database DELETE
        # TODO: Revert surname changes if applicable
        pass


>> ðŸ“‹ commands\genealogy_commands\add_person.py (8 code lines)
"""Command for adding a new person to the database."""

from __future__ import annotations
from typing import TYPE_CHECKING

from models.person import Person
from commands.base_command import BaseCommand
from database.person_repository import PersonRepository

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class AddPersonCommand(BaseCommand):
    """Add a new person to the dynasty database with undo support."""

    def __init__(self, db_manager: DatabaseManager, person: Person) -> None:
        """Initialize the add person command."""
        self.person = person
        self.person_id: int | None = None
        self.repo = PersonRepository(db_manager)

    def run(self) -> None:
        """Insert the person into the database and store the assigned ID."""
        if self.person_id is None:
            self.person_id = self.repo.insert(self.person)
            self.person.id = self.person_id

        else:
            self.person.id = self.person_id
            self.repo.insert_with_id(self.person)

    def undo(self) -> None:
        """Remove the person from the database."""
        if self.person_id is not None:
            self.repo.delete(self.person_id)

>> ðŸ“‹ commands\genealogy_commands\assign_parent.py (9 code lines)
"""Command for assigning a parent to a person."""

from commands.base_command import BaseCommand


class AssignParentCommand(BaseCommand):
    """Set or change a person's father or mother."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the assign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_id = parent_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Assign the parent relationship in database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Update father_id or mother_id based on parent_type
        pass

    def undo(self) -> None:
        """Restore original parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\genealogy_commands\create_child.py (11 code lines)
"""Command for creating a child with automatic parent assignment."""

from commands.base_command import BaseCommand


class CreateChildCommand(BaseCommand):
    """Create a new person as child of specified parents."""

    def __init__(
        self,
        database_connection,
        first_name: str,
        last_name: str,
        father_id: int | None = None,
        mother_id: int | None = None,
        **kwargs,
    ) -> None:
        """Initialize the create child command."""
        self.db = database_connection
        self.first_name = first_name
        self.last_name = last_name
        self.father_id = father_id
        self.mother_id = mother_id
        self.additional_data = kwargs
        self.created_person_id: int | None = None
        # TODO: Store created person ID for undo

    def run(self) -> None:
        """Create new person with parent relationships."""
        # TODO: Insert new person into database
        # TODO: Set father_id and mother_id
        # TODO: Store created_person_id
        pass

    def undo(self) -> None:
        """Delete the created child."""
        # TODO: Delete person record using created_person_id
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_event.py (3 code lines)
"""Command for deleting an event from the database."""

from commands.base_command import BaseCommand


class DeleteEventCommand(BaseCommand):
    """Remove an event from the database."""

    def __init__(self, database_connection, event_id: int) -> None:
        """Initialize the delete event command."""
        self.db = database_connection
        self.event_id = event_id
        self.deleted_data: dict = {}
        # TODO: Store complete event data for undo

    def run(self) -> None:
        """Delete the event from database."""
        # TODO: Fetch and save complete event data to deleted_data
        # TODO: Delete event record from database
        pass

    def undo(self) -> None:
        """Restore the deleted event."""
        # TODO: Re-insert event record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_marriage.py (3 code lines)
"""Command for deleting a marriage from the database."""

from commands.base_command import BaseCommand


class DeleteMarriageCommand(BaseCommand):
    """Remove a marriage relationship from the database."""

    def __init__(self, database_connection, marriage_id: int) -> None:
        """Initialize the delete marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.deleted_data: dict = {}
        # TODO: Store complete marriage data for undo

    def run(self) -> None:
        """Delete the marriage from database."""
        # TODO: Fetch and save complete marriage data to deleted_data
        # TODO: Delete marriage record from database
        pass

    def undo(self) -> None:
        """Restore the deleted marriage."""
        # TODO: Re-insert marriage record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_person.py (3 code lines)
"""Command for removing a person from the database."""

from commands.base_command import BaseCommand


class DeletePersonCommand(BaseCommand):
    """Delete a person from the dynasty database."""

    def __init__(self, person_id: int) -> None:
        """Initialize the delete person command."""
        self.person_id = person_id
        self.person_data: dict | None = None

    def run(self) -> None:
        """Remove the person from the database."""
        # TODO: Fetch and store all person data for undo
        # TODO: Implement database DELETE
        # TODO: Handle cascade effects (orphaned children, etc.)
        pass

    def undo(self) -> None:
        """Restore the deleted person."""
        # TODO: Implement database INSERT with stored person_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_event.py (3 code lines)
"""Command for editing an existing event."""

from commands.base_command import BaseCommand


class EditEventCommand(BaseCommand):
    """Edit details of an existing event."""

    def __init__(self, database_connection, event_id: int, **kwargs) -> None:
        """Initialize the edit event command."""
        self.db = database_connection
        self.event_id = event_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original event data for undo

    def run(self) -> None:
        """Update event details in database."""
        # TODO: Save current state to old_data
        # TODO: Update event record with new_data
        pass

    def undo(self) -> None:
        """Restore original event details."""
        # TODO: Restore event record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_marriage.py (3 code lines)
"""Command for editing an existing marriage."""

from commands.base_command import BaseCommand


class EditMarriageCommand(BaseCommand):
    """Edit details of an existing marriage relationship."""

    def __init__(self, database_connection, marriage_id: int, **kwargs) -> None:
        """Initialize the edit marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original marriage data for undo

    def run(self) -> None:
        """Update marriage details in database."""
        # TODO: Save current state to old_data
        # TODO: Update marriage record with new_data
        pass

    def undo(self) -> None:
        """Restore original marriage details."""
        # TODO: Restore marriage record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_person.py (3 code lines)
"""Command for editing an existing person."""

from commands.base_command import BaseCommand


class EditPersonCommand(BaseCommand):
    """Edit an existing person in the database."""

    def __init__(self, person_id: int, new_data: dict) -> None:
        """Initialize the edit person command."""
        self.person_id = person_id
        self.new_data = new_data
        self.old_data: dict | None = None

    def run(self) -> None:
        """Update the person in the database."""
        # TODO: Fetch and store old data for undo
        # TODO: Implement database UPDATE
        pass

    def undo(self) -> None:
        """Restore the person's original data."""
        # TODO: Implement database UPDATE with old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\end_marriage.py (10 code lines)
"""Command for ending a marriage with divorce or death."""

from commands.base_command import BaseCommand


class EndMarriageCommand(BaseCommand):
    """Mark a marriage as ended with a specific date."""

    def __init__(
        self,
        database_connection,
        marriage_id: int,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
    ) -> None:
        """Initialize the end marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.old_end_date: tuple[int | None, int | None, int | None] = (None, None, None)
        # TODO: Store original end date for undo

    def run(self) -> None:
        """Set the marriage end date in database."""
        # TODO: Save current end date to old_end_date
        # TODO: Update marriage end_year, end_month, end_day
        pass

    def undo(self) -> None:
        """Restore original marriage end date."""
        # TODO: Restore end date from old_end_date
        pass


>> ðŸ“‹ commands\genealogy_commands\unassign_parent.py (8 code lines)
"""Command for removing a parent assignment from a person."""

from commands.base_command import BaseCommand


class UnassignParentCommand(BaseCommand):
    """Remove a person's father or mother relationship."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the unassign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Remove the parent relationship from database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Set father_id or mother_id to NULL based on parent_type
        pass

    def undo(self) -> None:
        """Restore the parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\GUI_commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\change_skin.py (3 code lines)
"""Command for changing the application color scheme."""

from commands.base_command import BaseCommand


class ChangeSkinCommand(BaseCommand):
    """Switch between different UI color schemes."""

    def __init__(self, new_skin: str, old_skin: str) -> None:
        """Initialize the change skin command."""
        self.new_skin = new_skin
        self.old_skin = old_skin
        # TODO: Add reference to skin manager

    def run(self) -> None:
        """Apply the new color scheme."""
        # TODO: Load new skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass

    def undo(self) -> None:
        """Restore previous color scheme."""
        # TODO: Load old skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass


>> ðŸ“‹ commands\GUI_commands\change_view.py (3 code lines)
"""Command for switching between different visualization views."""

from commands.base_command import BaseCommand


class ChangeViewCommand(BaseCommand):
    """Switch between tree, timeline, table, and stats views."""

    def __init__(self, new_view: str, old_view: str) -> None:
        """Initialize the change view command."""
        self.new_view = new_view  # "tree", "timeline", "table", "stats"
        self.old_view = old_view
        # TODO: Add reference to main window

    def run(self) -> None:
        """Switch to the new visualization view."""
        # TODO: Hide current view widget
        # TODO: Show new view widget
        # TODO: Update menu checkmarks
        pass

    def undo(self) -> None:
        """Switch back to the previous view."""
        # TODO: Hide current view widget
        # TODO: Show old view widget
        # TODO: Update menu checkmarks
        pass


>> ðŸ“‹ commands\GUI_commands\move_node.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\move_person.py (10 code lines)
"""Command for moving a person box in the tree view."""

from commands.base_command import BaseCommand


class MovePersonCommand(BaseCommand):
    """Move a person's visual position in the tree canvas."""

    def __init__(
        self,
        person_id: int,
        new_x: float,
        new_y: float,
        old_x: float,
        old_y: float,
    ) -> None:
        """Initialize the move person command."""
        self.person_id = person_id
        self.new_x = new_x
        self.new_y = new_y
        self.old_x = old_x
        self.old_y = old_y
        # TODO: Add reference to canvas/scene for visual updates

    def run(self) -> None:
        """Move person box to new position."""
        # TODO: Update PersonPosition table in database
        # TODO: Update visual position on canvas
        pass

    def undo(self) -> None:
        """Restore person box to original position."""
        # TODO: Update PersonPosition table with old coordinates
        # TODO: Update visual position on canvas
        pass


>> ðŸ“‹ commands\GUI_commands\preference_changes.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\rebuild_scene.py (3 code lines)
"""Command for rebuilding the entire visualization scene."""

from commands.base_command import BaseCommand


class RebuildSceneCommand(BaseCommand):
    """Rebuild the current view from database state."""

    def __init__(self, database_connection, view_type: str) -> None:
        """Initialize the rebuild scene command."""
        self.db = database_connection
        self.view_type = view_type  # "tree", "timeline", "table", "stats"
        # TODO: Store current scene state for undo

    def run(self) -> None:
        """Clear and rebuild the visualization scene."""
        # TODO: Clear current scene/view
        # TODO: Reload all data from database
        # TODO: Recreate all visual elements
        pass

    def undo(self) -> None:
        """Restore previous scene state."""
        # TODO: Restore from saved scene state
        pass


>> ðŸ“‹ commands\GUI_commands\recompute_generation.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\recompute_generations.py (3 code lines)
"""Command for recalculating generation levels for all people."""

from commands.base_command import BaseCommand


class RecomputeGenerationsCommand(BaseCommand):
    """Recalculate generation numbers for entire family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the recompute generations command."""
        self.db = database_connection
        self.old_generations: dict[int, int] = {}
        # TODO: Store original generation assignments for undo

    def run(self) -> None:
        """Calculate and update generation levels."""
        # TODO: Use GenerationCalculator to compute levels
        # TODO: Update Person table with new generation values
        # TODO: Update tree view layout
        pass

    def undo(self) -> None:
        """Restore original generation assignments."""
        # TODO: Restore generation values from old_generations
        # TODO: Update tree view layout
        pass


>> ðŸ“‹ commands\GUI_commands\timeline_scroll.py (0 code lines)


>> ðŸ“‹ commands\undo_redo_manager.py (19 code lines)
from __future__ import annotations

from commands.base_command import BaseCommand


class UndoRedoManager:
    """Manages undo and redo stacks for command pattern operations."""
    
    def __init__(self) -> None:
        """Initialize the undo/redo manager with empty stacks."""
        self.undo_stack: list[BaseCommand] = []
        self.redo_stack: list[BaseCommand] = []
    
    def execute(self, command: BaseCommand) -> None:  
        """Execute a command and add it to the undo stack."""
        command.run()
        self.undo_stack.append(command)
        self.redo_stack.clear()
    
    def undo(self) -> bool:
        """Undo the last executed command."""
        if not self.undo_stack:
            return False
        cmd = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
        return True
    
    def redo(self) -> bool:
        """Redo the last undone command."""
        if not self.redo_stack:
            return False
        cmd = self.redo_stack.pop()
        cmd.run()
        self.undo_stack.append(cmd)
        return True
    
    def can_undo(self) -> bool:
        """Check if there are commands available to undo."""
        return len(self.undo_stack) > 0
    
    def can_redo(self) -> bool:
        """Check if there are commands available to redo."""
        return len(self.redo_stack) > 0
    
    def peek_undo(self) -> BaseCommand | None:
        """Get the next command that would be undone without executing it."""
        if self.can_undo():
            return self.undo_stack[-1]
        return None
    
    def peek_redo(self) -> BaseCommand | None:
        """Get the next command that would be redone without executing it."""
        if self.can_redo():
            return self.redo_stack[-1]
        return None

>> ðŸ“‹ commands\view_changes.py (0 code lines)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIALOGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ dialogs\__init__.py (0 code lines)
"""Dialog implementations for user interactions."""

from .add_person_dialog import AddPersonDialog
from .end_marriage_dialog import EndMarriageDialog
from .create_marriage_dialog import CreateMarriageDialog
from .create_child_dialog import CreateChildDialog

__all__ = ['AddPersonDialog', 'EndMarriageDialog', 'CreateMarriageDialog', 'CreateChildDialog']

>> ðŸ“‹ dialogs\about_dialog.py (1 code lines)
"""About dialog showing application information."""

from PySide6.QtWidgets import QDialog


class AboutDialog(QDialog):
    """Dialog displaying application information and credits."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the about dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add application name, version, credits
        # TODO: Add license information
        # TODO: Add GitHub link
        pass


>> âœ… dialogs\add_person_dialog.py (60 code lines)
"""Dialog for adding a new person to the database."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QSpinBox, QComboBox, QTextEdit,
    QPushButton, QLabel, QDialogButtonBox, QCheckBox, QWidget
)
from PySide6.QtCore import Qt

from models.person import Person
from widgets.date_picker import DatePicker  # Import our new widget


class AddPersonDialog(QDialog):
    """Dialog for adding a new person with essential information."""
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the add person dialog."""
        super().__init__(parent)
        
        self.setWindowTitle("Add New Person")
        self.setMinimumWidth(500)  # Slightly wider for date pickers
        
        self._person: Person | None = None
        
        self._setup_ui()
        self._connect_signals()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create and arrange all dialog widgets."""
        self.main_layout = QVBoxLayout(self)  # Store as instance variable
        
        # Special character toolbar
        self.main_layout.addLayout(self._create_special_char_toolbar())
        
        # Add separator line
        separator = QLabel()
        separator.setFrameShape(QLabel.Shape.HLine)
        separator.setFrameShadow(QLabel.Shadow.Sunken)
        self.main_layout.addWidget(separator)
        
        # Form fields
        self.main_layout.addLayout(self._create_form_layout())
        
        # OK/Cancel buttons
        self.main_layout.addWidget(self._create_button_box())
    
    def _create_special_char_toolbar(self) -> QHBoxLayout:
        """Create toolbar with special character buttons."""
        toolbar = QHBoxLayout()
        
        # Label
        label = QLabel("Special Characters:")
        toolbar.addWidget(label)
        
        # Character buttons
        special_chars = ['Ã¡', 'Ã½', 'Ã³', 'Ã©', 'Ã­']
        
        for char in special_chars:
            btn = QPushButton(char)
            btn.setMaximumWidth(40)
            btn.setToolTip(f"Insert '{char}' at cursor")
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.clicked.connect(lambda checked, c=char: self._insert_special_char(c))
            toolbar.addWidget(btn)
        
        toolbar.addStretch()
        
        return toolbar
    
    def _create_form_layout(self) -> QFormLayout:
        """Create the main form with input fields."""
        form = QFormLayout()
        
        # First Name (required)
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        form.addRow("First Name: *", self.first_name_input)
        
        # Middle Name (optional)
        self.middle_name_input = QLineEdit()
        self.middle_name_input.setPlaceholderText("Optional")
        form.addRow("Middle Name:", self.middle_name_input)
        
        # Last Name (required)
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        form.addRow("Last Name: *", self.last_name_input)
        
        # Gender (optional)
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        form.addRow("Gender:", self.gender_input)
        
        # --- Date Section ---
        
        # Born in Town checkbox
        self.born_in_town_check = QCheckBox("Born in Town")
        self.born_in_town_check.setChecked(False)  # Default: arrived from elsewhere
        form.addRow("", self.born_in_town_check)
        
        # Birth Date picker FIRST (stays visible always)
        self.birth_date_picker = DatePicker()
        form.addRow("Birth Date: *", self.birth_date_picker)
        
        # Arrival Date picker SECOND (disappears when born in town)
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_picker = DatePicker()
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
        
        # Notes (optional)
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this person...")
        self.notes_input.setMaximumHeight(80)
        form.addRow("Notes:", self.notes_input)
        
        return form
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create OK and Cancel buttons."""
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        
        return button_box
    
    # ------------------------------------------------------------------
    # Signal Handlers
    # ------------------------------------------------------------------
    
    def _connect_signals(self) -> None:
        """Connect widget signals to handlers."""
        # When "Born in Town" changes, show/hide arrival date
        self.born_in_town_check.stateChanged.connect(self._update_date_visibility)
        
        # Set initial visibility
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show or hide arrival date based on 'Born in Town' checkbox."""
        is_born_in_town = self.born_in_town_check.isChecked()
        
        # Hide/show arrival date row
        self.arrival_date_label.setVisible(not is_born_in_town)
        self.arrival_date_picker.setVisible(not is_born_in_town)
        
        # Adjust birth date precision hint
        if is_born_in_town:
            # Born in town: we know the precise month
            self.birth_date_picker.unknown_check.setChecked(False)
        else:
            # Arrived: might only know birth year
            self.birth_date_picker.unknown_check.setChecked(True)
        
        # Force layout to recalculate and resize dialog
        self.main_layout.invalidate()  # Use stored reference
        self.main_layout.activate()
        
        # Resize dialog to fit new content
        self.resize(self.minimumSizeHint())

    def _insert_special_char(self, char: str) -> None:
        """Insert a special character at the cursor position."""
        focused = self.focusWidget()
        
        if isinstance(focused, QLineEdit):
            focused.insert(char)
            focused.setFocus()
    
    def _handle_accept(self) -> None:
        """Validate inputs and create Person object before accepting."""
        if not self._validate_inputs():
            return
        
        # Get dates from pickers
        birth_year, birth_month = self.birth_date_picker.get_date()
        
        # Get arrival date if not born in town
        arrival_year = None
        arrival_month = None
        if not self.born_in_town_check.isChecked():
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        
        # Create Person object from form data
        self._person = Person(
            first_name = self.first_name_input.text().strip(),
            middle_name = self.middle_name_input.text().strip(),
            last_name = self.last_name_input.text().strip(),
            birth_year = birth_year,
            birth_month = birth_month,
            arrival_year = arrival_year,
            arrival_month = arrival_month,
            gender = self.gender_input.currentText(),
            notes = self.notes_input.toPlainText().strip()
        )
        
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate required fields and show error if invalid."""
        # First name required
        if not self.first_name_input.text().strip():
            self._show_error("First name is required.")
            self.first_name_input.setFocus()
            return False
        
        # Last name required
        if not self.last_name_input.text().strip():
            self._show_error("Last name is required.")
            self.last_name_input.setFocus()
            return False
        
        # Birth year required (always has a value from DatePicker)
        birth_year, _ = self.birth_date_picker.get_date()
        if birth_year < 1500 or birth_year > 2000:
            self._show_error("Birth year must be between 1500 and 2000.")
            return False
        
        return True
    
    def _show_error(self, message: str) -> None:
        """Display an error message to the user."""
        from PySide6.QtWidgets import QMessageBox
        
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Validation Error")
        msg.setText(message)
        msg.exec()
    
    # ------------------------------------------------------------------
    # Public Methods
    # ------------------------------------------------------------------
    
    def get_person(self) -> Person | None:
        """Return the created Person object."""
        return self._person

>> âœ… dialogs\create_child_dialog.py (66 code lines)
"""Dialog for creating a new child."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit,
    QComboBox, QLabel, QDialogButtonBox, QWidget, QMessageBox, 
    QCheckBox, QFrame
)
from PySide6.QtCore import QSignalBlocker, Qt

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from models.person import Person
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateChildDialog(QDialog):
    """Dialog for creating a new child with pre-filled parents."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        parent1: Person,
        parent2_id: int | None = None,
        parent_widget: QWidget | None = None
    ) -> None:
        super().__init__(parent_widget)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        self.parent1 = parent1
        self.parent2_id = parent2_id
        
        self.created_person: Person | None = None
        
        self.setWindowTitle("Create Child")
        self.setMinimumWidth(550)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        LABEL_WIDTH = 85  # Consistent label width for alignment
        
        # Parents header
        parents_header = QLabel("<b>Parents:</b>")
        layout.addWidget(parents_header)
        
        # Parent 1 (indented)
        parent1_layout = QHBoxLayout()
        parent1_layout.addSpacing(20)
        parent1_label_text = QLabel("Parent 1:")
        parent1_label_text.setMinimumWidth(LABEL_WIDTH)
        parent1_layout.addWidget(parent1_label_text)
        parent1_name = QLabel(f"<b>{self.parent1.display_name}</b>")
        parent1_layout.addWidget(parent1_name)
        parent1_layout.addStretch()
        layout.addLayout(parent1_layout)
        
        # Parent 2 (indented)
        parent2_layout = QHBoxLayout()
        parent2_layout.addSpacing(20)
        parent2_label_text = QLabel("Parent 2:")
        parent2_label_text.setMinimumWidth(LABEL_WIDTH)
        parent2_layout.addWidget(parent2_label_text)
        self.parent2_selector = PersonSelector(self.db_manager)
        if self.parent2_id:
            with QSignalBlocker(self.parent2_selector):
                self.parent2_selector.set_person(self.parent2_id)
        parent2_layout.addWidget(self.parent2_selector)
        layout.addLayout(parent2_layout)
        
        # Divider line
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        layout.addWidget(line)
        
        # Child Information header
        child_header = QLabel("<b>Child Information:</b>")
        layout.addWidget(child_header)
        
        # First Name (indented)
        first_name_layout = QHBoxLayout()
        first_name_layout.addSpacing(20)
        first_name_label = QLabel("First Name: *")
        first_name_label.setMinimumWidth(LABEL_WIDTH)
        first_name_layout.addWidget(first_name_label)
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        first_name_layout.addWidget(self.first_name_input)
        layout.addLayout(first_name_layout)
        
        # Last Name (indented)
        last_name_layout = QHBoxLayout()
        last_name_layout.addSpacing(20)
        last_name_label = QLabel("Last Name: *")
        last_name_label.setMinimumWidth(LABEL_WIDTH)
        last_name_layout.addWidget(last_name_label)
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        self.last_name_input.setText(self.parent1.last_name)
        last_name_layout.addWidget(self.last_name_input)
        layout.addLayout(last_name_layout)
        
        # Gender (indented)
        gender_layout = QHBoxLayout()
        gender_layout.addSpacing(20)
        gender_label = QLabel("Gender:")
        gender_label.setMinimumWidth(LABEL_WIDTH)
        gender_layout.addWidget(gender_label)
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        self.gender_input.setMinimumWidth(120)
        gender_layout.addWidget(self.gender_input)
        gender_layout.addStretch()
        layout.addLayout(gender_layout)
        
        # Birth Date (indented)
        birth_date_layout = QHBoxLayout()
        birth_date_layout.addSpacing(20)
        birth_date_label = QLabel("Birth Date:")
        birth_date_label.setMinimumWidth(LABEL_WIDTH)
        birth_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        birth_date_layout.addWidget(birth_date_label)
        self.birth_date_picker = DatePicker()
        self.birth_date_picker.set_date(1721, 1)
        birth_date_layout.addWidget(self.birth_date_picker)
        birth_date_layout.addStretch()
        layout.addLayout(birth_date_layout)
        
        # Immigrant checkbox (indented to align with field labels)
        immigrant_layout = QHBoxLayout()
        immigrant_layout.addSpacing(20)
        self.immigrant_check = QCheckBox("Immigrant")
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        immigrant_layout.addWidget(self.immigrant_check)
        immigrant_layout.addStretch()
        layout.addLayout(immigrant_layout)
        
        # Arrival Date (indented)
        arrival_date_layout = QHBoxLayout()
        arrival_date_layout.addSpacing(20)
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_label.setMinimumWidth(LABEL_WIDTH)
        self.arrival_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        arrival_date_layout.addWidget(self.arrival_date_label)
        self.arrival_date_picker = DatePicker()
        self.arrival_date_picker.set_date(1721, 1)
        arrival_date_layout.addWidget(self.arrival_date_picker)
        arrival_date_layout.addStretch()
        layout.addLayout(arrival_date_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        self._update_immigrant_state()
    
    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_state()
    
    def _update_immigrant_state(self) -> None:
        """Update visibility based on immigrant status."""
        is_immigrant = self.immigrant_check.isChecked()
        
        self.birth_date_picker.unknown_check.setVisible(False)
        self.birth_date_picker.month_spin.setEnabled(not is_immigrant)
        
        if is_immigrant:
            self.birth_date_picker.unknown_check.setChecked(True)
        else:
            self.birth_date_picker.unknown_check.setChecked(False)
        
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)
        self.arrival_date_picker.unknown_check.setVisible(False)
    
    def _handle_accept(self) -> None:
        """Validate and create child."""
        first_name = self.first_name_input.text().strip()
        last_name = self.last_name_input.text().strip()
        
        if not first_name:
            QMessageBox.warning(self, "Validation Error", "First name is required.")
            return
        
        if not last_name:
            QMessageBox.warning(self, "Validation Error", "Last name is required.")
            return
        
        gender = self.gender_input.currentText()
        
        if self.immigrant_check.isChecked():
            birth_year, _ = self.birth_date_picker.get_date()
            birth_month = None
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        else:
            birth_year, birth_month = self.birth_date_picker.get_date()
            arrival_year, arrival_month = None, None
        
        father_id = None
        mother_id = None
        parent2_id = self.parent2_selector.get_person_id()
        
        if self.parent1.gender == "Male":
            father_id = self.parent1.id
            if parent2_id:
                mother_id = parent2_id
        elif self.parent1.gender == "Female":
            mother_id = self.parent1.id
            if parent2_id:
                father_id = parent2_id
        else:
            father_id = self.parent1.id
            mother_id = parent2_id
        
        new_person = Person(
            first_name=first_name,
            last_name=last_name,
            gender=gender,
            birth_year=birth_year,
            birth_month=birth_month,
            arrival_year=arrival_year,
            arrival_month=arrival_month,
            father_id=father_id,
            mother_id=mother_id,
            dynasty_id=self.parent1.dynasty_id
        )
        
        person_id = self.person_repo.insert(new_person)
        new_person.id = person_id
        
        self.created_person = new_person
        
        self.accept()
    
    def get_created_person(self) -> Person | None:
        """Returns the created child Person."""
        return self.created_person

>> âœ… dialogs\create_marriage_dialog.py (36 code lines)
"""Dialog for creating a new marriage."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QCheckBox,
    QDialogButtonBox, QWidget, QMessageBox
)

from database.db_manager import DatabaseManager
from models.person import Person
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateMarriageDialog(QDialog):
    """Dialog for creating a new marriage relationship."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person = person
        self.spouse_id: int | None = None
        self.marriage_year: int | None = None
        self.marriage_month: int | None = None
        
        self.setWindowTitle("Create Marriage")
        self.setMinimumWidth(450)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        # Person 1
        person1_layout = QHBoxLayout()
        person1_layout.addWidget(QLabel("Person 1:"))
        person1_label = QLabel(f"<b>{self.person.display_name}</b>")
        person1_layout.addWidget(person1_label)
        person1_layout.addStretch()
        layout.addLayout(person1_layout)
        
        # Person 2
        person2_layout = QHBoxLayout()
        person2_layout.addWidget(QLabel("Person 2:"))
        self.spouse_selector = PersonSelector(self.db_manager)
        person2_layout.addWidget(self.spouse_selector)
        layout.addLayout(person2_layout)
        
        # Date Unknown checkbox
        date_unknown_layout = QHBoxLayout()
        date_unknown_layout.addSpacing(85)  # Align with fields above
        self.date_unknown_check = QCheckBox("Date Unknown")
        self.date_unknown_check.setChecked(True)
        self.date_unknown_check.stateChanged.connect(self._on_date_unknown_toggled)
        date_unknown_layout.addWidget(self.date_unknown_check)
        date_unknown_layout.addStretch()
        layout.addLayout(date_unknown_layout)
        
        # Marriage date
        marriage_date_layout = QHBoxLayout()
        self.marriage_date_label = QLabel("Marriage Date:")
        marriage_date_layout.addWidget(self.marriage_date_label)
        self.marriage_date = DatePicker()
        self.marriage_date.set_date(1721, 1)
        self.marriage_date.unknown_check.setVisible(False)
        marriage_date_layout.addWidget(self.marriage_date)
        marriage_date_layout.addStretch()
        layout.addLayout(marriage_date_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        self._update_date_visibility()
    
    def _on_date_unknown_toggled(self) -> None:
        """Handle date unknown checkbox toggle."""
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show/hide marriage date based on checkbox."""
        date_known = not self.date_unknown_check.isChecked()
        self.marriage_date_label.setVisible(date_known)
        self.marriage_date.setVisible(date_known)
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        spouse_id = self.spouse_selector.get_person_id()
        
        if not spouse_id:
            QMessageBox.warning(self, "Validation Error", "Please select a spouse.")
            return
        
        if spouse_id == self.person.id:
            QMessageBox.warning(self, "Validation Error", "A person cannot marry themselves.")
            return
        
        # Only get date if Date Unknown is NOT checked
        if self.date_unknown_check.isChecked():
            # Explicitly set to None - date is unknown
            self.spouse_id = spouse_id
            self.marriage_year = None
            self.marriage_month = None
        else:
            # Get date from picker
            year, month = self.marriage_date.get_date()
            self.spouse_id = spouse_id
            self.marriage_year = year
            self.marriage_month = month
        
        self.accept()
    
    def get_marriage_data(self) -> tuple[int | None, int | None, int | None]:
        """Returns (spouse_id, year, month)."""
        return (self.spouse_id, self.marriage_year, self.marriage_month)

>> âœ… dialogs\edit_person_dialog.py (73 code lines)
"""Dialog for editing a person with tabbed sections."""

from PySide6.QtWidgets import (
    QDialog, QHBoxLayout, QVBoxLayout, QListWidget,
    QStackedWidget, QDialogButtonBox, QWidget, QLabel,
    QMessageBox
)
from PySide6.QtCore import Qt

from database.db_manager import DatabaseManager
from models.person import Person
from dialogs.edit_person_panels.general_panel import GeneralPanel

class EditPersonDialog(QDialog):
    """Tabbed dialog for comprehensive person editing."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        """Initialize the edit person dialog."""
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person = person
        
        # Track if user has made changes
        self.has_unsaved_changes = False
        
        # Edited person data (will be filled by panels)
        self.edited_person: Person | None = None
        
        self.setWindowTitle(f"Edit Person: {person.display_name}")
        self.setMinimumSize(700, 500)
        
        self._setup_ui()
        self._load_data()
    
    def _setup_ui(self) -> None:
        """Create the main dialog layout with sidebar and panels."""
        main_layout = QVBoxLayout(self)
        
        # Horizontal split: sidebar | content
        content_layout = QHBoxLayout()
        
        # Left sidebar - panel selector
        self.panel_list = QListWidget()
        self.panel_list.setMaximumWidth(150)
        self.panel_list.addItem("General")
        self.panel_list.addItem("Relationships")
        self.panel_list.addItem("Events")
        self.panel_list.currentRowChanged.connect(self._on_panel_changed)
        
        # Right side - stacked panels
        self.panel_stack = QStackedWidget()
        
        # Create placeholder panels (we'll build these next)
        self.general_panel = self._create_general_panel()
        self.relationships_panel = self._create_relationships_panel()
        self.events_panel = self._create_events_panel()
        
        self.panel_stack.addWidget(self.general_panel)
        self.panel_stack.addWidget(self.relationships_panel)
        self.panel_stack.addWidget(self.events_panel)
        
        # Add to content layout
        content_layout.addWidget(self.panel_list)
        content_layout.addWidget(self.panel_stack, stretch=1)
        
        main_layout.addLayout(content_layout)
        
        # Bottom buttons - three button layout
        button_box = QDialogButtonBox()
        
        # Apply button - saves without closing
        self.apply_button = button_box.addButton(
            "Apply",
            QDialogButtonBox.ButtonRole.ApplyRole
        )
        self.apply_button.clicked.connect(self._handle_apply)
        
        # OK button - saves and closes
        self.ok_button = button_box.addButton(
            QDialogButtonBox.StandardButton.Ok
        )
        self.ok_button.clicked.connect(self._handle_ok)
        
        # Cancel button - closes without saving
        self.cancel_button = button_box.addButton(
            QDialogButtonBox.StandardButton.Cancel
        )
        self.cancel_button.clicked.connect(self.reject)
        
        main_layout.addWidget(button_box)
        
        # Select first panel
        self.panel_list.setCurrentRow(0)
    
    def _create_general_panel(self) -> QWidget:
        """Create the General information panel."""
        self.general_panel_widget = GeneralPanel(self)
        return self.general_panel_widget
    
    def _create_relationships_panel(self) -> QWidget:
        """Create the Relationships panel (parents, marriages, children)."""
        from dialogs.edit_person_panels.relationships_panel import RelationshipsPanel
        self.relationships_panel_widget = RelationshipsPanel(self.db_manager, self)
        return self.relationships_panel_widget
        
    def _create_events_panel(self) -> QWidget:
        """Create the Events panel (timeline of life events)."""
        # Placeholder
        panel = QWidget()
        layout = QVBoxLayout(panel)
        
        placeholder = QLabel("Events Panel - Coming Soon")
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(placeholder)
        
        return panel
    
    def _on_panel_changed(self, index: int) -> None:
        """Handle panel selection change."""
        self.panel_stack.setCurrentIndex(index)
    
    def _load_data(self) -> None:
        """Load person data into all panels."""
        self.general_panel_widget.load_person(self.person)
        self.relationships_panel_widget.load_person(self.person)  # This line must be here!
            
    def _handle_apply(self) -> None:
        """Save changes but keep dialog open (Apply button)."""
        if self._save_changes():
            self.has_unsaved_changes = False
    
    def _handle_ok(self) -> None:
        """Save changes and close dialog with confirmation (OK button)."""
        if self._save_changes():
            self.has_unsaved_changes = False
            
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Information)
            msg.setWindowTitle("Changes Saved")
            msg.setText("Your edits have been saved successfully.")
            msg.exec()
            
            self.accept()
    
    def _save_changes(self) -> bool:
        """Collect and validate data from all panels, then save."""
        # Validate General panel
        is_valid, error_msg = self.general_panel_widget.validate()
        if not is_valid:
            QMessageBox.warning(self, "Validation Error", error_msg)
            return False
        
        # Validate Relationships panel
        is_valid, error_msg = self.relationships_panel_widget.validate()
        if not is_valid:
            QMessageBox.warning(self, "Validation Error", error_msg)
            self.panel_list.setCurrentRow(1)
            return False
        
        # Get data from panels
        person_data = self.general_panel_widget.get_person_data()
        relationship_data = self.relationships_panel_widget.get_relationship_data()
        
        # Merge relationship data into person data
        person_data.update(relationship_data)
        
        # Create edited person
        from dataclasses import replace
        self.edited_person = replace(self.person, **person_data)
        
        # Save person to database
        from database.person_repository import PersonRepository
        person_repo = PersonRepository(self.db_manager)
        person_repo.update(self.edited_person)
        
        # Save marriages
        self.relationships_panel_widget.save_marriages()
        
        # Update the person object with saved data
        self.person = self.edited_person
        
        return True

    def reject(self) -> None:
        """Handle Cancel button - warn if unsaved changes."""
        if self.has_unsaved_changes:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Warning)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Discard them?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel
            )
            
            result = msg.exec()
            if result == QMessageBox.StandardButton.Discard:
                super().reject()  # Close without saving
            # Otherwise, do nothing (stay open)
        else:
            super().reject()  # No changes, just close
    
    def mark_dirty(self) -> None:
        """Mark the dialog as having unsaved changes.
        
        Call this from panels when user edits anything.
        """
        self.has_unsaved_changes = True
    
    def get_edited_person(self) -> Person | None:
        """Get the edited person data after dialog is accepted."""
        return self.edited_person

>> ðŸ“‹ dialogs\edit_person_panels\__init__.py (2 code lines)
from .general_panel import GeneralPanel

__all__ = ['GeneralPanel', ]

>> ðŸ“‹ dialogs\edit_person_panels\event_panel.py (0 code lines)


>> âœ… dialogs\edit_person_panels\general_panel.py (78 code lines)
"""General information panel for Edit Person dialog."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QLineEdit,
    QComboBox, QTextEdit, QLabel, QScrollArea, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

from models.person import Person
from widgets.date_picker import DatePicker


class GeneralPanel(QWidget):
    """Panel for editing general person information."""
    
    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create all form fields."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container = QWidget()
        form = QFormLayout(container)
        
        # Name fields
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        self.first_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("First Name: *", self.first_name_input)
        
        self.middle_name_input = QLineEdit()
        self.middle_name_input.setPlaceholderText("Optional")
        self.middle_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Middle Name:", self.middle_name_input)
        
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        self.last_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Last Name: *", self.last_name_input)
        
        self.maiden_name_input = QLineEdit()
        self.maiden_name_input.setPlaceholderText("Optional")
        self.maiden_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Maiden Name:", self.maiden_name_input)
        
        self.nickname_input = QLineEdit()
        self.nickname_input.setPlaceholderText("Optional")
        self.nickname_input.textChanged.connect(self._on_field_changed)
        form.addRow("Nickname:", self.nickname_input)
        
        # Gender
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        self.gender_input.currentIndexChanged.connect(self._on_field_changed)
        form.addRow("Gender:", self.gender_input)
        
        # Birth Date
        self.birth_date_picker = DatePicker()
        self.birth_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow("Birth Date:", self.birth_date_picker)
        
        # Death Date with checkbox BELOW
        self.death_date_label = QLabel("Death Date:")
        self.death_date_picker = DatePicker()
        self.death_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.death_date_label, self.death_date_picker)
        
        self.died_check = QCheckBox("Died?")
        self.died_check.setChecked(False)
        self.died_check.stateChanged.connect(self._on_died_toggled)
        self.died_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.died_check)
        
        # Arrival Date with checkbox BELOW
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_picker = DatePicker()
        self.arrival_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
        
        self.immigrant_check = QCheckBox("Immigrant?")
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        self.immigrant_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.immigrant_check)
        
        # Moved Out Date with checkbox BELOW
        self.moved_out_date_label = QLabel("Moved Out Date:")
        self.moved_out_date_picker = DatePicker()
        self.moved_out_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.moved_out_date_label, self.moved_out_date_picker)
        
        self.moved_out_check = QCheckBox("Moved Out?")
        self.moved_out_check.setChecked(False)
        self.moved_out_check.stateChanged.connect(self._on_moved_out_toggled)
        self.moved_out_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.moved_out_check)
        
        # Game-specific fields
        self.dynasty_id_input = QLineEdit()
        self.dynasty_id_input.setText("1")
        self.dynasty_id_input.textChanged.connect(self._on_field_changed)
        form.addRow("Dynasty ID:", self.dynasty_id_input)
        
        self.is_founder_check = QCheckBox("Is Dynasty Founder")
        self.is_founder_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.is_founder_check)
        
        self.education_input = QComboBox()
        self.education_input.addItems([
            "0 - Uneducated", "1 - Basic", "2 - Elementary",
            "3 - Advanced", "4 - Expert", "5 - Master"
        ])
        self.education_input.currentIndexChanged.connect(self._on_field_changed)
        form.addRow("Education:", self.education_input)
        
        # Notes
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this person...")
        self.notes_input.setMaximumHeight(120)
        self.notes_input.textChanged.connect(self._on_field_changed)
        form.addRow("Notes:", self.notes_input)
        
        scroll.setWidget(container)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(scroll)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()

    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_visibility()

    def _update_immigrant_visibility(self) -> None:
        """Show/hide arrival date based on checkbox."""
        is_immigrant = self.immigrant_check.isChecked()
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)

    def _on_died_toggled(self) -> None:
        """Handle died checkbox toggle."""
        self._update_died_visibility()

    def _update_died_visibility(self) -> None:
        """Show/hide death date based on checkbox."""
        has_died = self.died_check.isChecked()
        self.death_date_label.setVisible(has_died)
        self.death_date_picker.setVisible(has_died)

    def _on_moved_out_toggled(self) -> None:
        """Handle moved out checkbox toggle."""
        self._update_moved_out_visibility()
    
    def _update_moved_out_visibility(self) -> None:
        """Show/hide moved out date based on checkbox."""
        is_moved_out = self.moved_out_check.isChecked()
        self.moved_out_date_label.setVisible(is_moved_out)
        self.moved_out_date_picker.setVisible(is_moved_out)
    
    def _on_field_changed(self) -> None:
        """Mark dialog as dirty when any field changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    def load_person(self, person: Person) -> None:
        """Load person data into form fields."""
        blockers = [
            QSignalBlocker(self.first_name_input),
            QSignalBlocker(self.middle_name_input),
            QSignalBlocker(self.last_name_input),
            QSignalBlocker(self.maiden_name_input),
            QSignalBlocker(self.nickname_input),
            QSignalBlocker(self.gender_input),
            QSignalBlocker(self.birth_date_picker),
            QSignalBlocker(self.died_check),
            QSignalBlocker(self.death_date_picker),
            QSignalBlocker(self.immigrant_check),
            QSignalBlocker(self.arrival_date_picker),
            QSignalBlocker(self.moved_out_check),
            QSignalBlocker(self.moved_out_date_picker),
            QSignalBlocker(self.dynasty_id_input),
            QSignalBlocker(self.is_founder_check),
            QSignalBlocker(self.education_input),
            QSignalBlocker(self.notes_input),
        ]
        
        # Names
        self.first_name_input.setText(person.first_name or "")
        self.middle_name_input.setText(person.middle_name or "")
        self.last_name_input.setText(person.last_name or "")
        self.maiden_name_input.setText(person.maiden_name or "")
        self.nickname_input.setText(person.nickname or "")
        
        # Gender
        if person.gender:
            index = self.gender_input.findText(person.gender)
            if index >= 0:
                self.gender_input.setCurrentIndex(index)
        
        # Dates
        if person.birth_year:
            self.birth_date_picker.set_date(person.birth_year, person.birth_month)
        
        if person.death_year:
            self.died_check.setChecked(True)
            self.death_date_picker.set_date(person.death_year, person.death_month)
        else:
            self.died_check.setChecked(False)
        
        if person.arrival_year:
            self.immigrant_check.setChecked(True)
            self.arrival_date_picker.set_date(person.arrival_year, person.arrival_month)
        else:
            self.immigrant_check.setChecked(False)
        
        if person.moved_out_year:
            self.moved_out_check.setChecked(True)
            self.moved_out_date_picker.set_date(person.moved_out_year, person.moved_out_month)
        else:
            self.moved_out_check.setChecked(False)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()
        
        # Game fields
        self.dynasty_id_input.setText(str(person.dynasty_id))
        self.is_founder_check.setChecked(person.is_founder)
        self.education_input.setCurrentIndex(person.education)
        
        # Notes
        self.notes_input.setPlainText(person.notes or "")
    
    def get_person_data(self) -> dict:
        """Extract form data as dictionary."""
        birth_year, birth_month = self.birth_date_picker.get_date()
        
        if self.died_check.isChecked():
            death_year, death_month = self.death_date_picker.get_date()
        else:
            death_year, death_month = None, None
        
        if self.immigrant_check.isChecked():
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        else:
            arrival_year, arrival_month = None, None
        
        if self.moved_out_check.isChecked():
            moved_out_year, moved_out_month = self.moved_out_date_picker.get_date()
        else:
            moved_out_year, moved_out_month = None, None
        
        education_text = self.education_input.currentText()
        education_level = int(education_text.split(" ")[0])
        
        return {
            'first_name': self.first_name_input.text().strip(),
            'middle_name': self.middle_name_input.text().strip(),
            'last_name': self.last_name_input.text().strip(),
            'maiden_name': self.maiden_name_input.text().strip(),
            'nickname': self.nickname_input.text().strip(),
            'gender': self.gender_input.currentText(),
            'birth_year': birth_year,
            'birth_month': birth_month,
            'death_year': death_year,
            'death_month': death_month,
            'arrival_year': arrival_year,
            'arrival_month': arrival_month,
            'moved_out_year': moved_out_year,
            'moved_out_month': moved_out_month,
            'dynasty_id': int(self.dynasty_id_input.text() or "1"),
            'is_founder': self.is_founder_check.isChecked(),
            'education': education_level,
            'notes': self.notes_input.toPlainText().strip()
        }

    def validate(self) -> tuple[bool, str]:
        """Validate form data."""
        if not self.first_name_input.text().strip():
            return (False, "First name is required.")
        
        if not self.last_name_input.text().strip():
            return (False, "Last name is required.")
        
        try:
            dynasty_id = int(self.dynasty_id_input.text())
            if dynasty_id < 1:
                return (False, "Dynasty ID must be a positive number.")
        except ValueError:
            return (False, "Dynasty ID must be a valid number.")
        
        return (True, "")

>> âœ… dialogs\edit_person_panels\relationships_panel.py (239 code lines)
"""Relationships panel for Edit Person dialog."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, 
    QLabel, QScrollArea, QCheckBox,
    QGroupBox, QPushButton, QHBoxLayout, 
    QFrame, QMessageBox, QComboBox
)
from PySide6.QtCore import QSignalBlocker

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from database.marriage_repository import MarriageRepository
from models.person import Person
from models.marriage import Marriage
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker
from dialogs.end_marriage_dialog import EndMarriageDialog


class RelationshipsPanel(QWidget):
    """Panel for editing person relationships."""
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        self.marriage_repo = MarriageRepository(db_manager)
        self.current_person: Person | None = None
        
        self.marriage_widgets: list[tuple[Marriage, QFrame]] = []
        self.new_marriages: list[Marriage] = []
        self.deleted_marriage_ids: list[int] = []
        self.modified_marriages: dict[int, Marriage] = {}
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create all relationship sections."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container = QWidget()
        layout = QVBoxLayout(container)
        
        layout.addWidget(self._create_parents_section())
        layout.addWidget(self._create_marriages_section())
        layout.addWidget(self._create_children_section())
        layout.addStretch()
        
        scroll.setWidget(container)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll)
    
    def _create_parents_section(self) -> QGroupBox:
        """Create parents section with father/mother selectors."""
        group = QGroupBox("Parents")
        layout = QVBoxLayout(group)
        form = QFormLayout()
        
        # Father selector
        self.father_selector = PersonSelector(self.db_manager)
        self.father_selector.set_filter(gender="Male")
        self.father_selector.personSelected.connect(self._on_field_changed)
        self.father_selector.selectionCleared.connect(self._on_field_changed)
        self.father_selector.personSelected.connect(lambda: self._load_siblings())
        
        father_row = QHBoxLayout()
        father_row.addWidget(self.father_selector)
        self.father_jump_btn = QPushButton("View Person")
        self.father_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.father_selector.get_person_id())
        )
        father_row.addWidget(self.father_jump_btn)
        form.addRow("Father:", father_row)
        
        # Mother selector
        self.mother_selector = PersonSelector(self.db_manager)
        self.mother_selector.set_filter(gender="Female")
        self.mother_selector.personSelected.connect(self._on_field_changed)
        self.mother_selector.selectionCleared.connect(self._on_field_changed)
        self.mother_selector.personSelected.connect(lambda: self._load_siblings())
        
        mother_row = QHBoxLayout()
        mother_row.addWidget(self.mother_selector)
        self.mother_jump_btn = QPushButton("View Person")
        self.mother_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.mother_selector.get_person_id())
        )
        mother_row.addWidget(self.mother_jump_btn)
        form.addRow("Mother:", mother_row)
        
        layout.addLayout(form)
        
        layout.addWidget(QLabel("<b>Siblings:</b>"))
        self.siblings_container = QVBoxLayout()
        layout.addLayout(self.siblings_container)
        
        return group
    
    def _create_marriages_section(self) -> QGroupBox:
        """Create marriages section with inline editing."""
        group = QGroupBox("Marriages")
        layout = QVBoxLayout(group)
        
        self.marriages_container = QVBoxLayout()
        layout.addLayout(self.marriages_container)
        
        add_btn = QPushButton("+ Add New Marriage")
        add_btn.clicked.connect(self._add_marriage)
        layout.addWidget(add_btn)
        
        return group
    
    def _create_children_section(self) -> QGroupBox:
        """Create children section."""
        group = QGroupBox("Children")
        layout = QVBoxLayout(group)
        
        self.children_container = QVBoxLayout()
        layout.addLayout(self.children_container)
        
        add_btn = QPushButton("+ Add Child")
        add_btn.clicked.connect(self._add_child)
        layout.addWidget(add_btn)
        
        return group
    
    def _create_marriage_widget(self, marriage: Marriage) -> QFrame:
        """Create inline editable widget for a marriage."""
        frame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        frame.setFrameShadow(QFrame.Shadow.Raised)
        main_layout = QVBoxLayout(frame)
        
        # Status header
        header_layout = QHBoxLayout()
        status_indicator = QLabel("âœ“ Active" if marriage.is_active else "â—‹ Ended")
        status_indicator.setStyleSheet(
            f"font-weight: bold; color: {'green' if marriage.is_active else 'gray'}"
        )
        header_layout.addWidget(status_indicator)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)
        
        # Spouse row
        spouse_layout = QHBoxLayout()
        spouse_layout.addWidget(QLabel("Spouse:"))
        
        spouse_selector = PersonSelector(self.db_manager)
        with QSignalBlocker(spouse_selector):
            if self.current_person and self.current_person.id:
                spouse_id = self.marriage_repo.get_spouse_id(marriage, self.current_person.id)
            else:
                spouse_id = None
            
            if spouse_id:
                spouse_selector.set_person(spouse_id)
        
        spouse_selector.personSelected.connect(self._on_field_changed)
        spouse_layout.addWidget(spouse_selector)
        
        spouse_jump_btn = QPushButton("View Person")
        spouse_jump_btn.setEnabled(spouse_id is not None)
        spouse_jump_btn.clicked.connect(lambda: self._jump_to_person(spouse_selector.get_person_id()))
        spouse_selector.personSelected.connect(lambda: spouse_jump_btn.setEnabled(True))
        spouse_selector.selectionCleared.connect(lambda: spouse_jump_btn.setEnabled(False))
        spouse_layout.addWidget(spouse_jump_btn)
        
        main_layout.addLayout(spouse_layout)
        
        # Date Unknown checkbox (stays in place)
        date_unknown_layout = QHBoxLayout()
        date_unknown_layout.addSpacing(60)  # Indent to align with fields above
        
        date_unknown_check = QCheckBox("Date Unknown")
        date_unknown_check.setChecked(marriage.marriage_year is None)
        date_unknown_layout.addWidget(date_unknown_check)
        date_unknown_layout.addStretch()
        
        main_layout.addLayout(date_unknown_layout)
        
        # Marriage date row (appears/disappears below)
        marriage_date_layout = QHBoxLayout()
        marriage_date_label = QLabel("Married:")
        marriage_date_layout.addWidget(marriage_date_label)
        
        marriage_date = DatePicker()
        with QSignalBlocker(marriage_date):
            if marriage.marriage_year:
                marriage_date.set_date(marriage.marriage_year, marriage.marriage_month or 1)
            else:
                marriage_date.set_date(1721, 1)
        
        marriage_date.unknown_check.setVisible(False)
        marriage_date.dateChanged.connect(self._on_field_changed)
        marriage_date_layout.addWidget(marriage_date)
        marriage_date_layout.addStretch()
        
        main_layout.addLayout(marriage_date_layout)
        
        # Initially hide/show based on whether date is known
        date_known = marriage.marriage_year is not None
        marriage_date_label.setVisible(date_known)
        marriage_date.setVisible(date_known)
        
        # Connect checkbox to toggle visibility
        def toggle_date_visibility():
            date_is_known = not date_unknown_check.isChecked()
            marriage_date_label.setVisible(date_is_known)
            marriage_date.setVisible(date_is_known)
            self._on_field_changed()
        
        date_unknown_check.stateChanged.connect(toggle_date_visibility)
        
        # End date and reason (if ended)
        if not marriage.is_active:
            end_date_layout = QHBoxLayout()
            end_date_layout.addWidget(QLabel("Ended:"))
            
            end_date = DatePicker()
            with QSignalBlocker(end_date):
                if marriage.dissolution_year:
                    end_date.set_date(marriage.dissolution_year, marriage.dissolution_month)
            
            end_date.dateChanged.connect(self._on_field_changed)
            end_date_layout.addWidget(end_date)
            end_date_layout.addStretch()
            main_layout.addLayout(end_date_layout)
            
            reason_layout = QHBoxLayout()
            reason_layout.addWidget(QLabel("Reason:"))
            
            reason_combo = QComboBox()
            with QSignalBlocker(reason_combo):
                reason_combo.addItems(["Death", "Divorce", "Annulment", "Other", "Unknown"])
                if marriage.dissolution_reason:
                    index = reason_combo.findText(marriage.dissolution_reason)
                    if index >= 0:
                        reason_combo.setCurrentIndex(index)
            
            reason_combo.currentIndexChanged.connect(self._on_field_changed)
            reason_layout.addWidget(reason_combo)
            reason_layout.addStretch()
            main_layout.addLayout(reason_layout)
        
        # Action buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        if marriage.is_active:
            end_btn = QPushButton("End Marriage")
            end_btn.clicked.connect(lambda: self._end_marriage(marriage))
            button_layout.addWidget(end_btn)
        else:
            reactivate_btn = QPushButton("Reactivate")
            reactivate_btn.clicked.connect(lambda: self._reactivate_marriage(marriage))
            button_layout.addWidget(reactivate_btn)
        
        delete_btn = QPushButton("Delete")
        delete_btn.clicked.connect(lambda: self._delete_marriage(marriage))
        button_layout.addWidget(delete_btn)
        
        main_layout.addLayout(button_layout)
        
        # Store widget references
        frame.spouse_selector = spouse_selector  # type: ignore[attr-defined]
        frame.date_unknown_check = date_unknown_check  # type: ignore[attr-defined]
        frame.marriage_date = marriage_date  # type: ignore[attr-defined]
        if not marriage.is_active:
            frame.end_date = end_date  # type: ignore[attr-defined]
            frame.reason_combo = reason_combo  # type: ignore[attr-defined]
        
        return frame
    
    def _create_person_widget(self, person: Person, show_remove: bool = False) -> QFrame:
        """Create widget displaying a person with jump button."""
        frame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        layout = QHBoxLayout(frame)
        
        birth_info = f"b. {person.birth_year}" if person.birth_year else "birth unknown"
        info_label = QLabel(f"{person.display_name} ({birth_info})")
        layout.addWidget(info_label)
        layout.addStretch()
        
        jump_btn = QPushButton("View Person")
        jump_btn.clicked.connect(lambda: self._jump_to_person(person.id))
        layout.addWidget(jump_btn)
        
        if show_remove:
            remove_btn = QPushButton("Remove")
            remove_btn.clicked.connect(lambda: self._remove_child(person))
            layout.addWidget(remove_btn)
        
        return frame
    
    def _on_field_changed(self) -> None:
        """Mark dialog as dirty when any field changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    def _jump_to_person(self, person_id: int | None) -> None:
        """Jump to editing a different person."""
        if person_id is None:
            return
        
        dialog = self._find_parent_dialog()
        if not dialog:
            return
        
        person = self.person_repo.get_by_id(person_id)
        if not person:
            return
        
        if dialog.has_unsaved_changes:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Question)
            msg.setWindowTitle("Save Changes?")
            msg.setText("Save changes before jumping to another person?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save |
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel
            )
            
            result = msg.exec()
            if result == QMessageBox.StandardButton.Cancel:
                return
            elif result == QMessageBox.StandardButton.Save:
                if not dialog._save_changes():
                    return
        
        dialog.person = person
        dialog.setWindowTitle(f"Edit Person: {person.display_name}")
        dialog._load_data()
        dialog.has_unsaved_changes = False
        dialog.panel_list.setCurrentRow(1)
    
    def _add_marriage(self) -> None:
        """Add a new marriage using dialog."""
        if not self.current_person or not self.current_person.id:
            return
        
        active_marriages = [m for m, _ in self.marriage_widgets if m.is_active]
        
        # Validate active marriages have spouses
        for marriage, widget in self.marriage_widgets:
            if marriage.is_active:
                spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                if not spouse_selector.get_person_id():
                    QMessageBox.warning(
                        self,
                        "Incomplete Marriage",
                        "Please select a spouse for the current marriage before adding a new one."
                    )
                    return
        
        if active_marriages:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Question)
            msg.setWindowTitle("End Current Marriage?")
            msg.setText("This person has an active marriage. End it before creating a new one?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if msg.exec() == QMessageBox.StandardButton.Yes:
                marriage = active_marriages[0]
                from dialogs.end_marriage_dialog import EndMarriageDialog
                end_dialog = EndMarriageDialog(marriage, self)
                
                if end_dialog.exec():
                    year, month, reason = end_dialog.get_dissolution_data()
                    marriage.dissolution_year = year
                    marriage.dissolution_month = month
                    marriage.dissolution_reason = reason
                    
                    if marriage.id:
                        self.modified_marriages[marriage.id] = marriage
                    
                    self._on_field_changed()
                else:
                    return
        
        # Open create marriage dialog
        from dialogs.create_marriage_dialog import CreateMarriageDialog
        dialog = CreateMarriageDialog(self.db_manager, self.current_person, self)
        
        if dialog.exec():
            spouse_id, year, month = dialog.get_marriage_data()
            
            # Create new marriage with data from dialog
            new_marriage = Marriage(
                spouse1_id=self.current_person.id,
                spouse2_id=spouse_id,
                marriage_year=year,
                marriage_month=month
            )
            
            self.new_marriages.append(new_marriage)
            self._load_marriages()
            self._on_field_changed()

    def _end_marriage(self, marriage: Marriage) -> None:
        """End a marriage with dialog."""
        dialog = EndMarriageDialog(marriage, self)
        
        if dialog.exec():
            year, month, reason = dialog.get_dissolution_data()
            
            # Validate end date after marriage date
            if marriage.marriage_year:
                if year and year < marriage.marriage_year:
                    QMessageBox.warning(self, "Invalid Date", "Marriage cannot end before it started.")
                    return
                elif year == marriage.marriage_year and marriage.marriage_month and month:
                    if month < marriage.marriage_month:
                        QMessageBox.warning(self, "Invalid Date", "Marriage cannot end before it started.")
                        return
            
            marriage.dissolution_year = year
            marriage.dissolution_month = month
            marriage.dissolution_reason = reason
            
            if marriage.id:
                self.modified_marriages[marriage.id] = marriage
            
            self._load_marriages()
            self._on_field_changed()
    
    def _reactivate_marriage(self, marriage: Marriage) -> None:
        """Reactivate an ended marriage."""
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Question)
        msg.setWindowTitle("Reactivate Marriage?")
        msg.setText("Remove the end date and reactivate this marriage? This will remove any empty active marriages.")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            # Delete empty active marriages
            for m, widget in list(self.marriage_widgets):
                if m != marriage and m.is_active:
                    spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                    spouse_id = spouse_selector.get_person_id()
                    
                    if not spouse_id:
                        if m.id:
                            self.deleted_marriage_ids.append(m.id)
                        if m in self.new_marriages:
                            self.new_marriages.remove(m)
            
            marriage.dissolution_year = None
            marriage.dissolution_month = None
            marriage.dissolution_day = None
            marriage.dissolution_reason = ""
            
            if marriage.id:
                self.modified_marriages[marriage.id] = marriage
            
            self._load_marriages()
            self._on_field_changed()
    
    def _delete_marriage(self, marriage: Marriage) -> None:
        """Delete a marriage after confirmation."""
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Delete Marriage")
        msg.setText("Are you sure you want to delete this marriage?")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            if marriage.id:
                self.deleted_marriage_ids.append(marriage.id)
            if marriage in self.new_marriages:
                self.new_marriages.remove(marriage)
            
            self.marriage_widgets = [(m, w) for m, w in self.marriage_widgets if m != marriage]
            self._load_marriages()
            self._on_field_changed()
    
    def _add_child(self) -> None:
        """Open dialog to create a new child."""
        if not self.current_person or not self.current_person.id:
            return
        
        # Find oldest active marriage spouse
        active_marriages = self.marriage_repo.get_active_marriages(self.current_person.id)
        parent2_id = None
        
        if active_marriages:
            # Sort by marriage date (oldest first)
            active_marriages.sort(key=lambda m: (
                (9999, 12) if m.marriage_year is None else (m.marriage_year, m.marriage_month or 0)
            ))
            
            oldest_marriage = active_marriages[0]
            parent2_id = self.marriage_repo.get_spouse_id(oldest_marriage, self.current_person.id)
        
        # Open create child dialog
        from dialogs.create_child_dialog import CreateChildDialog
        dialog = CreateChildDialog(self.db_manager, self.current_person, parent2_id, self)
        
        if dialog.exec():
            created_person = dialog.get_created_person()
            if created_person:
                # Reload children to show new child
                self._load_children()
                self._on_field_changed()
        
    def load_person(self, person: Person) -> None:
        """Load person relationship data."""
        self.current_person = person
        
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
        
        blockers = [
            QSignalBlocker(self.father_selector),
            QSignalBlocker(self.mother_selector),
        ]
        
        if person.father_id:
            self.father_selector.set_person(person.father_id)
            self.father_jump_btn.setEnabled(True)
        else:
            self.father_selector.clear()
            self.father_jump_btn.setEnabled(False)
        
        if person.mother_id:
            self.mother_selector.set_person(person.mother_id)
            self.mother_jump_btn.setEnabled(True)
        else:
            self.mother_selector.clear()
            self.mother_jump_btn.setEnabled(False)
        
        self._load_siblings()
        self._load_marriages()
        self._load_children()
    
    def _load_siblings(self) -> None:
        """Load and display siblings."""
        while self.siblings_container.count():
            item = self.siblings_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        if not self.current_person:
            return
        
        siblings = []
        
        father_id = self.father_selector.get_person_id()
        if father_id:
            father_children = self.person_repo.get_children(father_id)
            siblings.extend([p for p in father_children if p.id != self.current_person.id])
        
        mother_id = self.mother_selector.get_person_id()
        if mother_id:
            mother_children = self.person_repo.get_children(mother_id)
            for child in mother_children:
                if child.id != self.current_person.id and child not in siblings:
                    siblings.append(child)
        
        if siblings:
            for sibling in siblings:
                sibling_widget = self._create_person_widget(sibling)
                self.siblings_container.addWidget(sibling_widget)
        else:
            placeholder = QLabel("No siblings found")
            placeholder.setStyleSheet("color: gray; font-style: italic;")
            self.siblings_container.addWidget(placeholder)
    
    def _load_marriages(self) -> None:
        """Load and display marriages."""
        while self.marriages_container.count():
            item = self.marriages_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        self.marriage_widgets.clear()
        
        if not self.current_person or not self.current_person.id:
            placeholder = QLabel("No marriages recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.marriages_container.addWidget(placeholder)
            return
        
        marriages = self.marriage_repo.get_by_person(self.current_person.id)
        marriages = [m for m in marriages if m.id not in self.deleted_marriage_ids]
        
        # Apply modifications
        for i, m in enumerate(marriages):
            if m.id and m.id in self.modified_marriages:
                marriages[i] = self.modified_marriages[m.id]
        
        all_marriages = marriages + self.new_marriages
        
        # Sort by date (oldest first)
        all_marriages.sort(key=lambda m: (
            (9999, 12) if m.marriage_year is None else (m.marriage_year, m.marriage_month or 0)
        ))
        
        if all_marriages:
            for marriage in all_marriages:
                widget = self._create_marriage_widget(marriage)
                self.marriages_container.addWidget(widget)
                self.marriage_widgets.append((marriage, widget))
        else:
            placeholder = QLabel("No marriages recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.marriages_container.addWidget(placeholder)
    
    def _load_children(self) -> None:
        """Load and display children."""
        while self.children_container.count():
            item = self.children_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        if not self.current_person or not self.current_person.id:
            return
        
        children = self.person_repo.get_children(self.current_person.id)
        
        if children:
            for child in children:
                child_widget = self._create_person_widget(child, show_remove=True)
                self.children_container.addWidget(child_widget)
        else:
            placeholder = QLabel("No children recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.children_container.addWidget(placeholder)

    def _remove_child(self, child: Person) -> None:
        """Remove parent-child relationship."""
        if not self.current_person:
            return
        
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Remove Child")
        msg.setText(f"Remove {child.display_name} as a child of {self.current_person.display_name}?")
        msg.setInformativeText("This will clear the parent relationship but not delete the person.")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            # Determine which parent to clear
            if child.father_id == self.current_person.id:
                child.father_id = None
            if child.mother_id == self.current_person.id:
                child.mother_id = None
            
            # Update in database
            self.person_repo.update(child)
            
            # Reload children
            self._load_children()
            self._on_field_changed()

    def get_relationship_data(self) -> dict:
        """Extract relationship data."""
        return {
            'father_id': self.father_selector.get_person_id(),
            'mother_id': self.mother_selector.get_person_id(),
        }
    
    def save_marriages(self) -> None:
        """Save all marriage changes to database."""
        # Delete marriages
        for marriage_id in self.deleted_marriage_ids:
            self.marriage_repo.delete(marriage_id)
        
        # Insert new marriages
        for marriage in self.new_marriages:
            for m, widget in self.marriage_widgets:
                if m == marriage:
                    spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                    spouse_id = spouse_selector.get_person_id()
                    if spouse_id:
                        marriage.spouse2_id = spouse_id
                    
                    date_unknown_check = widget.date_unknown_check  # type: ignore[attr-defined]
                    if date_unknown_check.isChecked():
                        marriage.marriage_year = None
                        marriage.marriage_month = None
                    else:
                        marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
                        year, month = marriage_date_picker.get_date()
                        marriage.marriage_year = year
                        marriage.marriage_month = month
                    
                    break
            
            self.marriage_repo.insert(marriage)
        
        # Update ALL existing marriages (not just ones in modified_marriages)
        for marriage, widget in self.marriage_widgets:
            # Skip new marriages (already inserted above)
            if marriage in self.new_marriages:
                continue
            
            # Update existing marriage
            if marriage.id:
                spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                spouse_id = spouse_selector.get_person_id()
                
                if self.current_person and self.current_person.id:
                    if marriage.spouse1_id == self.current_person.id:
                        marriage.spouse2_id = spouse_id
                    else:
                        marriage.spouse1_id = spouse_id
                
                date_unknown_check = widget.date_unknown_check  # type: ignore[attr-defined]
                if date_unknown_check.isChecked():
                    marriage.marriage_year = None
                    marriage.marriage_month = None
                else:
                    marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
                    year, month = marriage_date_picker.get_date()
                    marriage.marriage_year = year
                    marriage.marriage_month = month
                
                self.marriage_repo.update(marriage)
        
        # Clear tracking
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
    
    def validate(self) -> tuple[bool, str]:
        """Validate relationship data."""
        if not self.current_person:
            return (True, "")
        
        if self.father_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own father.")
        if self.mother_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own mother.")
        
        for marriage, widget in self.marriage_widgets:
            marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
            marriage_year, marriage_month = marriage_date_picker.get_date()
            
            if not marriage.is_active:
                if marriage.dissolution_year and marriage_year:
                    if marriage.dissolution_year < marriage_year:
                        return (False, "Marriage end date cannot be before start date.")
                    elif marriage.dissolution_year == marriage_year and marriage.dissolution_month and marriage_month:
                        if marriage.dissolution_month < marriage_month:
                            return (False, "Marriage end date cannot be before start date.")
        
        return (True, "")

>> âœ… dialogs\end_marriage_dialog.py (35 code lines)
"""Dialog for ending a marriage."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QComboBox,
    QDialogButtonBox, QWidget, QMessageBox
)

from widgets.date_picker import DatePicker
from models.marriage import Marriage


class EndMarriageDialog(QDialog):
    """Dialog for ending a marriage with date and reason."""
    
    def __init__(self, marriage: Marriage, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.marriage = marriage
        self.dissolution_year: int | None = None
        self.dissolution_month: int | None = None
        self.dissolution_reason: str = ""
        
        self.setWindowTitle("End Marriage")
        self.setMinimumWidth(400)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        form = QFormLayout()
        
        # End date
        self.end_date = DatePicker()
        
        # Set minimum date to marriage start date
        if self.marriage.marriage_year:
            self.end_date.set_min_date(self.marriage.marriage_year, self.marriage.marriage_month)
            self.end_date.set_date(self.marriage.marriage_year, self.marriage.marriage_month)
        else:
            self.end_date.set_date(1721, None)
        
        form.addRow("End Date:", self.end_date)
        
        # Reason
        self.reason_combo = QComboBox()
        self.reason_combo.addItems(["Death", "Divorce", "Annulment", "Other", "Unknown"])
        form.addRow("Reason:", self.reason_combo)
        
        layout.addLayout(form)
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        year, month = self.end_date.get_date()
        
        if not year:
            QMessageBox.warning(self, "Validation Error", "End date year is required.")
            return
        
        # Validate against marriage start date
        if self.marriage.marriage_year:
            if year < self.marriage.marriage_year:
                QMessageBox.warning(
                    self,
                    "Invalid Date",
                    "Marriage cannot end before it started."
                )
                return
            elif year == self.marriage.marriage_year and self.marriage.marriage_month and month:
                if month < self.marriage.marriage_month:
                    QMessageBox.warning(
                        self,
                        "Invalid Date",
                        "Marriage cannot end before it started."
                    )
                    return
        
        self.dissolution_year = year
        self.dissolution_month = month
        self.dissolution_reason = self.reason_combo.currentText()
        
        self.accept()
    
    def get_dissolution_data(self) -> tuple[int | None, int | None, str]:
        """Returns (year, month, reason)."""
        return (self.dissolution_year, self.dissolution_month, self.dissolution_reason)

>> ðŸ“‹ dialogs\import_csv_dialog.py (1 code lines)
"""Dialog for importing genealogy data from CSV files."""

from PySide6.QtWidgets import QDialog


class ImportCSVDialog(QDialog):
    """Dialog for CSV import configuration and mapping."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the CSV import dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add file picker for CSV selection
        # TODO: Add column mapping controls
        # TODO: Add preview table
        # TODO: Add import mode selection (replace/merge)
        # TODO: Add progress bar
        # TODO: Connect to CSVImporter utility
        pass


>> ðŸ“‹ dialogs\settings_dialog.py (1 code lines)
"""Dialog for application preferences and settings."""

from PySide6.QtWidgets import QDialog


class PreferencesDialog(QDialog):
    """Dialog for configuring application settings."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the preferences dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI with tabs
        # TODO: Add appearance settings (skin selection)
        # TODO: Add default view selection
        # TODO: Add date format preferences
        # TODO: Add auto-save settings
        # TODO: Load current settings from database
        # TODO: Save settings on OK button
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VIEWS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ views\__init__.py (0 code lines)


>> ðŸ“‹ views\data_table.py (0 code lines)


>> ðŸ“‹ views\dynasty_view.py (0 code lines)


>> ðŸ“‹ views\stats_view\charts.py (2 code lines)
"""Chart widgets for statistical visualizations."""

from PySide6.QtWidgets import QWidget


class Charts(QWidget):
    """Container for various statistical charts and graphs."""

    def __init__(self, database_connection) -> None:
        """Initialize the charts widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add population over time chart
        # TODO: Add birth/death rate chart
        # TODO: Add age distribution histogram
        # TODO: Add family size comparison chart
        # TODO: Use matplotlib or QtCharts for rendering
        # TODO: Add export chart buttons
        pass

    def refresh_charts(self) -> None:
        """Reload data and redraw all charts."""
        # TODO: Reload statistics from database
        # TODO: Regenerate all chart data
        # TODO: Redraw all visualizations
        pass


>> ðŸ“‹ views\stats_view\comparison_widget.py (2 code lines)
"""Widget for comparing statistics between families or people."""

from PySide6.QtWidgets import QWidget


class ComparisonWidget(QWidget):
    """Side-by-side comparison of selected entities."""

    def __init__(self, database_connection) -> None:
        """Initialize the comparison widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add selectors for entities to compare
        # TODO: Display side-by-side statistics
        # TODO: Show comparison charts
        # TODO: Highlight differences
        # TODO: Support comparing families, people, or generations
        pass

    def set_comparison(self, entity1_id: int, entity2_id: int, entity_type: str) -> None:
        """Set which entities to compare."""
        # TODO: Load data for both entities
        # TODO: Calculate comparison metrics
        # TODO: Update display
        pass


>> ðŸ“‹ views\stats_view\family_dashboard.py (2 code lines)
"""Dashboard widget showing dynasty statistics."""

from PySide6.QtWidgets import QWidget


class FamilyDashboard(QWidget):
    """Dashboard displaying key statistics about the dynasty."""

    def __init__(self, database_connection) -> None:
        """Initialize the family dashboard widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Calculate total people count
        # TODO: Calculate total marriages count
        # TODO: Calculate average lifespan
        # TODO: Calculate generation count
        # TODO: Display statistics in grid layout
        # TODO: Add Charts widget for visualizations
        # TODO: Add refresh button
        pass

    def refresh_stats(self) -> None:
        """Recalculate and update all statistics."""
        # TODO: Reload data from database
        # TODO: Recalculate all metrics
        # TODO: Update display widgets
        pass


>> ðŸ“‹ views\table_view\event_table.py (2 code lines)
"""Table view for listing all events in the database."""

from PySide6.QtWidgets import QTableWidget


class EventTable(QTableWidget):
    """Sortable, filterable table of all events."""

    def __init__(self, database_connection) -> None:
        """Initialize the event table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Person, Event Type, Date, Description)
        # TODO: Load all events from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show event details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all events
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\family_table.py (2 code lines)
"""Table view for listing all families in the database."""

from PySide6.QtWidgets import QTableWidget


class FamilyTable(QTableWidget):
    """Sortable, filterable table of all families."""

    def __init__(self, database_connection) -> None:
        """Initialize the family table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Family Name, Member Count, Start Year, etc.)
        # TODO: Load all families from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add double-click handler to show family details
        # TODO: Add right-click menu (edit/view members)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all families
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\marriage_table.py (2 code lines)
"""Table view for listing all marriages in the database."""

from PySide6.QtWidgets import QTableWidget


class MarriageTable(QTableWidget):
    """Sortable, filterable table of all marriages."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Husband, Wife, Start Date, End Date, Type)
        # TODO: Load all marriages from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all marriages
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\person_table.py (2 code lines)
"""Table view for listing all people in the database."""

from PySide6.QtWidgets import QTableWidget


class PersonTable(QTableWidget):
    """Sortable, filterable table of all people."""

    def __init__(self, database_connection) -> None:
        """Initialize the person table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Name, Gender, Birth, Death, etc.)
        # TODO: Load all people from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add row selection highlighting
        # TODO: Add double-click handler to show person details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all people
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\timeline_view\event_marker.py (1 code lines)
"""Visual marker for person events on timeline."""

from PySide6.QtWidgets import QGraphicsWidget


class EventMarker(QGraphicsWidget):
    """Small marker showing an event on a person's timeline bar."""

    def __init__(self, event_id: int) -> None:
        """Initialize the event marker widget."""
        super().__init__()
        self.event_id = event_id
        # TODO: Load event data from database
        # TODO: Draw small icon/shape at event year
        # TODO: Use different colors for event types
        # TODO: Add tooltip showing event details
        # TODO: Add click handler for event editing
        pass


>> ðŸ“‹ views\timeline_view\family_bar.py (1 code lines)
"""Horizontal bar representing a family's timespan."""

from PySide6.QtWidgets import QGraphicsWidget


class FamilyBar(QGraphicsWidget):
    """Visual bar showing family existence over time."""

    def __init__(self, family_id: int) -> None:
        """Initialize the family bar widget."""
        super().__init__()
        self.family_id = family_id
        # TODO: Calculate family start year (earliest member birth)
        # TODO: Calculate family end year (latest member death or current)
        # TODO: Draw horizontal bar spanning timespan
        # TODO: Add family name label
        # TODO: Add click handler to show family details
        # TODO: Add PersonBar widgets for each family member
        pass


>> ðŸ“‹ views\timeline_view\major_event_marker.py (1 code lines)
"""Visual marker for major historical events."""

from PySide6.QtWidgets import QGraphicsWidget


class MajorEventMarker(QGraphicsWidget):
    """Vertical line showing major events across all families."""

    def __init__(self, major_event_id: int) -> None:
        """Initialize the major event marker widget."""
        super().__init__()
        self.major_event_id = major_event_id
        # TODO: Load major event data from database
        # TODO: Draw vertical line at event year
        # TODO: Add event name label
        # TODO: Use distinctive color/style
        # TODO: Add tooltip with event description
        # TODO: Add click handler for editing
        pass


>> ðŸ“‹ views\timeline_view\person_bar.py (1 code lines)
"""Horizontal bar representing a person's lifespan."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBar(QGraphicsWidget):
    """Visual bar showing person's life from birth to death."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person bar widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load person data from database
        # TODO: Calculate x position from birth_year
        # TODO: Calculate width from birth_year to death_year (or current)
        # TODO: Draw horizontal bar with portrait thumbnail
        # TODO: Add name label
        # TODO: Add event markers along bar
        # TODO: Add click handler to show person details
        pass


>> ðŸ“‹ views\timeline_view\timeline_canvas.py (2 code lines)
"""Main canvas for the timeline visualization view."""

from PySide6.QtWidgets import QGraphicsView


class TimelineCanvas(QGraphicsView):
    """Scrollable canvas displaying families and events over time."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the timeline canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Add horizontal time axis (year scale)
        # TODO: Add vertical scrolling for families
        # TODO: Implement zoom for time scale
        # TODO: Add major event markers
        # TODO: Load all families and events from database
        pass

    def refresh_timeline(self) -> None:
        """Reload and redraw entire timeline from database."""
        # TODO: Clear scene
        # TODO: Reload all data
        # TODO: Recreate all visual elements
        pass


>> ðŸ“‹ views\timeline_view.py (0 code lines)


>> ðŸ“‹ views\tree_view\__init__.py (0 code lines)
"""Tree view components for family tree visualization."""


>> ðŸ“‹ views\tree_view\generation_band.py (2 code lines)
"""Horizontal band showing a generation level in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class GenerationBand(QGraphicsWidget):
    """Background band for highlighting a generation level."""

    def __init__(self, generation: int, y_position: float, height: float) -> None:
        """Initialize the generation band widget."""
        super().__init__()
        self.generation = generation
        self.y_position = y_position
        self.height = height
        # TODO: Draw horizontal background rectangle
        # TODO: Use alternating colors for visual separation
        # TODO: Add generation label on left side
        # TODO: Update position when tree layout changes
        pass

    def update_position(self, new_y: float, new_height: float) -> None:
        """Adjust band position and height."""
        # TODO: Update y_position and height
        # TODO: Redraw band
        pass


>> ðŸ“‹ views\tree_view\layout_engine.py (2 code lines)
"""Automatic layout engine for positioning people in the tree."""


class TreeLayoutEngine:
    """Calculate automatic positions for people in the family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the layout engine."""
        self.db = database_connection

    def calculate_positions(self) -> dict[int, tuple[float, float]]:
        """Calculate x,y positions for all people."""
        # TODO: Implement generational hierarchy algorithm
        # TODO: Group siblings together
        # TODO: Consider cohort positioning (move-in dates)
        # TODO: Return dict: person_id -> (x, y)
        pass


>> ðŸ“‹ views\tree_view\marriage_node.py (1 code lines)
"""Visual representation of a marriage in the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class MarriageNode(QGraphicsWidget):
    """Node connecting spouses in the family tree."""

    def __init__(self, marriage_id: int) -> None:
        """Initialize the marriage node widget."""
        super().__init__()
        self.marriage_id = marriage_id
        # TODO: Draw small connector shape (circle/diamond)
        # TODO: Display marriage date on hover
        # TODO: Connect to both spouse PersonBox widgets
        # TODO: Add click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete marriage)
        pass


>> ðŸ“‹ views\tree_view\person_box.py (1 code lines)
"""Person box widget for the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBox(QGraphicsWidget):
    """Visual representation of a person in the family tree."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person box widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Add portrait display
        # TODO: Add name label
        # TODO: Add dates label
        # TODO: Add gear icon button
        # TODO: Implement drag functionality
        # TODO: Implement click handlers
        pass


>> ðŸ“‹ views\tree_view\relationship_line.py (7 code lines)
"""Visual line connecting related people in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class RelationshipLine(QGraphicsWidget):
    """Line connecting parent to child or spouse to spouse."""

    def __init__(
        self,
        start_person_id: int,
        end_person_id: int,
        line_type: str,  # "parent", "marriage", "sibling"
    ) -> None:
        """Initialize the relationship line widget."""
        super().__init__()
        self.start_person_id = start_person_id
        self.end_person_id = end_person_id
        self.line_type = line_type
        # TODO: Draw line between two PersonBox widgets
        # TODO: Use different styles for different line types
        # TODO: Update position when PersonBox moves
        # TODO: Add hover highlighting
        pass

    def update_endpoints(self) -> None:
        """Recalculate line position based on connected boxes."""
        # TODO: Get current positions of connected PersonBox widgets
        # TODO: Redraw line with new coordinates
        pass


>> ðŸ“‹ views\tree_view\tree_canvas.py (1 code lines)
"""Main canvas for displaying the family tree."""

from PySide6.QtWidgets import QGraphicsView


class TreeCanvas(QGraphicsView):
    """Scrollable, zoomable canvas for displaying the family tree."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the tree canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Implement zoom functionality
        # TODO: Implement pan functionality
        # TODO: Add minimap (optional)
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WIDGETS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ widgets\__init__.py (0 code lines)


>> âœ… widgets\date_picker.py (72 code lines)
"""Custom date picker widget supporting flexible precision."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, 
    QSpinBox, QLabel, QCheckBox
)
from PySide6.QtCore import Signal


class MonthSpinBox(QSpinBox):
    """Custom spinbox that displays month names instead of just numbers."""
    
    yearAdjustNeeded = Signal(int)
    
    MONTH_NAMES = [
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ]
    
    def __init__(self, parent=None):
        """Initialize month spinbox."""
        super().__init__(parent)
        self.setWrapping(True)
    
    def textFromValue(self, value: int) -> str:
        """Convert internal value (1-12) to display text."""
        if 1 <= value <= 12:
            return f"{self.MONTH_NAMES[value - 1]} ({value})"
        return str(value)
    
    def valueFromText(self, text: str) -> int:
        """Convert display text back to internal value (1-12)."""
        if "(" in text and ")" in text:
            try:
                return int(text.split("(")[1].split(")")[0])
            except (ValueError, IndexError):
                pass
        
        text_lower = text.lower().strip()
        for i, month in enumerate(self.MONTH_NAMES, start=1):
            if month.lower().startswith(text_lower):
                return i
        
        try:
            return int(text)
        except ValueError:
            return 1
    
    def stepBy(self, steps: int) -> None:
        """Override step behavior to handle year adjustment on wrap."""
        old_value = self.value()
        super().stepBy(steps)
        new_value = self.value()
        
        if steps > 0 and old_value == 12 and new_value == 1:
            self.yearAdjustNeeded.emit(1)
        elif steps < 0 and old_value == 1 and new_value == 12:
            self.yearAdjustNeeded.emit(-1)


class DatePicker(QWidget):
    """Widget for entering dates with flexible precision (Year + Month)."""
    
    dateChanged = Signal()
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the date picker widget."""
        super().__init__(parent)
        
        self.min_year: int | None = None
        self.min_month: int | None = None
        
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # Year Section
        year_layout = QVBoxLayout()
        year_label = QLabel("Year", self)
        self.year_spin = QSpinBox(self)
        self.year_spin.setRange(1500, 2000)
        self.year_spin.setValue(1721)
        self.year_spin.valueChanged.connect(self._on_date_changed)
        
        year_layout.addWidget(year_label)
        year_layout.addWidget(self.year_spin)
        
        # Month Section
        month_layout = QVBoxLayout()
        month_label = QLabel("Month", self)
        
        month_controls = QHBoxLayout()
        self.month_spin = MonthSpinBox(self)
        self.month_spin.setRange(1, 12)
        self.month_spin.setValue(1)
        self.month_spin.valueChanged.connect(self._on_date_changed)
        self.month_spin.yearAdjustNeeded.connect(self._on_year_adjust)
        
        self.unknown_check = QCheckBox("Unknown", self)
        self.unknown_check.setChecked(False)
        self.unknown_check.stateChanged.connect(self._on_unknown_toggled)
        
        month_controls.addWidget(self.month_spin)
        month_controls.addWidget(self.unknown_check)
        
        month_layout.addWidget(month_label)
        month_layout.addLayout(month_controls)
        
        main_layout.addLayout(year_layout)
        main_layout.addLayout(month_layout)
        main_layout.addStretch()
        
        self._update_month_state()
    
    def set_min_date(self, min_year: int, min_month: int | None = None) -> None:
        """Set minimum allowable date."""
        self.min_year = min_year
        self.min_month = min_month if min_month else 1
        
        if self.min_year:
            self.year_spin.setMinimum(self.min_year)
    
    def _on_year_adjust(self, direction: int) -> None:
        """Adjust year when month wraps around."""
        current_year = self.year_spin.value()
        new_year = current_year + direction
        
        if self.year_spin.minimum() <= new_year <= self.year_spin.maximum():
            self.year_spin.setValue(new_year)
    
    def _on_unknown_toggled(self) -> None:
        """Handle unknown checkbox state change."""
        self._update_month_state()
        self._on_date_changed()
    
    def _update_month_state(self) -> None:
        """Enable or disable month spinbox based on unknown checkbox."""
        is_unknown = self.unknown_check.isChecked()
        self.month_spin.setEnabled(not is_unknown)
    
    def _on_date_changed(self) -> None:
        """Internal handler when date changes - emits signal."""
        self.dateChanged.emit()
    
    def get_date(self) -> tuple[int, int | None]:
        """Get the selected date as (year, month) tuple."""
        year = self.year_spin.value()
        
        if self.unknown_check.isChecked():
            return (year, None)
        else:
            return (year, self.month_spin.value())
    
    def set_date(self, year: int, month: int | str | None = None) -> None:
        """Set the date to specific values."""
        self.year_spin.setValue(year)
        
        if month is None or month == "":
            self.unknown_check.setChecked(True)
        else:
            self.unknown_check.setChecked(False)
            
            if isinstance(month, str):
                month_num = self._month_name_to_number(month)
                if month_num is not None:
                    self.month_spin.setValue(month_num)
                else:
                    self.unknown_check.setChecked(True)
            else:
                self.month_spin.setValue(int(month))
        
        self._update_month_state()

    def _month_name_to_number(self, month_name: str) -> int | None:
        """Convert month name to number (1-12)."""
        month_map = {
            'january': 1, 'february': 2, 'march': 3, 'april': 4,
            'may': 5, 'june': 6, 'july': 7, 'august': 8,
            'september': 9, 'october': 10, 'november': 11, 'december': 12
        }
        return month_map.get(month_name.lower())
    
    def clear(self) -> None:
        """Reset to default values (1721, Unknown)."""
        self.set_date(1721, None)

>> ðŸ“‹ widgets\extended_details_panel.py (2 code lines)
"""Panel widget for displaying detailed person information."""

from PySide6.QtWidgets import QWidget


class ExtendedDetailsPanel(QWidget):
    """Panel showing comprehensive person details and relationships."""

    def __init__(self, person_id: int | None = None) -> None:
        """Initialize the extended details panel."""
        super().__init__()
        self.person_id = person_id
        # TODO: Display full person information
        # TODO: Show all marriages with dates
        # TODO: Show all children with clickable links
        # TODO: Show all events in chronological order
        # TODO: Show portrait gallery
        # TODO: Add edit button for each section
        # TODO: Add relationship path calculator
        pass

    def set_person(self, person_id: int) -> None:
        """Update panel to show different person."""
        # TODO: Clear current display
        # TODO: Load new person data
        # TODO: Refresh all sections
        pass


>> âœ… widgets\person_selector.py (39 code lines)
"""Widget for selecting a person from the database with autocomplete."""

import unicodedata
from PySide6.QtWidgets import QWidget, QLineEdit, QVBoxLayout, QCompleter
from PySide6.QtCore import Signal, Qt, QStringListModel

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository


class PersonSelector(QWidget):
    """Autocomplete text field for selecting a person from the database."""
    
    # Signal emitted when a person is selected (emits person_id)
    personSelected = Signal(int)
    # Signal emitted when selection is cleared
    selectionCleared = Signal()
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize the person selector widget."""
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)

        self.gender_filter: str | None = None

        self._name_to_id: dict[str, int] = {}

        self._selected_person_id: int | None = None
        
        self._setup_ui()
        self._load_people()
    
    def _setup_ui(self) -> None:
        """Create the autocomplete text field."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Create text field
        self.text_field = QLineEdit(self)
        self.text_field.setPlaceholderText("Type to search for a person...")
        self.text_field.setClearButtonEnabled(True)
        
        # Create completer
        self.completer = QCompleter(self)
        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
        self.completer.setMaxVisibleItems(10)
        
        # Attach completer to text field
        self.text_field.setCompleter(self.completer)
        
        # Connect signals
        self.completer.activated.connect(self._on_person_selected)
        self.text_field.textChanged.connect(self._on_text_changed)
        
        layout.addWidget(self.text_field)
    
    def _load_people(self) -> None:
        """Load all people from database and populate completer."""
        if not self.db_manager.is_open:
            return

        all_people = self.person_repo.get_all()

        if hasattr(self, 'gender_filter') and self.gender_filter:
            all_people = [p for p in all_people if p.gender in (self.gender_filter, "Unknown")]

        self._name_to_id.clear()

        display_names = []
        
        for person in all_people:
            if person.id is None:
                continue
            
            display_name = self._format_person_display(person)
            display_names.append(display_name)
            self._name_to_id[display_name] = person.id

        display_names.sort()

        from PySide6.QtCore import QStringListModel
        model = QStringListModel(display_names)
        self.completer.setModel(model)
    
    def _format_person_display(self, person) -> str:
        """Format a person's info for display in the dropdown."""
        name = person.display_name

        if person.death_year:
            date_str = f"{person.birth_year or '?'}-{person.death_year}"
        elif person.birth_year:
            date_str = f"b. {person.birth_year}"
        else:
            date_str = "dates unknown"
        
        return f"{name} ({date_str})"
    
    def _normalize_text(self, text: str) -> str:
        """Normalize text for searching (handle special characters)."""
        text = text.lower()
        
        # Unicode normalization: Ã¡ â†’ a, Ã½ â†’ y, etc.
        normalized = unicodedata.normalize('NFD', text)
        ascii_text = ''.join(
            char for char in normalized 
            if unicodedata.category(char) != 'Mn'
        )
        
        return ascii_text
    
    def _on_person_selected(self, display_name: str) -> None:
        """Handle person selection from dropdown."""
        person_id = self._name_to_id.get(display_name)
        
        if person_id is not None:
            self._selected_person_id = person_id
            self.personSelected.emit(person_id)
    
    def _on_text_changed(self, text: str) -> None:
        """Handle text field changes."""
        if not text.strip():
            self._selected_person_id = None
            self.selectionCleared.emit()
    
    def get_person_id(self) -> int | None:
        """Get the currently selected person's ID."""
        return self._selected_person_id
    
    def set_person(self, person_id: int | None) -> None:
        """Set the selected person by ID."""
        if person_id is None:
            self.clear()
            return

        for display_name, pid in self._name_to_id.items():
            if pid == person_id:
                self.text_field.setText(display_name)
                self._selected_person_id = person_id
                return

        self.clear()
    
    def clear(self) -> None:
        """Clear the selection."""
        self.text_field.clear()
        self._selected_person_id = None
        self.selectionCleared.emit()
    
    def refresh(self) -> None:
        """Reload people from database (call after adding/editing people)."""
        current_id = self._selected_person_id
        self._load_people()

        if current_id is not None:
            self.set_person(current_id)
    
    def set_filter(self, gender: str | None = None) -> None:
        """Filter the displayed people by gender."""
        self.gender_filter = gender
        self._load_people()

>> ðŸ“‹ widgets\portrait_gallery.py (1 code lines)
"""Widget for displaying and managing person portraits."""

from PySide6.QtWidgets import QWidget


class PortraitGallery(QWidget):
    """Gallery widget for viewing and selecting portraits."""

    def __init__(self, person_id: int) -> None:
        """Initialize the portrait gallery widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load portraits from Portrait table
        # TODO: Display portraits in grid layout
        # TODO: Add portrait selection highlighting
        # TODO: Add upload new portrait button
        # TODO: Add delete portrait button
        # TODO: Emit signal on portrait selection
        pass


>> ðŸ“‹ widgets\search_bar.py (2 code lines)
"""Search bar widget for finding people by name."""

from PySide6.QtWidgets import QWidget


class SearchBar(QWidget):
    """Search widget with autocomplete for finding people."""

    def __init__(self) -> None:
        """Initialize the search bar widget."""
        super().__init__()
        # TODO: Add QLineEdit for search input
        # TODO: Implement autocomplete using QCompleter
        # TODO: Load all person names from database
        # TODO: Add search icon/button
        # TODO: Add clear button
        # TODO: Emit signal when person is selected
        # TODO: Support fuzzy matching (optional)
        pass

    def update_completions(self) -> None:
        """Refresh autocomplete list from database."""
        # TODO: Reload all person names
        # TODO: Update QCompleter model
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UTILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ utils\__init__.py (0 code lines)
"""Utility modules for calculations and helpers."""


>> ðŸ“‹ utils\color_manager.py (5 code lines)
"""Color utilities for UI elements."""

from PySide6.QtGui import QColor


class ColorManager:
    """Manage colors for various UI elements."""

    def __init__(self) -> None:
        """Initialize the color manager."""
        # TODO: Define color palettes
        # TODO: Define gender-specific colors
        # TODO: Define generation band colors
        # TODO: Define event type colors
        pass

    def get_person_color(self, gender: str | None) -> QColor: # type: ignore 
        """Get color for person based on gender."""
        # TODO: Return blue for male
        # TODO: Return pink for female
        # TODO: Return gray for unknown
        pass

    def get_generation_color(self, generation: int) -> QColor: # type: ignore 
        """Get alternating color for generation bands."""
        # TODO: Return alternating colors based on generation number
        pass

    def get_event_color(self, event_type: str) -> QColor: # type: ignore 
        """Get color for event type."""
        # TODO: Return different colors for different event types
        # TODO: Birth, death, marriage, arrival, etc.
        pass

    def interpolate_color(self, color1: QColor, color2: QColor, ratio: float) -> QColor: # type: ignore 
        """Blend two colors together."""
        # TODO: Calculate intermediate color
        # TODO: Return blended QColor
        pass


>> ðŸ“‹ utils\csv_importer.py (4 code lines)
"""CSV import utility for bulk data loading."""

import csv


class CSVImporter:
    """Import genealogy data from CSV files."""

    def __init__(self, database_connection) -> None:
        """Initialize the CSV importer."""
        self.db = database_connection

    def import_people(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import people from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert people into database
        # TODO: Return count of imported people
        pass

    def import_marriages(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import marriages from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data (check person IDs exist)
        # TODO: Insert marriages into database
        # TODO: Return count of imported marriages
        pass

    def import_events(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import events from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert events into database
        # TODO: Return count of imported events
        pass


>> ðŸ“‹ utils\generation_calculator.py (2 code lines)
"""Calculate generation levels for all people."""


class GenerationCalculator:
    """Compute generation levels for genealogical hierarchy."""

    def __init__(self, database_connection) -> None:
        """Initialize the generation calculator."""
        self.db = database_connection

    def recompute_all_generations(self) -> None:
        """Recalculate generation levels for all people."""
        # TODO: Find all founders (no parents)
        # TODO: Run BFS from founders
        # TODO: Assign generation numbers
        # TODO: Handle edge cases (adoptions, step-relations)
        pass


>> ðŸ“‹ utils\relationship_calculator.py (3 code lines)
"""Calculate relationships between people using graph traversal."""


class RelationshipCalculator:
    """Calculate familial relationships between two people."""

    def __init__(self, database_connection) -> None:
        """Initialize the relationship calculator."""
        self.db = database_connection

    def find_relationship_path(self, person1_id: int, person2_id: int) -> list[int] | None:
        """Find the shortest relationship path between two people."""
        # TODO: Implement BFS graph traversal
        # TODO: Return list of person IDs in the path
        pass

    def describe_relationship(self, person1_id: int, person2_id: int) -> str:
        """Return a human-readable relationship description."""
        # TODO: Implement relationship naming logic
        # TODO: Handle parents, siblings, cousins, etc.
        # TODO: Handle "removed" relationships
        pass


>> âœ… utils\settings_manager.py (81 code lines)
"""User preferences and settings management."""

from __future__ import annotations
from typing import Any
from PySide6.QtCore import QSettings

class SettingsManager:
    """Manages user preferences and disk persistence."""

    DEFAULTS = {
        "shortcuts": {
            # File Menu shortcuts
            "file.new": "Ctrl+N",
            "file.open": "Ctrl+O",
            "file.save": "Ctrl+S",
            "file.save_as": "Ctrl+Shift+S",
            "file.exit": "Ctrl+Q",

            # Edit Menu shortcuts
            "edit.undo": "Ctrl+Z",
            "edit.redo": "Ctrl+Y",
            "edit.add_person": "Ctrl+P",
            "edit.remove_person": "Del",
            "edit.add_new_family": "Ctrl+F",

            # View Menu shortcuts
            "view.family_trees": "Ctrl+1",
            "view.timeline": "Ctrl+2",
            "view.dynasty": "Ctrl+3",
            "view.data_table": "Ctrl+4",

            # Tools Menu shortcuts
            "tools.rebuild_scene": "F5",
            "tools.recompute_generations": "Ctrl+R",
            "tools.validate_marriages": "Ctrl+M",
            "tools.validate_parentage": "Ctrl+Shift+P",

            # Settings Menu shortcuts
            "settings.settings": "Ctrl+,",
            "settings.general": "",
            "settings.shortcuts": "",
            "settings.display": "",
            "settings.appearance": "",
            "settings.formats": "",

            # Help Menu shortcuts
            "help.about": "F1",
        },

        "general": {
            # TODO: Define general settings defaults
            # e.g., autosave interval, default file paths, etc.
            # including different header sections as above
        },

        "display": {
            # TODO: Define display settings defaults
            # e.g., default zoom level, layout preferences, etc.
            # including different header sections as above
            # window size, position, maximized state, fonts, themes etc.
        },

        "appearance": {
            # TODO: Define appearance settings defaults
            # e.g., color schemes, node styles, edge styles, Colorblindness modes,
            # Male/Female/Unknown color preferences, generation band colors, genetic line styles, etc.
            # including different header sections as above to keep things organized
        },

        "formats": {
            # TODO: Define format settings defaults
            # e.g., date formats, name display formats, event display formats, etc.
            # Undo/Redo stack size, autosave file format, import/export preferences, etc.
            # including different header sections as above
        },
    }

    def __init__(self) -> None:
        """Initialize settings manager and load user settings."""
        
        self.qsettings = QSettings("DynastyVizualizer", "DynastyVisualizer")

        self.custom_shortcuts: dict[str, str | None] = {}
        self.custom_general: dict[str, Any] = {}
        self.custom_display: dict[str, Any] = {}
        self.custom_appearance: dict[str, Any] = {}
        self.custom_formats: dict[str, Any] = {}
    
        self._load_from_disk()

    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------

    def _get_custom_dict(self, category: str) -> dict[str, Any]:
        """Get the custom dictionary for a given category."""
        category_map = {
            "shortcuts": self.custom_shortcuts,
            "general": self.custom_general,
            "display": self.custom_display,
            "appearance": self.custom_appearance,
            "formats": self.custom_formats,
        }
        return category_map.get(category, {})

    def _load_from_disk(self) -> None:
        """Load user's saved settings from disk."""
        for category in self.DEFAULTS.keys():
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if self.qsettings.contains(key):
                    value = self.qsettings.value(key)
                    custom_dict[key] = value if value else None
            
            self.qsettings.endGroup()
    def _save_to_disk(self) -> None:
        """Save user's custom settings to disk."""
        for category in self.DEFAULTS.keys():
            # Clear existing category on disk
            self.qsettings.beginGroup(category)
            self.qsettings.remove("")
            self.qsettings.endGroup()
            
            # Save only settings that exist in current DEFAULTS
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if key in custom_dict:  
                    value = custom_dict[key]
                    default = self.DEFAULTS[category][key]

                    if value != default:
                        self.qsettings.setValue(key, value if value else "")
            
            self.qsettings.endGroup()
        
        self.qsettings.sync()

    # ------------------------------------------------------------------
    # Shortcut Operations (Specific, Type-Safe)
    # ------------------------------------------------------------------

    def get_shortcut(self, action_name: str) -> str:
        """Get the shortcut for a given action, falling back to default if not customized."""
        return self.get_setting("shortcuts", action_name)

    def set_shortcut(self, action_name: str, shortcut: str) -> None:
        """Set custom shortcut in memory without saving to disk."""
        self.set_setting("shortcuts", action_name, shortcut)

        if shortcut:
            for other_action in list(self.custom_shortcuts.keys()):
                if other_action != action_name:
                    if self.custom_shortcuts[other_action] == shortcut:
                        self.custom_shortcuts[other_action] = None


    # ------------------------------------------------------------------
    # Generic Settings Operations
    # ------------------------------------------------------------------

    def get_setting(self, category: str, key: str) -> Any:
        """Get setting from any category, checking custom then default."""
        # Check custom value first
        custom_dict = self._get_custom_dict(category)
        if key in custom_dict:
            value = custom_dict[key]
            return value if value is not None else ""
        
        # Fall back to default
        if category in self.DEFAULTS and key in self.DEFAULTS[category]:
            return self.DEFAULTS[category][key]
        
        return ""
    
    def set_setting(self, category: str, key: str, value: Any) -> None:
        """Set setting in any category (memory only, not saved to disk)."""
        custom_dict = self._get_custom_dict(category)
        custom_dict[key] = value if value else None

    # ------------------------------------------------------------------
    # Save/Discard/Reset Operations
    # ------------------------------------------------------------------

    def save(self) -> None:
        """Save all custom settings to disk."""
        self._save_to_disk()

    def discard_changes(self) -> None:
        """Discard unsaved changes by reloading from disk."""
        self.custom_shortcuts.clear()
        self.custom_general.clear()
        self.custom_display.clear()
        self.custom_appearance.clear()
        self.custom_formats.clear()
        self._load_from_disk()

    def reset_category_to_defaults(self, category: str) -> None:
        """Reset one category to defaults and save to disk."""
        custom_dict = self._get_custom_dict(category)
        custom_dict.clear()
        self._save_to_disk()

    def reset_all_to_defaults(self) -> None:
        """Reset all categories to defaults and save to disk."""
        for category in self.DEFAULTS.keys():
            self.reset_category_to_defaults(category)

>> ðŸ“‹ utils\skin_manager.py (4 code lines)
"""Skin/theme management for UI customization."""

from PySide6.QtWidgets import QApplication


class SkinManager:
    """Manage application color schemes and themes."""

    def __init__(self) -> None:
        """Initialize the skin manager with built-in themes."""
        self.skins: dict[str, dict[str, str]] = {}
        # TODO: Define default skin
        # TODO: Define dark mode skin
        # TODO: Define light mode skin
        # TODO: Define custom color schemes
        pass

    def load_skin(self, skin_name: str) -> None:
        """Apply a color scheme to the application."""
        # TODO: Get color definitions for skin_name
        # TODO: Generate QSS stylesheet
        # TODO: Apply to QApplication
        pass

    def get_available_skins(self) -> list[str]:
        """Get list of available skin names."""
        # TODO: Return list of skin keys
        pass

    def create_custom_skin(self, name: str, colors: dict[str, str]) -> None:
        """Create a new custom color scheme."""
        # TODO: Validate color values
        # TODO: Store in skins dictionary
        # TODO: Optionally save to Settings table
        pass


>> ðŸ“‹ utils\validators.py (5 code lines)
"""Data validation tools for detecting inconsistencies."""


class MarriageValidator:
    """Validate marriage data for inconsistencies."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all marriages for issues."""
        # TODO: Check for overlapping marriages
        # TODO: Check for invalid dates
        # TODO: Check for self-marriages
        # TODO: Return list of issues
        pass


class ParentageValidator:
    """Validate parent-child relationships."""

    def __init__(self, database_connection) -> None:
        """Initialize the parentage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all parentage relationships for issues."""
        # TODO: Check for circular parentage
        # TODO: Check for impossible dates
        # TODO: Return list of issues
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCRIPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… scripts\create_codebase_summary.py (119 code lines)
"""
Generate dynasty_codebase.txt - Complete codebase snapshot optimized for LLMs.

Creates a token-efficient snapshot of ALL source code that LLMs can use to
understand the complete project state in a single context window.

Usage:
    python scripts/create_codebase_summary.py

Output:
    dynasty_codebase.txt - Complete codebase, LLM-optimized

Features:
    - Token-efficient: Minimal headers, maximum code density
    - Complete: ALL Python files included
    - Organized: Grouped by category for easy parsing
    - Compact: No visual trees, just clean code listings
    - Smart encoding: Handles UTF-8, UTF-16
"""

import os
from pathlib import Path
from datetime import datetime
from typing import List, Tuple


# Configuration
OUTPUT_FILE = "dynasty_codebase.txt"
PROJECT_NAME = "DynastyVizualizer"

# Files/directories to ignore
IGNORE_PATTERNS = {
    "__pycache__", ".git", ".pytest_cache", ".venv", "venv", "env",
    ".env", "*.pyc", "*.pyo", "*.pyd", ".DS_Store", "*.egg-info",
    "dist", "build", ".idea", ".vscode", "*.dyn", "*.backup",
    "node_modules", "*.md", "dynasty_codebase.txt"
}

# File extensions to include
SOURCE_EXTENSIONS = {".py"}

# Config files to include
CONFIG_FILES = {"requirements.txt"}


def should_ignore(path: Path) -> bool:
    """Check if path or any parent should be ignored."""
    path_str = str(path)
    
    # Check if any part of the path matches ignore patterns
    for part in path.parts:
        if part in IGNORE_PATTERNS:
            return True
    
    # Check filename patterns
    name = path.name
    for pattern in IGNORE_PATTERNS:
        if "*" in pattern:
            ext = pattern.replace("*", "")
            if path_str.endswith(ext):
                return True
    
    if name == OUTPUT_FILE:
        return True
    
    return False

def count_code_lines(filepath: Path) -> int:
    """Count non-empty, non-comment lines."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            count = 0
            in_multiline = False

            for line in f:
                stripped = line.strip()
                if not stripped:
                    continue

                if '"""' in stripped or "'''" in stripped:
                    in_multiline = not in_multiline
                    continue

                if in_multiline or stripped.startswith('#'):
                    continue

                count += 1

            return count
    except Exception:
        return 0


def discover_files(root_dir: Path) -> Tuple[List[Path], List[Path]]:
    """Discover all source and config files."""
    source_files = []
    config_files = []

    for path in sorted(root_dir.rglob("*")):
        if path.is_dir() or should_ignore(path):
            continue

        if path.suffix in SOURCE_EXTENSIONS:
            source_files.append(path)
        elif path.name in CONFIG_FILES:
            config_files.append(path)

    return source_files, config_files


def get_relative_path(filepath: Path, root: Path) -> str:
    """Get path relative to project root."""
    try:
        return str(filepath.relative_to(root))
    except ValueError:
        return str(filepath)


def read_file_content(filepath: Path) -> str:
    """Read file content with multiple encoding support."""
    for encoding in ['utf-8', 'utf-16', 'utf-16-le', 'latin-1']:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                content = f.read()
                if '\x00' not in content or encoding.startswith('utf-16'):
                    return content
        except (UnicodeDecodeError, Exception):
            continue

    try:
        with open(filepath, 'rb') as f:
            return f.read().decode('utf-8', errors='replace')
    except Exception as e:
        return f"[Error: {e}]"


def categorize_files(source_files: List[Path], root: Path) -> dict:
    """Organize files by category."""
    categories = {
        "Core": [], "Database": [], "Models": [], "Actions": [],
        "Commands": [], "Dialogs": [], "Views": [], "Widgets": [],
        "Utils": [], "Scripts": []
    }

    for f in source_files:
        rel_path = get_relative_path(f, root)
        parent = str(Path(rel_path).parent)

        if rel_path == "main.py":
            categories["Core"].append(f)
        elif "database" in parent:
            categories["Database"].append(f)
        elif "models" in parent:
            categories["Models"].append(f)
        elif "actions" in parent:
            categories["Actions"].append(f)
        elif "commands" in parent:
            categories["Commands"].append(f)
        elif "dialogs" in parent:
            categories["Dialogs"].append(f)
        elif "views" in parent:
            categories["Views"].append(f)
        elif "widgets" in parent:
            categories["Widgets"].append(f)
        elif "utils" in parent:
            categories["Utils"].append(f)
        elif "scripts" in parent:
            categories["Scripts"].append(f)
        else:
            categories["Core"].append(f)

    return categories


def generate_summary(root_dir: Path) -> None:
    """Generate the token-efficient codebase snapshot."""

    print(f"ðŸ” Discovering files in {PROJECT_NAME}...")
    source_files, config_files = discover_files(root_dir)

    total_files = len(source_files)
    implemented = sum(1 for f in source_files if count_code_lines(f) > 20)
    code_lines = sum(count_code_lines(f) for f in source_files)

    print(f"ðŸ“Š Found {total_files} files ({implemented} implemented, {code_lines} code lines)")

    categories = categorize_files(source_files, root_dir)
    output_path = root_dir / OUTPUT_FILE

    with open(output_path, 'w', encoding='utf-8') as out:
        # Compact header
        out.write(f"{'='*70}\n")
        out.write(f"{PROJECT_NAME} - Complete Codebase\n")
        out.write(f"{'='*70}\n")
        out.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        out.write(f"Files: {implemented}/{total_files} implemented | {code_lines} code lines\n")
        out.write(f"Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern\n")
        out.write(f"Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)\n")
        out.write(f"{'='*70}\n\n")

        # Quick context
        out.write("QUICK CONTEXT:\n")
        out.write("Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,\n")
        out.write("undo/redo, flexible dates, special char support, DB migration.\n")
        out.write("Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database\n\n")

        # File index (compact)
        out.write("FILE INDEX:\n")
        for category, files in categories.items():
            if files:
                out.write(f"{category}: ")
                file_names = [get_relative_path(f, root_dir) for f in sorted(files)]
                out.write(", ".join(file_names[:5]))
                if len(files) > 5:
                    out.write(f", ... ({len(files)} total)")
                out.write("\n")
        out.write(f"\n{'='*70}\n")
        out.write("COMPLETE SOURCE CODE\n")
        out.write(f"{'='*70}\n\n")

        # Output code by category (compact format)
        for category, files in categories.items():
            if not files:
                continue

            out.write(f"\n{'â”€'*70}\n")
            out.write(f"{category.upper()}\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in sorted(files):
                rel_path = get_relative_path(filepath, root_dir)
                lines = count_code_lines(filepath)
                status = "âœ…" if lines > 20 else "ðŸ“‹"

                # Compact file header
                out.write(f">> {status} {rel_path} ({lines} code lines)\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

                print(f"âœ… {rel_path} ({lines} lines)")

        # Config files
        if config_files:
            out.write(f"\n{'â”€'*70}\n")
            out.write("CONFIGURATION\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in config_files:
                rel_path = get_relative_path(filepath, root_dir)
                out.write(f">> {rel_path}\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

        # Compact footer
        out.write(f"\n{'='*70}\n")
        out.write(f"END - {implemented}/{total_files} files, {code_lines} code lines\n")
        out.write(f"{'='*70}\n")

    print(f"\nâœ… Generated {OUTPUT_FILE}")
    print(f"ðŸ“Š {implemented}/{total_files} files, {code_lines:,} code lines")
    print(f"ðŸ“„ Output: {output_path}")
    print(f"ðŸ¤– Token-optimized for LLM consumption!\n")


if __name__ == "__main__":
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)

    print(f"{'='*60}")
    print(f"  {PROJECT_NAME} - Codebase Generator")
    print(f"{'='*60}\n")

    generate_summary(project_root)


>> âœ… scripts\migrate_database.py (57 code lines)
"""
Migration script to upgrade existing .dyn files to the new schema.

This script safely adds:
1. Day fields to all date columns (birth, death, arrival, etc.)
2. New tables (Portrait, Family, MajorEvent, PersonPosition, Settings)
3. Additional Person fields (maiden_name, family_id, notes)
4. Marriage type field

Usage:
    python scripts/migrate_database.py <path_to_dynasty_file.dyn>

Example:
    python scripts/migrate_database.py "MyDynasty.dyn"

This migration is SAFE:
- Existing data is preserved (new columns are NULL)
- No data is deleted or modified
- Backup is created before migration
"""

import sqlite3
import shutil
import sys
from pathlib import Path


def backup_database(file_path: str) -> str:
    """Create a backup of the database before migration."""
    backup_path = f"{file_path}.backup"
    shutil.copy2(file_path, backup_path)
    print(f"âœ… Backup created: {backup_path}")
    return backup_path


def get_existing_columns(cursor: sqlite3.Cursor, table_name: str) -> list[str]:
    """Get list of existing columns in a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return [row[1] for row in cursor.fetchall()]


def migrate_database(file_path: str) -> None:
    """Migrate an existing .dyn database to the new schema."""

    if not Path(file_path).exists():
        print(f"âŒ Error: File '{file_path}' not found")
        sys.exit(1)

    print(f"Migrating database: {file_path}")
    print("=" * 60)

    # Create backup
    backup_path = backup_database(file_path)

    try:
        # Connect to database
        conn = sqlite3.connect(file_path)
        conn.execute("PRAGMA foreign_keys = ON;")
        cursor = conn.cursor()

        # Migrate Person table
        print("\nðŸ“ Migrating Person table...")
        person_columns = get_existing_columns(cursor, "Person")

        person_migrations = [
            ("birth_day", "ALTER TABLE Person ADD COLUMN birth_day INTEGER"),
            ("death_day", "ALTER TABLE Person ADD COLUMN death_day INTEGER"),
            ("arrival_day", "ALTER TABLE Person ADD COLUMN arrival_day INTEGER"),
            ("moved_out_day", "ALTER TABLE Person ADD COLUMN moved_out_day INTEGER"),
            ("maiden_name", "ALTER TABLE Person ADD COLUMN maiden_name TEXT"),
            ("family_id", "ALTER TABLE Person ADD COLUMN family_id INTEGER REFERENCES Family(id) ON DELETE SET NULL"),
            ("notes", "ALTER TABLE Person ADD COLUMN notes TEXT"),
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
        ]

        for col_name, sql in person_migrations:
            if col_name not in person_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Event table
        print("\nðŸ“ Migrating Event table...")
        event_columns = get_existing_columns(cursor, "Event")

        event_migrations = [
            ("start_day", "ALTER TABLE Event ADD COLUMN start_day INTEGER"),
            ("end_day", "ALTER TABLE Event ADD COLUMN end_day INTEGER"),
        ]

        for col_name, sql in event_migrations:
            if col_name not in event_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Marriage table
        print("\nðŸ“ Migrating Marriage table...")
        marriage_columns = get_existing_columns(cursor, "Marriage")

        marriage_migrations = [
            ("marriage_day", "ALTER TABLE Marriage ADD COLUMN marriage_day INTEGER"),
            ("dissolution_day", "ALTER TABLE Marriage ADD COLUMN dissolution_day INTEGER"),
            ("marriage_type", "ALTER TABLE Marriage ADD COLUMN marriage_type TEXT DEFAULT 'spouse'"),
        ]

        for col_name, sql in marriage_migrations:
            if col_name not in marriage_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Create new tables
        print("\nðŸ“ Creating new tables...")

        new_tables = {
            "Portrait": """
                CREATE TABLE IF NOT EXISTS Portrait (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    person_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    valid_from_year INTEGER,
                    valid_from_month INTEGER,
                    valid_from_day INTEGER,
                    valid_to_year INTEGER,
                    valid_to_month INTEGER,
                    valid_to_day INTEGER,
                    is_primary INTEGER DEFAULT 0,
                    display_order INTEGER DEFAULT 0,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Family": """
                CREATE TABLE IF NOT EXISTS Family (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    surname TEXT NOT NULL,
                    move_in_year INTEGER,
                    move_in_month INTEGER,
                    move_in_day INTEGER,
                    coat_of_arms_path TEXT,
                    family_color TEXT,
                    is_extinct INTEGER DEFAULT 0,
                    notes TEXT
                )
            """,
            "MajorEvent": """
                CREATE TABLE IF NOT EXISTS MajorEvent (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_name TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    start_year INTEGER NOT NULL,
                    start_month INTEGER,
                    start_day INTEGER,
                    end_year INTEGER,
                    end_month INTEGER,
                    end_day INTEGER,
                    description TEXT,
                    color TEXT
                )
            """,
            "PersonPosition": """
                CREATE TABLE IF NOT EXISTS PersonPosition (
                    person_id INTEGER PRIMARY KEY,
                    view_type TEXT NOT NULL,
                    x_position REAL NOT NULL,
                    y_position REAL NOT NULL,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Settings": """
                CREATE TABLE IF NOT EXISTS Settings (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL
                )
            """
        }

        for table_name, create_sql in new_tables.items():
            # Check if table exists
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (table_name,)
            )
            if cursor.fetchone():
                print(f"  â­ï¸  Table already exists: {table_name}")
            else:
                cursor.execute(create_sql)
                print(f"  âœ… Created table: {table_name}")

        # Commit all changes
        conn.commit()
        conn.close()

        print("\n" + "=" * 60)
        print("âœ… Migration completed successfully!")
        print(f"âœ… Original database backed up to: {backup_path}")
        print(f"âœ… Migrated database: {file_path}")
        print("\nYour database is now ready for the full feature set!")
        print("All existing data has been preserved.")

    except Exception as e:
        print(f"\nâŒ Migration failed: {e}")
        print(f"Restoring from backup: {backup_path}")
        shutil.copy2(backup_path, file_path)
        print("âœ… Database restored to original state")
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/migrate_database.py <path_to_dynasty_file.dyn>")
        print("\nExample:")
        print('  python scripts/migrate_database.py "MyDynasty.dyn"')
        sys.exit(1)

    dynasty_file = sys.argv[1]
    migrate_database(dynasty_file)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONFIGURATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> requirements.txt
packaging==25.0
PySide6==6.10.1
PySide6_Addons==6.10.1
PySide6_Essentials==6.10.1
QtPy==2.4.3
shiboken6==6.10.1



======================================================================
END - 23/100 files, 2013 code lines
======================================================================
