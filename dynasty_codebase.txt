======================================================================
======================================================================
  DynastyVizualizer - Complete Codebase
======================================================================
======================================================================

Project: Family tree GUI for game Ostriv
Tech Stack: PySide6, SQLite, Python 3.10+
Code Files: 12 files, ~1057 lines

======================================================================

CONTEXT & DOCUMENTATION
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: README.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# DynastyVizualizer

A beautiful, feature-rich family tree visualization and genealogy management application for games with multi-generational families.

## Overview

DynastyVizualizer brings professional genealogy software features to gaming communities. Originally designed for [Ostriv](https://store.steampowered.com/app/773790/Ostriv/), it provides an intuitive interface for tracking complex family dynasties across generations, with support for multiple visualization modes, relationship tracing, portrait galleries, and historical event tracking.

### Why DynastyVizualizer?

- **Multiple Views**: Visualize your dynasty as an interactive tree, chronological timeline, data table, or statistics dashboard
- **Intelligent Layouts**: Automatic generational hierarchy with cohort positioning (families that move in together are displayed near age-peers)
- **Rich Relationships**: Track marriages, divorces, remarriages, affairs, step-families, and complex genealogical connections
- **Visual Customization**: Themeable UI with skins (parchment, blueprint, modern), portrait galleries, and family color coding
- **Powerful Search**: Real-time filtering and relationship path tracing between any two people
- **Full History**: Personal event logs, job changes, illnesses, injuries, and major historical events
- **Undo/Redo Everything**: Every operation is reversible, from data edits to UI changes

---

## Current Features (v0.1 - Early Development)

### âœ… Implemented
- âœ… Create and manage dynasty database files (`.dyn` format)
- âœ… Comprehensive database schema with 8 tables (flexible date support)
- âœ… SQLite-based data persistence with migration support
- âœ… File operations (New, Open, Save, Save As) - **fully functional**
- âœ… Unsaved changes tracking and prompting
- âœ… Clean, professional UI framework with menu structure
- âœ… Undo/redo infrastructure (Command pattern framework)

### ğŸš§ In Progress (Phase 1 Completion)
- ğŸš§ Edit menu dialogs (Add Person, Remove Person)
- ğŸš§ View menu functionality (view switching stubs)
- ğŸš§ Tools menu functionality (validation stubs)
- ğŸš§ Help menu (About dialog)
- ğŸš§ Error handling and user feedback dialogs

---

## Planned Features

### ğŸ¯ Phase 2: Data Management (Weeks 3-5)
- ğŸ“‹ Add, edit, and delete people with flexible date handling (year/month/day optional)
- ğŸ“‹ Create marriages and parent-child relationships
- ğŸ“‹ Track multiple marriages and divorces
- ğŸ“‹ Support for portraits with date-based switching
- ğŸ“‹ Personal event logs (jobs, illnesses, residences, etc.)
- ğŸ“‹ Maiden name tracking and configurable surname inheritance

### ğŸŒ³ Phase 3: Interactive Family Tree (Weeks 6-10)
- ğŸ“‹ Visual person boxes with portraits, names, and key dates
- ğŸ“‹ **Drag-and-drop**: Reposition people or drag onto each other to create marriages
- ğŸ“‹ Automatic generational layout with cohort positioning
- ğŸ“‹ **In-place editing**: Click any field to edit directly
- ğŸ“‹ **Gear icon**: Opens extended details panel with tabs for:
  - Basic info and all editable fields
  - Personal event history
  - Relationship overview
  - Portrait gallery
- ğŸ“‹ Generation bands showing hierarchical levels
- ğŸ“‹ Scrollable, zoomable canvas (pan with middle-mouse, zoom with scroll wheel)
- ğŸ“‹ Right-click context menus for quick actions

### ğŸ” Phase 4: Relationship Analysis (Weeks 11-13)
- ğŸ“‹ **Single-click**: Highlight immediate family (parents, spouses, children)
- ğŸ“‹ **Double-click**: Set as "primary" person and label all relationships
  - Brothers, sisters, grandparents, uncles, aunts, cousins
  - Step-parents, step-siblings, half-siblings
  - "1st removed", "2nd removed" for distant relatives
- ğŸ“‹ **Ctrl+Click two people**: Find and highlight relationship path
  - Visual gradient (green â†’ yellow â†’ red by distance)
  - Popup explaining relationship ("Alice is Bob's great-aunt's grandson")
  - Dim unrelated people
- ğŸ“‹ **Real-time search**: Type names to filter tree and auto-scroll to matches

### ğŸ“… Phase 5: Timeline View (Weeks 14-17)
- ğŸ“‹ Horizontal scrolling timeline with family lifespans
- ğŸ“‹ Collapsible family bars showing move-in to extinction dates
- ğŸ“‹ Individual lifespan bars with event markers:
  - Marriages, children born, job changes, illnesses
  - Clickable icons showing event details
- ğŸ“‹ **Major events**: Add historical context (wars, plagues, disasters)
  - Vertical lines across all families
  - Date ranges for ongoing events
- ğŸ“‹ **Sticky headers**: Family bars stay pinned while scrolling through members
- ğŸ“‹ Portrait thumbnails on person bars

### ğŸ“Š Phase 6: Data Tables & Import (Weeks 18-20)
- ğŸ“‹ Spreadsheet-style editing for power users
- ğŸ“‹ Sortable, filterable tables for people, marriages, events
- ğŸ“‹ Family statistics table with computed metrics:
  - Member count (living/total)
  - Longest-lived member
  - Most children (father/mother separately)
- ğŸ“‹ **CSV Import**: Bulk data entry with flexible date formats
  - Auto-detection of date formats (YYYY-MM-DD, DD-MM-YYYY, etc.)
  - Column mapping and validation preview
  - Error correction before import

### ğŸ“ˆ Phase 7: Statistics & Validation (Weeks 21-23)
- ğŸ“‹ Family dashboard with key metrics:
  - Population over time
  - Lifespan averages
  - Family size distributions
- ğŸ“‹ Interactive charts (population trends, deaths per year)
- ğŸ“‹ **Family comparison**: Ctrl+Click families to compare side-by-side
  - Member counts, lifespans, intermarriage statistics
  - Shared ancestors
- ğŸ“‹ **Data validation tools**:
  - Find overlapping marriages
  - Detect impossible dates (child born before parent)
  - Identify circular parentage
  - Clickable validation reports

### ğŸ¨ Phase 8: Visual Customization (Weeks 24-26)
- ğŸ“‹ **UI Skins**: Choose from multiple themes
  - Default (clean, modern)
  - Parchment (aged paper aesthetic)
  - Blueprint (technical drawing)
  - Medieval (illuminated manuscript)
  - Import custom skins
- ğŸ“‹ **Portrait Management**:
  - Multiple portraits per person
  - Date-based portrait switching ("looked like this from 1705-1720")
  - Auto-cycle or manual selection
  - Portrait gallery view
- ğŸ“‹ **Family Color Coding** (optional):
  - Visual family identification
  - Relationship distance gradient (green=close, red=distant)
  - Toggle on/off in preferences

### âš™ï¸ Phase 9: Polish & Convenience (Weeks 27-30)
- ğŸ“‹ Comprehensive preferences dialog (date formats, auto-save, behavior)
- ğŸ“‹ **Keyboard shortcuts**:
  - Ctrl+N/O/S (File operations)
  - Ctrl+Z/Y (Undo/Redo)
  - Ctrl+F (Search), Ctrl+P (Add Person), Del (Delete)
  - Ctrl+1/2/3/4 (Switch views)
  - Ctrl+Plus/Minus/0 (Zoom)
- ğŸ“‹ **Export functionality**:
  - Save tree view as high-resolution PNG/JPG
  - Export entire tree (not just viewport)
  - Optional PDF export (multi-page)
- ğŸ“‹ **Right-click workflows**:
  - "Get Married" â†’ searchable spouse selector
  - "Create Child" â†’ searchable partner selector
  - Quick access to all common operations
- ğŸ“‹ First-run tutorial and sample dynasty
- ğŸ“‹ Auto-save with configurable intervals

### ğŸš€ Future Possibilities (Post-Release)
- ğŸ“‹ Multi-dynasty support (work on multiple dynasties simultaneously)
- ğŸ“‹ Game-specific integrations (Ostriv, Crusader Kings 3 save file import)
- ğŸ“‹ Cloud sync and collaboration features
- ğŸ“‹ Mobile version (touch-optimized interface)
- ğŸ“‹ Advanced genealogy (trait tracking, DNA simulation)
- ğŸ“‹ Research citations and media attachments

---

## Installation

### Requirements
- **Python 3.10 or higher**
- **PySide6** (Qt for Python)

### Setup

1. Clone the repository:
```bash
git clone https://github.com/thief9001-maker/DynastyVizualizer.git
cd DynastyVizualizer
```

2. Install dependencies:
```bash
pip install -r requirements.txt
```

3. Run the application:
```bash
python main.py
```

---

## Usage Guide

### Creating a New Dynasty
1. Launch DynastyVizualizer
2. Go to **File â†’ New Dynasty**
3. Choose a location and name for your `.dyn` file
4. Start adding people and families

### Managing People
- **Add Person**: Right-click canvas or use **Edit â†’ Add Person**
- **Edit Person**: Double-click person box or click gear icon for extended panel
- **Quick Edit**: Click any field (name, dates) to edit in-place
- **Delete Person**: Select and press Delete, or right-click â†’ Delete

### Creating Relationships
- **Marriage (Drag-Drop)**: Drag a person box onto another to create a marriage
- **Marriage (Right-Click)**: Right-click person â†’ "Get Married" â†’ search for spouse
- **Add Child**: Right-click marriage node â†’ "Add Child"

### Navigation
- **Pan**: Middle-mouse drag or scrollbars
- **Zoom**: Ctrl + Scroll wheel
- **Search**: Ctrl+F to open search bar, type name to filter tree
- **Switch Views**: Ctrl+1 (Tree), Ctrl+2 (Timeline), Ctrl+3 (Table), Ctrl+4 (Stats)

### Saving Your Work
- **Save**: File â†’ Save (Ctrl+S)
- **Save As**: File â†’ Save As (Ctrl+Shift+S)
- **Auto-Save**: Configurable in preferences (Phase 9)
- The application will prompt you before closing with unsaved changes

---

## Technical Architecture

DynastyVizualizer uses a clean **MVC (Model-View-Controller)** architecture combined with the **Command Pattern** for comprehensive undo/redo support:

- **Model**: SQLite database with Person, Marriage, Event, Portrait, Family, and MajorEvent tables
- **View**: PySide6 (Qt) widgets for multiple visualization modes
- **Controller**: Action handlers coordinating user interactions
- **Command Pattern**: Every operation is undoable/redoable (data edits, UI changes, imports)

This architecture scales seamlessly from simple operations to complex features like draggable UI elements, relationship tracing, and bulk data import.

See [CODEBASE_SUMMARY.md](CODEBASE_SUMMARY.md) for comprehensive technical documentation.

---

## Development Status

**Current Phase**: Foundation (Phase 1) ğŸš§ **~60% Complete**
**Progress**: ~10% of total project
**Lines of Code**: ~850 (estimated final: 8,000-12,000)
**Next Milestone**: Complete Phase 1 foundational menus and dialogs

### What Works Now
- âœ… Application launches with menu bar
- âœ… File â†’ New Dynasty (creates `.dyn` database)
- âœ… File â†’ Open Dynasty (loads existing database)
- âœ… File â†’ Save / Save As (persists changes)
- âœ… File â†’ Exit (with unsaved changes prompt)
- âœ… Database schema with all 8 tables
- âœ… Migration script for existing files

### What's Next (Completing Phase 1)
- ğŸš§ Edit â†’ Add Person (dialog implementation)
- ğŸš§ Edit â†’ Remove Person (with confirmation)
- ğŸš§ Help â†’ About (application info dialog)
- ğŸš§ Basic error handling and feedback
- ğŸš§ Application icon and branding

### Roadmap Summary

| Phase | Description | Status | Progress | Weeks |
|-------|-------------|--------|----------|-------|
| **1** | Foundation (Database, Menus, Framework) | ğŸš§ In Progress | ~60% | 1-2 |
| **2** | Data Models & CRUD Dialogs | ğŸ“‹ Planned | 0% | 2-5 |
| **3** | Interactive Family Tree (QGraphicsView) | ğŸ“‹ Planned | 0% | 6-10 |
| **4** | Relationship Analysis & Tracing | ğŸ“‹ Planned | 0% | 11-13 |
| **5** | Timeline View | ğŸ“‹ Planned | 0% | 14-17 |
| **6** | Data Tables & CSV Import | ğŸ“‹ Planned | 0% | 18-20 |
| **7** | Statistics & Validation | ğŸ“‹ Planned | 0% | 21-23 |
| **8** | Visual Customization (Skins, Portraits) | ğŸ“‹ Planned | 0% | 24-26 |
| **9** | Polish & Convenience | ğŸ“‹ Planned | 0% | 27-30 |
| **10** | Future Enhancements | ğŸ“‹ Post-Release | 0% | TBD |

---

## Database Schema

Dynasty files (`.dyn`) are SQLite databases with flexible date handling and comprehensive relationship tracking.

### Core Tables
- **Person**: Names, dates (birth/death/arrival), parent references, portraits
- **Marriage**: Spouse pairs, marriage dates, dissolution dates and reasons
- **Event**: Personal history (jobs, illnesses, moves) with start/end dates

### Extended Tables (Included from Start)
- **Portrait**: Multiple images per person with date ranges
- **Family**: Dynasty grouping with move-in dates, coat of arms, colors
- **MajorEvent**: Historical context markers (wars, plagues, festivals)
- **PersonPosition**: Custom drag-and-drop positions
- **Settings**: User preferences

### Flexible Date Support

All date fields support three levels of precision:
- **Year Only**: `1705` (for unknown month/day)
- **Year/Month**: `March 1705` (typical for Ostriv)
- **Year/Month/Day**: `March 15, 1705` (real-world genealogy)

This design seamlessly supports both game contexts (like Ostriv without day precision) and real-world genealogy.

See [CODEBASE_SUMMARY.md](CODEBASE_SUMMARY.md) for complete SQL schemas.

---

## Contributing

This project follows strict coding conventions for consistency and maintainability.

### Coding Standards
- **Type Hints**: Python 3.10+ syntax (`X | None`, lowercase `list[T]`, `dict[K, V]`)
- **Docstrings**: Concise single-line format (5-15 words, imperative verbs)
- **Code Style**: PEP 8 compliant
- **Architecture**: Follow MVC + Command patterns

### Development Workflow
1. Review scaffolded files in project structure
2. Implement following established patterns (see reference files)
3. Add undo/redo support via Command pattern
4. Update UI integration
5. Test thoroughly (especially undo/redo)

See [CODEBASE_SUMMARY.md](CODEBASE_SUMMARY.md) for complete style guide and file templates.

---

## Technology Stack

- **Python 3.10+** - Modern Python with type hints
- **PySide6 6.10.1** - Qt framework for rich, cross-platform GUI
- **SQLite** - Embedded database for `.dyn` file persistence
- **Command Pattern** - Comprehensive undo/redo architecture

**Future Dependencies** (Phase 7+):
- **matplotlib** or **Qt Charts** - Statistics visualizations
- **Pillow** - Image processing for portraits

---

## License

This project is licensed under the **MIT License** - see the [LICENSE](LICENSE) file for details.

---

## Acknowledgments

- Built for the [Ostriv](https://store.steampowered.com/app/773790/Ostriv/) gaming community
- Developed with PySide6 (Qt for Python)
- Inspired by professional genealogy software with a focus on gaming use cases

---

## Project Links

- **Repository**: https://github.com/thief9001-maker/DynastyVizualizer
- **Issue Tracker**: https://github.com/thief9001-maker/DynastyVizualizer/issues
- **Technical Documentation**: [CODEBASE_SUMMARY.md](CODEBASE_SUMMARY.md)
- **Code Sharing Utility**: [scripts/create_codebase_summary.py](scripts/create_codebase_summary.py)

---

## Support

Found a bug? Have a feature request? Please [open an issue](https://github.com/thief9001-maker/DynastyVizualizer/issues) on GitHub.

For questions about Ostriv-specific use cases, visit the Ostriv community forums.

---

**Version**: 0.1.0-dev
**Status**: Early Development (Phase 1: ~60% Complete)
**Last Updated**: 2025-12-08

---

## Vision Statement

DynastyVizualizer aims to be the definitive tool for managing complex family dynasties in gaming. We're building something that looks professional, feels intuitive, and provides the depth that dynasty-management enthusiasts craveâ€”whether you're tracking three generations in Ostriv or twenty generations in Crusader Kings.

Every feature is designed with both power users and newcomers in mind: drag-and-drop for quick marriages, but also detailed event logs for deep genealogical research. Real-time search to find anyone instantly, but also relationship path tracing to discover how that random villager is actually your character's third cousin twice removed.

This is a labor of love for gaming communities who care about their virtual families as much as we do. ğŸ°ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: CODEBASE_SUMMARY.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# DynastyVizualizer Codebase Summary

## Project Overview

**DynastyVizualizer** is a comprehensive family tree visualization and genealogy management application designed for games with multi-generational families, starting with [Ostriv](https://store.steampowered.com/app/773790/Ostriv/). It provides tools to create, manage, and visualize complex family dynasties with support for marriages, events, portraits, and genealogical relationships across multiple views and perspectives.

### Technology Stack
- **GUI Framework**: PySide6 (Qt for Python)
- **Database**: SQLite with custom `.dyn` file format
- **Language**: Python 3.10+
- **Patterns**: MVC architecture with Command pattern for undo/redo

### Vision
A beautiful, feature-rich genealogy application that combines the depth of professional genealogy software with the accessibility of modern UI design. Support for draggable person nodes, multiple visualization modes (tree, timeline, statistics), relationship tracing, portrait galleries, and historical event tracking.

---

## Codebase Statistics

- **Total Python Files**: 102 (9 implemented, 93 scaffolded)
- **Lines of Code**: ~1,100 (excluding comments and blank lines)
- **Total Lines**: ~2,500 (including docstrings and comments)
- **Implementation Status**: ~10% complete (Phase 1 infrastructure in progress)
- **Estimated Final Size**: 10,000-15,000 lines of code

---

## Coding Standards & Conventions

### Type Hints
We use modern Python 3.10+ type hint syntax throughout the codebase:

```python
# Union types with pipe operator (not Optional[...])
def save_database(self, path: str | None = None) -> bool:
    """Save the database, optionally to a new path."""

# Instance variables with type annotations
self.conn: sqlite3.Connection | None = None
self.file_path: str | None = None

# Modern collection types (lowercase, not typing.List/Dict)
self.undo_stack: list[Command] = []
self.data: dict[str, int] = {}

# Forward references for circular imports
def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
```

**Rules**:
- âœ… Always specify return types (`-> Type`)
- âœ… Use `X | None` instead of `Optional[X]` or `Union[X, None]`
- âœ… Use lowercase `list[T]`, `dict[K, V]` (PEP 585 style)
- âœ… Use forward references with quotes for circular imports
- âœ… Add `# type: ignore` when necessary for Qt compatibility

### Docstrings
We maintain concise, single-line docstrings for clarity and consistency:

```python
def new_database(self, file_path: str) -> None:
    """Create a brand-new .dyn file with the dynasty schema."""

class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""
```

**Rules**:
- âœ… Single-line triple quotes for most methods/classes
- âœ… Imperative/action verbs ("Create...", "Check...", "Initialize...")
- âœ… Keep to 5-15 words typically
- âœ… No parameter documentation or return value docs
- âœ… Only use multi-line when genuinely needed for context
- âŒ Avoid complex/advanced docstring formats (Google, NumPy, Sphinx style)

### Code Style
- **Formatting**: PEP 8 compliant
- **Section markers**: Use `# -----` comment blocks to organize code sections
- **Naming**: Descriptive names, `snake_case` for functions/variables
- **Properties**: Use `@property` decorators for encapsulation
- **Error handling**: Specific exception types, informative error messages

---

## Architecture

### Design Pattern: MVC + Command

The application uses **Model-View-Controller (MVC)** architecture combined with the **Command Pattern** for undo/redo functionality. This architecture successfully scales to support complex features like draggable UI, multiple views, and relationship tracing.

#### High-Level Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MainWindow (main.py)                      â”‚
â”‚                   - Central Controller                      â”‚
â”‚                   - Menu bar and toolbar                    â”‚
â”‚                   - View switching and lifecycle            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                                  â”‚
           â”‚ delegates to                     â”‚ displays
           â–¼                                  â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Actions    â”‚                  â”‚      Views       â”‚
    â”‚   Handlers   â”‚                  â”‚  (Presentation)  â”‚
    â”‚ (Controllers)â”‚                  â”‚                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚  â€¢ TreeView      â”‚
           â”‚                          â”‚  â€¢ TimelineView  â”‚
           â”‚ creates/executes         â”‚  â€¢ TableView     â”‚
           â–¼                          â”‚  â€¢ StatsView     â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚   Commands   â”‚                           â”‚
    â”‚  (Business   â”‚                           â”‚ reads from
    â”‚   Logic)     â”‚                           â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
           â”‚                                   â”‚
           â”‚ modifies                          â”‚
           â–¼                                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              DatabaseManager (Model)                  â”‚
    â”‚              - SQLite .dyn files                      â”‚
    â”‚              - CRUD operations                        â”‚
    â”‚              - Data validation                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Component Responsibilities

**Model (Data Layer)**
- `database/db_manager.py` - SQLite database operations
- `models/` - Data classes (Person, Marriage, Event, Family, Portrait, MajorEvent)
- Responsibilities:
  - Store and retrieve data
  - Enforce data integrity
  - Provide clean API for data access
  - Track dirty state (unsaved changes)

**View (Presentation Layer)**
- `views/tree_view/` - Family tree visualization
- `views/timeline_view/` - Chronological timeline
- `views/table_view/` - Spreadsheet-style tables
- `views/stats_view/` - Statistics dashboard
- `dialogs/` - Modal dialogs for data entry
- `widgets/` - Reusable UI components
- Responsibilities:
  - Display data to user
  - Capture user input
  - Emit signals on user actions
  - Update when data changes

**Controller (Logic Layer)**
- `main.py` - Central controller and view manager
- `actions/` - Action handlers for menu operations
- `commands/` - Business logic encapsulated as commands
- Responsibilities:
  - Respond to user actions
  - Create and execute commands
  - Coordinate between model and view
  - Manage application state

#### Command Pattern Integration

Every data modification goes through the command pattern for undo/redo support:

```
User Action Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User   â”‚â”€â”€â”€â”€â”€â–¶â”‚   View   â”‚â”€â”€â”€â”€â”€â–¶â”‚   Action     â”‚â”€â”€â”€â”€â”€â–¶â”‚ Command  â”‚
â”‚  (Click) â”‚      â”‚ (Signal) â”‚      â”‚   Handler    â”‚      â”‚ (Created)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                                                â”‚
                                                                â–¼
                                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                    â”‚  UndoRedoManager  â”‚
                                                    â”‚  execute(command) â”‚
                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                              â”‚
                                                              â–¼
                                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                            â”‚  1. command.run()           â”‚
                                            â”‚  2. Modify database         â”‚
                                            â”‚  3. Push to undo stack      â”‚
                                            â”‚  4. Clear redo stack        â”‚
                                            â”‚  5. Emit signals to update  â”‚
                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Interaction Example: Adding a Person

Let's trace what happens when a user adds a new person:

**Step 1: User Initiates Action**
```
User clicks: Edit â†’ Add Person
  â†“
main.py menu action triggered
  â†“
Calls: self.edit_actions.add_person()
```

**Step 2: Controller Creates Dialog**
```
actions/edit_actions.py:
  â†“
Opens: AddPersonDialog(self.parent)
  â†“
User fills form: Name, Gender, Birth Date, etc.
  â†“
User clicks: OK button
```

**Step 3: Dialog Creates Command**
```
dialogs/add_person_dialog.py:
  â†“
Creates: AddPersonCommand(db=self.db, first_name="John", last_name="Smith", ...)
  â†“
Passes to: self.parent.undo_manager.execute(command)
```

**Step 4: Command Executes**
```
commands/undo_redo_manager.py:
  execute(command):
    1. command.run()  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â†“                           â”‚
    2. Add to undo stack           â”‚
       self.undo_stack.append(cmd) â”‚
       â†“                           â”‚
    3. Clear redo stack            â”‚
       self.redo_stack.clear()     â”‚
                                   â”‚
                                   â–¼
commands/genealogy_commands/add_person.py:
  run():
    1. INSERT INTO Person (...) VALUES (...)
       â†“
    2. Store self.person_id = cursor.lastrowid
       â†“
    3. db.mark_dirty()
       â†“
    4. Emit signal: person_added(self.person_id)
```

**Step 5: Views Update**
```
Views listening to signals:
  â†“
TreeView.on_person_added(person_id)
  - Creates new PersonBox widget
  - Adds to scene
  - Runs layout engine
  â†“
TableView.on_person_added(person_id)
  - Adds new row to person table
  - Sorts if necessary
  â†“
MainWindow updates:
  - Sets title to show unsaved changes (*)
  - Enables Undo menu item
```

**Step 6: User Can Undo**
```
User presses: Ctrl+Z or Edit â†’ Undo
  â†“
undo_manager.undo():
  1. Pop command from undo stack
  2. command.undo()  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  3. Push to redo stack          â”‚
                                 â”‚
                                 â–¼
AddPersonCommand.undo():
  1. DELETE FROM Person WHERE id = self.person_id
  2. Emit signal: person_removed(self.person_id)
     â†“
Views update:
  - TreeView removes PersonBox
  - TableView removes row
  - MainWindow enables Redo
```

#### Interaction Example: Dragging a Person Box

Demonstrates how GUI operations are also commands:

**Step 1: User Drags Person Box**
```
User action: Click and drag PersonBox in TreeView
  â†“
views/tree_view/person_box.py:
  mousePressEvent()  - Record start position
  mouseMoveEvent()   - Update position in real-time
  mouseReleaseEvent() - Finalize position
```

**Step 2: Create Move Command**
```
views/tree_view/person_box.py:
  mouseReleaseEvent():
    old_pos = self.start_position
    new_pos = self.pos()
    â†“
Creates: MovePersonCommand(
           person_id=self.person_id,
           old_x=old_pos.x(), old_y=old_pos.y(),
           new_x=new_pos.x(), new_y=new_pos.y()
         )
    â†“
Executes via: undo_manager.execute(command)
```

**Step 3: Command Persists Position**
```
commands/gui_commands/move_person.py:
  run():
    1. UPDATE PersonPosition
       SET x_position=new_x, y_position=new_y
       WHERE person_id=self.person_id
    2. db.mark_dirty()
    3. (Visual position already updated during drag)
```

**Step 4: Undo Restores Position**
```
User presses: Ctrl+Z
  â†“
MovePersonCommand.undo():
  1. UPDATE PersonPosition
     SET x_position=old_x, y_position=old_y
  2. Emit signal: person_position_changed(person_id)
     â†“
TreeView.on_person_position_changed():
  - Animates PersonBox back to original position
```

#### Data Flow Patterns

**Read Operations (No Commands Needed)**
```
View needs data:
  1. View calls: db_manager.query(...)
  2. Database returns: list[Person] or Person object
  3. View creates widgets to display data
  4. No undo/redo needed (read-only)
```

**Write Operations (Via Commands)**
```
Modification needed:
  1. Create command object
  2. Execute via undo_manager.execute(command)
  3. Command.run() modifies database
  4. Command pushed to undo stack
  5. Views notified via signals
  6. All commands are undoable
```

**Multi-View Synchronization**
```
Data changes in one view:
  1. Command modifies database
  2. Command emits Qt signal
  3. All views listening to that signal update
  4. Example signals:
     - person_added(person_id)
     - person_modified(person_id)
     - person_deleted(person_id)
     - marriage_created(marriage_id)
     - etc.
```

#### Why This Pattern Works

**Separation of Concerns**
- Model knows nothing about views
- Views know nothing about business logic
- Commands encapsulate all business logic
- Easy to test each layer independently

**Undo/Redo Everything**
- UI changes (drag person box) â†’ MovePersonCommand
- Data changes (add person) â†’ AddPersonCommand
- Bulk operations (CSV import) â†’ ImportCSVCommand
- Settings changes â†’ ChangeSettingCommand
- All operations are undoable by design

**Multiple Views Without Coupling**
- TreeView, TimelineView, TableView, StatsView all observe the same data
- Any view can trigger commands
- All views automatically update via signals
- Views never directly call each other

**Scalability**
- New operation? Create new command class
- New view? Create new widget and connect signals
- New feature? Add to appropriate layer
- No changes to existing code structure

**Qt Integration**
- Signals/slots provide automatic observer pattern
- QGraphicsView provides scene/view separation
- QAbstractTableModel for table views
- Qt's undo framework could be integrated later

---

## Database Schema

### Complete Schema (All Phases)

All tables are created from the start to ensure consistency. Dates support flexible precision: year only, year/month, or full year/month/day. Any component can be NULL.

**Migration**: Existing `.dyn` files can be safely upgraded using `scripts/migrate_database.py`

---

#### Person Table
```sql
CREATE TABLE Person (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    maiden_name TEXT,
    gender TEXT,
    -- Birth date (flexible: year, year/month, or year/month/day)
    birth_year INTEGER,
    birth_month INTEGER,
    birth_day INTEGER,
    -- Death date (flexible precision)
    death_year INTEGER,
    death_month INTEGER,
    death_day INTEGER,
    -- Arrival date (when moved into town/game)
    arrival_year INTEGER,
    arrival_month INTEGER,
    arrival_day INTEGER,
    -- Move-out date (when left town/game)
    moved_out_year INTEGER,
    moved_out_month INTEGER,
    moved_out_day INTEGER,
    -- Relationships
    father_id INTEGER,
    mother_id INTEGER,
    family_id INTEGER,
    notes TEXT,
    FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
    FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
    FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
);
```

**Features**:
- Flexible date precision (all day fields can be NULL for Ostriv, populated for real-world genealogy)
- Maiden name tracking for married individuals
- Family dynasty grouping via `family_id`
- General notes field for additional context

---

#### Event Table
```sql
CREATE TABLE Event (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    person_id INTEGER NOT NULL,
    event_type TEXT NOT NULL,
    event_title TEXT NOT NULL,
    -- Start date (flexible precision)
    start_year INTEGER,
    start_month INTEGER,
    start_day INTEGER,
    -- End date (for ongoing events like jobs)
    end_year INTEGER,
    end_month INTEGER,
    end_day INTEGER,
    notes TEXT,
    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
);
```

**Event Types**: `job`, `illness`, `injury`, `residence`, `education`, `military`, `custom`

**Features**:
- Support for both point-in-time events (marriage, birth) and duration events (job, illness)
- Flexible date precision for all historical contexts

---

#### Marriage Table
```sql
CREATE TABLE Marriage (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    spouse1_id INTEGER,
    spouse2_id INTEGER,
    -- Marriage date (flexible precision)
    marriage_year INTEGER,
    marriage_month INTEGER,
    marriage_day INTEGER,
    -- Dissolution date (divorce/death)
    dissolution_year INTEGER,
    dissolution_month INTEGER,
    dissolution_day INTEGER,
    dissolution_reason TEXT,
    marriage_type TEXT DEFAULT 'spouse',  -- 'spouse', 'concubine', 'affair'
    FOREIGN KEY(spouse1_id) REFERENCES Person(id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    FOREIGN KEY(spouse2_id) REFERENCES Person(id)
        ON UPDATE CASCADE ON DELETE SET NULL
);
```

**Features**:
- Support for multiple marriage types (spouse, concubine, affair for games like Crusader Kings)
- Track dissolution reason (death, divorce, annulment)
- Flexible date precision
- Cascade updates for person ID changes
- Preserve marriage records even if persons are deleted (SET NULL)

---

#### Portrait Table
```sql
CREATE TABLE Portrait (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    person_id INTEGER NOT NULL,
    image_path TEXT NOT NULL,
    -- Date range when this portrait is valid (flexible precision)
    valid_from_year INTEGER,
    valid_from_month INTEGER,
    valid_from_day INTEGER,
    valid_to_year INTEGER,
    valid_to_month INTEGER,
    valid_to_day INTEGER,
    is_primary INTEGER DEFAULT 0,
    display_order INTEGER DEFAULT 0,
    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
);
```

**Features**:
- Multiple portraits per person
- Date-based portrait switching (e.g., "looked like this from 1705-1720")
- Cycle through portraits automatically or manually
- Primary portrait designation
- Display order for galleries

---

#### Family Table
```sql
CREATE TABLE Family (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    surname TEXT NOT NULL,
    -- Move-in date (when family arrived)
    move_in_year INTEGER,
    move_in_month INTEGER,
    move_in_day INTEGER,
    coat_of_arms_path TEXT,
    family_color TEXT,  -- RGB hex code for visualization
    is_extinct INTEGER DEFAULT 0,
    notes TEXT
);
```

**Purpose**: Group people by family dynasty (not just surname), track move-in dates, extinction status

**Note**: Multiple families can share the same surname if they moved in separately

**Features**:
- Coat of arms/family image support
- Color-coding for visual identification
- Extinction tracking

---

#### MajorEvent Table
```sql
CREATE TABLE MajorEvent (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_name TEXT NOT NULL,
    event_type TEXT NOT NULL,  -- 'war', 'disaster', 'plague', 'festival', etc.
    -- Start date (year required, month/day optional)
    start_year INTEGER NOT NULL,
    start_month INTEGER,
    start_day INTEGER,
    -- End date (for ongoing events like wars)
    end_year INTEGER,
    end_month INTEGER,
    end_day INTEGER,
    description TEXT,
    color TEXT  -- For timeline visualization
);
```

**Purpose**: Historical context markers displayed across all families in timeline view

**Examples**: World War 1, Great Plague of 1665, Town Fire of 1720

**Features**:
- Flexible date precision
- Support for both point events and duration events
- Color-coding for visual distinction in timeline

---

#### PersonPosition Table
```sql
CREATE TABLE PersonPosition (
    person_id INTEGER PRIMARY KEY,
    view_type TEXT NOT NULL,  -- 'tree', 'custom'
    x_position REAL NOT NULL,
    y_position REAL NOT NULL,
    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
);
```

**Purpose**: Store custom positions when user drags person boxes in tree view

**Features**:
- Per-person custom positioning
- Automatic layout as fallback if no custom position
- View-type support for future multiple tree layouts

---

#### Settings Table
```sql
CREATE TABLE Settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);
```

**Purpose**: Store user preferences and application settings

**Example Settings**:
- `date_format` â†’ "YYYY-MM-DD", "DD/MM/YYYY", etc.
- `auto_surname_change` â†’ "true", "false"
- `surname_inheritance` â†’ "paternal", "maternal", "choice"
- `default_skin` â†’ "default", "parchment", "blueprint"
- `auto_save_interval` â†’ "300" (seconds)

---

### Date Flexibility Design

All date fields follow the pattern: `year`, `month`, `day`

**Ostriv Usage** (no day precision):
- `birth_year = 1705, birth_month = 3, birth_day = NULL`
- Display: "March 1705"

**Real-World Genealogy** (full precision):
- `birth_year = 1705, birth_month = 3, birth_day = 15`
- Display: "March 15, 1705" or "15/03/1705"

**Unknown Month** (year only):
- `birth_year = 1705, birth_month = NULL, birth_day = NULL`
- Display: "1705"

This design supports seamless transitions between game contexts and real-world use.

---

## Directory Structure

Complete file structure with implementation status:

```
DynastyVizualizer/
â”œâ”€â”€ main.py                              # Application entry point (222 lines) âœ…
â”‚
â”œâ”€â”€ database/                            # Data layer (Model)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ db_manager.py                   # SQLite CRUD operations (268 lines) âœ…
â”‚
â”œâ”€â”€ models/                              # Data model classes
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ person.py                       # Person with properties (68 lines) ğŸ“‹
â”‚   â”œâ”€â”€ marriage.py                     # Marriage relationship (41 lines) ğŸ“‹
â”‚   â”œâ”€â”€ event.py                        # Life events (41 lines) ğŸ“‹
â”‚   â”œâ”€â”€ portrait.py                     # Portrait metadata (30 lines) ğŸ“‹
â”‚   â”œâ”€â”€ family.py                       # Family dynasty (35 lines) ğŸ“‹
â”‚   â””â”€â”€ major_event.py                  # Historical events (30 lines) ğŸ“‹
â”‚
â”œâ”€â”€ actions/                             # Menu action handlers (Controllers)
â”‚   â”œâ”€â”€ __init__.py                     # (6 lines) âœ…
â”‚   â”œâ”€â”€ file_actions.py                 # New/Open/Save/Exit (159 lines) âœ…
â”‚   â”œâ”€â”€ edit_actions.py                 # Undo/Redo/Add/Remove (29 lines) âœ…
â”‚   â”œâ”€â”€ view_actions.py                 # View switching (22 lines) âœ…
â”‚   â”œâ”€â”€ tools_actions.py                # Validation tools (22 lines) âœ…
â”‚   â””â”€â”€ help_actions.py                 # About dialog (10 lines) âœ…
â”‚
â”œâ”€â”€ commands/                            # Command pattern for undo/redo
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ undo_redo_manager.py            # Command manager (55 lines) âœ…
â”‚   â”œâ”€â”€ base_command.py                 # Base command class (13 lines) ğŸ“‹
â”‚   â”‚
â”‚   â”œâ”€â”€ genealogy commands/             # Genealogy operations [PHASE 2-3]
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ add_person.py               # Create new person (23 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ edit_person.py              # Modify person data (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ remove_person.py            # Delete person (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ add_marriage.py             # Create marriage (25 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ edit_marriage.py            # Modify marriage (25 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ end_marriage.py             # End marriage (30 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ delete_marriage.py          # Delete marriage (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ create_child.py             # Create with parents (30 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ add_event.py                # Add life event (23 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ edit_event.py               # Modify event (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ delete_event.py             # Delete event (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ assign_parent.py            # Set parent link (33 lines) ğŸ“‹
â”‚   â”‚   â””â”€â”€ unassign_parent.py          # Remove parent link (31 lines) ğŸ“‹
â”‚   â”‚
â”‚   â””â”€â”€ GUI commands/                   # GUI operations [PHASE 3-5]
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ move_person.py              # Drag-and-drop (28 lines) ğŸ“‹
â”‚       â”œâ”€â”€ rebuild_scene.py            # Rebuild view (25 lines) ğŸ“‹
â”‚       â”œâ”€â”€ recompute_generations.py    # Recalc generations (26 lines) ğŸ“‹
â”‚       â”œâ”€â”€ change_skin.py              # Switch theme (26 lines) ğŸ“‹
â”‚       â””â”€â”€ change_view.py              # Switch view mode (27 lines) ğŸ“‹
â”‚
â”œâ”€â”€ views/                               # Visualization layer (Views)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_table.py                   # (placeholder)
â”‚   â”œâ”€â”€ dynasty_view.py                 # (placeholder)
â”‚   â”œâ”€â”€ timeline_view.py                # (placeholder)
â”‚   â”‚
â”‚   â”œâ”€â”€ tree_view/                      # Family tree visualization [PHASE 3]
â”‚   â”‚   â”œâ”€â”€ __init__.py                 # ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ tree_canvas.py              # Main canvas (25 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ person_box.py               # Person widget (38 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ marriage_node.py            # Marriage connector (20 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ relationship_line.py        # Parent-child lines (27 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ layout_engine.py            # Auto-positioning (20 lines) ğŸ“‹
â”‚   â”‚   â””â”€â”€ generation_band.py          # Gen markers (25 lines) ğŸ“‹
â”‚   â”‚
â”‚   â”œâ”€â”€ timeline_view/                  # Timeline visualization [PHASE 5]
â”‚   â”‚   â”œâ”€â”€ timeline_canvas.py          # Timeline canvas (25 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ family_bar.py               # Family lifespan (24 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ person_bar.py               # Person lifespan (27 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ event_marker.py             # Event icons (20 lines) ğŸ“‹
â”‚   â”‚   â””â”€â”€ major_event_marker.py       # Historical events (20 lines) ğŸ“‹
â”‚   â”‚
â”‚   â”œâ”€â”€ table_view/                     # Database tables [PHASE 6]
â”‚   â”‚   â”œâ”€â”€ person_table.py             # People table (28 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ marriage_table.py           # Marriages table (28 lines) ğŸ“‹
â”‚   â”‚   â”œâ”€â”€ event_table.py              # Events table (28 lines) ğŸ“‹
â”‚   â”‚   â””â”€â”€ family_table.py             # Families table (26 lines) ğŸ“‹
â”‚   â”‚
â”‚   â””â”€â”€ stats_view/                     # Statistics [PHASE 7]
â”‚       â”œâ”€â”€ family_dashboard.py         # Stats dashboard (25 lines) ğŸ“‹
â”‚       â”œâ”€â”€ comparison_widget.py        # Compare entities (25 lines) ğŸ“‹
â”‚       â””â”€â”€ charts.py                   # Visual charts (24 lines) ğŸ“‹
â”‚
â”œâ”€â”€ widgets/                             # Reusable UI components
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ date_picker.py                  # Date input widget (20 lines) ğŸ“‹
â”‚   â”œâ”€â”€ person_selector.py              # Person dropdown (20 lines) ğŸ“‹
â”‚   â”œâ”€â”€ portrait_gallery.py             # Portrait display (24 lines) ğŸ“‹
â”‚   â”œâ”€â”€ extended_details_panel.py       # Detail panel (30 lines) ğŸ“‹
â”‚   â””â”€â”€ search_bar.py                   # Search widget (26 lines) ğŸ“‹
â”‚
â”œâ”€â”€ dialogs/                             # Modal dialogs
â”‚   â”œâ”€â”€ __init__.py                     # ğŸ“‹
â”‚   â”œâ”€â”€ add_person_dialog.py            # Add person form (18 lines) ğŸ“‹
â”‚   â”œâ”€â”€ edit_person_dialog.py           # Edit person form (18 lines) ğŸ“‹
â”‚   â”œâ”€â”€ create_marriage_dialog.py       # Marriage form (19 lines) ğŸ“‹
â”‚   â”œâ”€â”€ create_child_dialog.py          # Child form (20 lines) ğŸ“‹
â”‚   â”œâ”€â”€ add_event_dialog.py             # Event form (21 lines) ğŸ“‹
â”‚   â”œâ”€â”€ preferences_dialog.py           # Settings dialog (20 lines) ğŸ“‹
â”‚   â”œâ”€â”€ import_csv_dialog.py            # CSV import (22 lines) ğŸ“‹
â”‚   â””â”€â”€ about_dialog.py                 # About dialog (13 lines) ğŸ“‹
â”‚
â”œâ”€â”€ utils/                               # Utility modules
â”‚   â”œâ”€â”€ __init__.py                     # ğŸ“‹
â”‚   â”œâ”€â”€ relationship_calculator.py      # Relationship logic (20 lines) ğŸ“‹
â”‚   â”œâ”€â”€ generation_calculator.py        # Generation levels (16 lines) ğŸ“‹
â”‚   â”œâ”€â”€ validators.py                   # Data validation (28 lines) ğŸ“‹
â”‚   â”œâ”€â”€ csv_importer.py                 # CSV import (36 lines) ğŸ“‹
â”‚   â”œâ”€â”€ skin_manager.py                 # Theme management (32 lines) ğŸ“‹
â”‚   â””â”€â”€ color_manager.py                # Color utilities (33 lines) ğŸ“‹
â”‚
â”œâ”€â”€ resources/                           # Assets [PHASE 8]
â”‚   â”œâ”€â”€ skins/                          # UI themes
â”‚   â”œâ”€â”€ icons/                          # App icons
â”‚   â””â”€â”€ default_portraits/              # Portrait placeholders
â”‚
â”œâ”€â”€ scripts/                             # Development tools
â”‚   â”œâ”€â”€ create_codebase_summary.py      # Code snapshot tool âœ…
â”‚   â””â”€â”€ migrate_database.py             # Database migration âœ…
â”‚
â”œâ”€â”€ CODEBASE_SUMMARY.md                 # This file âœ…
â”œâ”€â”€ README.md                           # User documentation âœ…
â”œâ”€â”€ requirements.txt                    # Python dependencies âœ…
â””â”€â”€ LICENSE                             # MIT License âœ…

Legend:
  âœ… = Fully implemented
  ğŸ“‹ = Scaffolded (class structure, docstrings, TODOs)
  [PHASE X] = Target implementation phase
```

### File Count Summary

**By Status:**
- âœ… Implemented: 9 files (main.py, database, actions, undo_redo_manager)
- ğŸ“‹ Scaffolded: 93 files (models, commands, views, widgets, dialogs, utils)
- Total Python files: 102

**By Category:**
- Core: 1 (main.py)
- Database: 1 (db_manager.py)
- Models: 6 (person, marriage, event, portrait, family, major_event)
- Actions: 5 (file, edit, view, tools, help)
- Commands: 20 (base + 13 genealogy + 5 GUI + undo_redo_manager)
- Views: 22 (tree: 6, timeline: 5, table: 4, stats: 3, other: 4)
- Widgets: 5 (date_picker, person_selector, portrait_gallery, extended_details, search_bar)
- Dialogs: 8 (add_person, edit_person, create_marriage, create_child, add_event, preferences, import_csv, about)
- Utils: 6 (relationship_calculator, generation_calculator, validators, csv_importer, skin_manager, color_manager)
- Scripts: 2 (create_codebase_summary, migrate_database)
- Documentation: 3 (CODEBASE_SUMMARY, README, LICENSE)

### Implementation Checklist

Use this checklist to track development progress:

**Phase 1: Foundation** (~60% complete)
- [x] Main window and menu structure
- [x] Database schema and management
- [x] File operations (New/Open/Save)
- [x] Undo/redo infrastructure
- [ ] Basic dialogs (Add Person, About)
- [ ] Error handling and user feedback

**Phase 2: Models & CRUD** (0% complete)
- [ ] Implement Person model (6 properties)
- [ ] Implement Marriage model (4 properties)
- [ ] Implement Event model (5 properties)
- [ ] Implement Portrait model (4 properties)
- [ ] Implement Family model (4 properties)
- [ ] Implement MajorEvent model (5 properties)
- [ ] Implement AddPersonCommand
- [ ] Implement EditPersonCommand
- [ ] Implement RemovePersonCommand
- [ ] Implement AddMarriageCommand
- [ ] Implement AddPersonDialog (13 fields)
- [ ] Implement EditPersonDialog
- [ ] Implement DatePicker widget
- [ ] Implement PersonSelector widget

**Phase 3: Tree Visualization** (0% complete)
- [ ] Implement PersonBox widget
- [ ] Implement MarriageNode widget
- [ ] Implement RelationshipLine widget
- [ ] Implement TreeLayoutEngine
- [ ] Implement TreeCanvas
- [ ] Implement GenerationBand
- [ ] Implement MovePersonCommand
- [ ] Implement ExtendedDetailsPanel

**Phases 4-9:** See roadmap section for detailed breakdown

---

## Development Roadmap

### ğŸš§ **Phase 1: Foundation** (CURRENT - Weeks 1-2)
**Status**: ~60% Complete
**Lines**: ~850

Core infrastructure for database management, undo/redo, and application framework.

**Completed:**
- [x] Main application window and menu structure
- [x] Comprehensive database schema (all 8 tables with flexible dates)
- [x] SQLite database management (`.dyn` format with migration support)
- [x] File operations (New, Open, Save, Save As, Exit) - fully functional
- [x] Undo/redo infrastructure (Command pattern framework)
- [x] Action handler framework (scaffolded)
- [x] Project scaffolding

**In Progress:**
- [ ] Edit menu functionality (Add Person, Remove Person dialogs)
- [ ] View menu functionality (placeholder stubs)
- [ ] Tools menu functionality (placeholder stubs)
- [ ] Help menu functionality (About dialog)
- [ ] Basic error dialogs and user feedback
- [ ] Application icon and branding

**Key Files**: `main.py`, `database/db_manager.py`, `actions/file_actions.py`, `commands/undo_redo_manager.py`

**Next Steps**: Complete remaining menu items, add basic dialogs, implement About dialog

---

### ğŸ“‹ **Phase 2: Data Models & Basic CRUD** (Weeks 2-5)
**Status**: Not Started
**Estimated Lines**: +1,200

Build data models and basic create/read/update/delete operations with dialogs.

**Goals:**
- [ ] Implement `Person`, `Marriage`, `Event` model classes
- [ ] Create `AddPersonCommand`, `EditPersonCommand`, `DeletePersonCommand`
- [ ] Create `AddPersonDialog`, `EditPersonDialog` with full validation
- [ ] Build `CreateMarriageCommand`, `CreateChildCommand`
- [ ] Build `CreateMarriageDialog`
- [ ] Implement flexible date handling widget (year/month/day with nulls)
- [ ] Add portrait support (`Portrait` model + upload functionality)
- [ ] Create `DatePicker` widget (supports partial dates)
- [ ] Create `PersonSelector` widget (searchable dropdown)
- [ ] Implement basic list view to display people

**Deliverable**: Can add, edit, and delete people and marriages through functional dialogs

**Key Files**: `models/`, `commands/genealogy_commands/`, `dialogs/`, `widgets/date_picker.py`

---

### ğŸ“‹ **Phase 3: Tree Visualization** (Weeks 6-10)
**Status**: Not Started
**Estimated Lines**: +2,500

Build the interactive family tree view with QGraphicsView and custom widgets.

**Goals:**
- [ ] Create `PersonBox` custom QGraphicsWidget (portrait + name + dates + gear icon)
- [ ] Create `MarriageNode` widget (connection point + dates)
- [ ] Create `RelationshipLine` widget (parent-child connectors using QPainterPath)
- [ ] Implement `TreeLayoutEngine` (automatic generational positioning algorithm)
- [ ] Build `TreeCanvas` (QGraphicsView with scrollable, zoomable scene)
- [ ] Implement generation bands with labels
- [ ] Add drag-and-drop for creating marriages (drop person on person)
- [ ] Add drag-and-drop for repositioning person boxes
- [ ] Implement `MovePersonCommand` (undoable position changes)
- [ ] Add in-place editing (click name/date to edit)
- [ ] Implement gear icon â†’ extended details panel
- [ ] Build `ExtendedDetailsPanel` (tabbed: Info, Events, Relationships, Portraits)
- [ ] Add right-click context menus

**Deliverable**: Fully interactive family tree with draggable people, marriages, and visual hierarchy

**Key Files**: `views/tree_view/`, `widgets/extended_details_panel.py`, `commands/gui_commands/move_person.py`

---

### ğŸš§ **Phase 4: Relationship Analysis** (Week 11-13)
**Status**: Not Started
**Estimated Lines**: +800

Implement relationship tracing and highlighting.

**Goals:**
- [ ] Create `RelationshipCalculator` utility (graph traversal)
- [ ] Single-click selection highlights immediate family (parents, spouses, children)
- [ ] Double-click sets person as "primary" and labels all relationships
  - Brother, Sister, Father, Mother, Spouse, Ex-Spouse
  - Grandfather, Grandmother, Uncle, Aunt, Cousin
  - Step-parent, Step-sibling, Half-sibling
  - "1st removed", "2nd removed" for distant relatives
- [ ] Ctrl+Click two people to find relationship path
  - Highlight path with gradient (green â†’ yellow â†’ red by distance)
  - Show relationship description in popup
  - Dim unrelated people
- [ ] Implement search bar with real-time pruning
  - Type name â†’ filter tree to matching people + connections
  - Highlight matches
  - Auto-scroll to first match

**Deliverable**: Visual relationship exploration and tracing

**Key Files**: `utils/relationship_calculator.py`, `views/tree_view/tree_canvas.py`, `widgets/search_bar.py`

---

### ğŸš§ **Phase 5: Timeline View** (Week 14-17)
**Status**: Not Started
**Estimated Lines**: +1,800

Build chronological timeline visualization with family lifespans.

**Goals:**
- [ ] Create `TimelineCanvas` (horizontal scrolling timeline)
- [ ] Create `FamilyBar` widget (collapsible family lifespan)
  - Show family move-in â†’ extinction dates
  - Chevron to expand/collapse members
  - Sticky header while scrolling through family
- [ ] Create `PersonBar` widget (individual lifespan bar)
  - Birth â†’ death (or current date)
  - Portrait thumbnail
  - Event markers on bar (marriage, children, job changes, etc.)
- [ ] Create `EventMarker` widget (clickable icons on person bars)
- [ ] Create `MajorEventMarker` widget (vertical line across all families)
- [ ] Implement `Family` model and database table
- [ ] Implement `MajorEvent` model and database table
- [ ] Add "Add Major Event" dialog
- [ ] Implement sticky header logic (pin family bar, bump on scroll past)

**Deliverable**: Timeline view showing family lifespans and events

**Key Files**: `views/timeline_view/`, `models/family.py`, `models/major_event.py`

---

### ğŸš§ **Phase 6: Table View & Data Management** (Week 18-20)
**Status**: Not Started
**Estimated Lines**: +900

Build database table views for spreadsheet-style editing.

**Goals:**
- [ ] Create `PersonTableWidget` (sortable, filterable, editable)
- [ ] Create `MarriageTableWidget`
- [ ] Create `EventTableWidget`
- [ ] Create `FamilyTableWidget` (with computed statistics)
- [ ] Add warning dialog on first open ("editing raw data")
- [ ] Implement `EditCellCommand` (undoable table edits)
- [ ] Add computed fields to Family table:
  - Member count (living/total)
  - Longest lived member
  - Most children (father/mother separately)
- [ ] Build CSV import functionality
  - Flexible date format detection (YYYY-MM-DD, MM-DD-YYYY, etc.)
  - Column mapping dialog
  - Validation and error preview
  - Bulk `ImportPersonsCommand`

**Deliverable**: Spreadsheet-style data editing and CSV import

**Key Files**: `views/table_view/`, `dialogs/import_csv_dialog.py`, `utils/csv_importer.py`

---

### ğŸš§ **Phase 7: Statistics & Analytics** (Week 21-23)
**Status**: Not Started
**Estimated Lines**: +1,100

Build family statistics dashboard and comparison tools.

**Goals:**
- [ ] Create `FamilyDashboard` widget with cards showing:
  - Total families, living persons, deceased persons
  - Average lifespan
  - Largest family, most marriages, most children
  - Current generation count
- [ ] Add charts (using matplotlib or Qt Charts):
  - Population over time (line chart)
  - Deaths per year (bar chart)
  - Family size distribution (pie chart)
- [ ] Build family comparison tool (Ctrl+Click families)
  - Side-by-side statistics
  - Intermarriage count (connections between families)
  - Shared ancestors
- [ ] Implement data validation tools:
  - `MarriageValidator` (overlapping marriages, invalid dates)
  - `ParentageValidator` (circular parentage, impossible dates)
  - Validation report with clickable issues
- [ ] Implement `GenerationCalculator` utility
  - Recompute generations from founders (BFS algorithm)
  - Handle edge cases (adoptions, remarriages)

**Deliverable**: Statistics dashboard and data validation tools

**Key Files**: `views/stats_view/`, `utils/validators.py`, `utils/generation_calculator.py`

---

### ğŸš§ **Phase 8: Visual Customization** (Week 24-26)
**Status**: Not Started
**Estimated Lines**: +1,200

Implement UI skins, portrait management, and family color coding.

**Goals:**
- [ ] Create `SkinManager` class (load skins from JSON)
- [ ] Build built-in skins:
  - Default (clean, modern)
  - Parchment (aged paper aesthetic)
  - Blueprint (technical drawing style)
  - Medieval (illuminated manuscript)
- [ ] Add skin selector to preferences
- [ ] Support user custom skins (import skin folder)
- [ ] Implement `PortraitGallery` widget
  - Display multiple portraits per person
  - Add/edit/delete portraits
  - Set date ranges for portraits (valid from â†’ valid to)
  - Auto-cycle or manual selection
- [ ] Build portrait import workflow
  - Copy images to `/portraits/` subdirectory
  - Support PNG, JPG, GIF formats
  - Thumbnail generation
- [ ] Implement family color coding (optional feature)
  - **Option A**: Mixed colors (genetic blending)
  - **Option B**: Striped patterns (proportional stripes)
  - **Option C**: Relationship gradient (green=close, red=distant)
  - Toggle in preferences (default: off)

**Deliverable**: Themeable UI and comprehensive portrait management

**Key Files**: `utils/skin_manager.py`, `utils/color_manager.py`, `widgets/portrait_gallery.py`, `resources/skins/`

---

### ğŸš§ **Phase 9: Polish & Advanced Features** (Week 27-30)
**Status**: Not Started
**Estimated Lines**: +800

Final polish, preferences, keyboard shortcuts, and quality-of-life features.

**Goals:**
- [ ] Build `PreferencesDialog` with tabs:
  - General (date format, auto-save interval, confirmations)
  - Display (skin, font size, color scheme)
  - Behavior (surname change rules, portrait auto-cycle)
  - Advanced (validation strictness, close relative marriages)
- [ ] Implement keyboard shortcuts:
  - Ctrl+N/O/S (File operations)
  - Ctrl+Z/Y (Undo/Redo)
  - Ctrl+F (Search), Ctrl+P (Add Person), Del (Delete)
  - Ctrl+1/2/3/4 (Switch views)
  - Ctrl+Plus/Minus/0 (Zoom)
- [ ] Add comprehensive right-click context menus
- [ ] Build `AboutDialog` with credits and version info
- [ ] Implement export functionality:
  - Export tree view as PNG/JPG
  - Export entire tree (not just viewport)
  - Resolution multiplier (1x, 2x, 4x)
  - Optional: PDF export (multi-page)
- [ ] Create first-run tutorial/welcome dialog
- [ ] Add sample dynasty database (pre-populated example)
- [ ] Implement auto-save with configurable interval
- [ ] Add keyboard shortcut reference (Help menu)

**Deliverable**: Polished, production-ready application

**Key Files**: `dialogs/preferences_dialog.py`, `dialogs/about_dialog.py`, `utils/export_manager.py`

---

### ğŸ“‹ **Phase 10: Future Enhancements** (Post-Release)

**Potential Features:**
- [ ] Multi-dynasty support (tabs for multiple open files)
- [ ] Cloud sync and sharing
- [ ] Collaboration features (concurrent editing)
- [ ] Game-specific integrations:
  - Ostriv save file import
  - Crusader Kings 3 save file import
  - Support for titles, claims, traits (CK3)
- [ ] Mobile version (touch-optimized)
- [ ] Advanced genealogy features:
  - DNA inheritance simulation
  - Genetic trait tracking
  - Ancestry composition
- [ ] Research log and citations
- [ ] Media attachments (documents, certificates)

---

## Current Implementation Details

### Implemented Components (Phase 1 Complete)

#### 1. **main.py** (222 lines) âœ…
**Responsibilities**:
- Initialize PySide6 QMainWindow
- Create menu bar (File, Edit, View, Tools, Help)
- Manage database and undo/redo managers
- Connect menu actions to handlers
- Update UI state based on database/undo stack status

**Key Methods**:
- `_create_menus()` - Builds all menu structures
- `_connect_actions()` - Links menu items to action handlers
- `_update_menu_states()` - Enable/disable menus based on app state
- `refresh_ui()` - Public method to refresh title and menu states

#### 2. **database/db_manager.py** (193 lines) âœ…
**Responsibilities**:
- Manage SQLite connections to `.dyn` files
- Create new databases with schema initialization
- Open existing dynasty files
- Save/commit changes to disk
- Track dirty state (unsaved changes)

**Key Methods**:
- `new_database(file_path: str)` - Create fresh `.dyn` file
- `open_database(file_path: str)` - Open existing file
- `save_database(path: str | None)` - Save or "Save As"
- `mark_dirty()` / `mark_clean()` - Track unsaved changes

**Properties**:
- `is_open` - Check if database is loaded
- `is_dirty` - Check if there are unsaved changes
- `database_name` - Get filename without path
- `database_directory` - Get directory path

#### 3. **actions/file_actions.py** (159 lines) âœ…
**Responsibilities**:
- Handle File menu operations
- Show file dialogs (open/save)
- Error handling for file operations
- Prompt for unsaved changes on exit

**Key Methods**:
- `new_dynasty()` - Create new dynasty file
- `open_dynasty()` - Open existing file
- `save()` - Save current database
- `save_as()` - Save to new path
- `exit_app()` - Close application with unsaved check

#### 4. **actions/edit_actions.py** (29 lines) âš ï¸ Partial
**Implemented**:
- `undo()` - Undo last action
- `redo()` - Redo last undone action

**Scaffolded** (Phase 2):
- `add_person()` - TODO: Implement with dialog
- `remove_person()` - TODO: Implement with confirmation
- `add_new_family()` - TODO: Implement family creation

#### 5. **commands/undo_redo_manager.py** (55 lines) âœ…
**Responsibilities**:
- Implement Command pattern for undo/redo
- Maintain undo and redo stacks
- Execute commands and manage stack state

**Command Protocol**:
```python
class Command(Protocol):
    def run(self) -> None: ...
    def undo(self) -> None: ...
```

**Key Methods**:
- `execute(command: Command)` - Run command and add to undo stack
- `undo()` - Undo last command
- `redo()` - Redo last undone command
- `can_undo()` / `can_redo()` - Check stack availability

---

## Architecture Validation

### Is MVC + Command Still Appropriate?

**YES** - The architecture scales excellently for all planned features:

âœ… **Draggable UI**: `MovePersonCommand` makes position changes undoable
âœ… **Multiple Views**: Each view is a separate widget, no coupling
âœ… **Relationship Tracing**: Pure data operations in `RelationshipCalculator`
âœ… **Complex Operations**: Marriage creation, child creation = discrete commands
âœ… **Data Import**: `ImportCSVCommand` wraps bulk operations
âœ… **Preferences**: Settings changes = commands (undoable theme switches, etc.)

### Pattern Benefits for This Project

1. **Undo/Redo Everything**: UI changes, data changes, imports - all undoable
2. **View Independence**: Tree, Timeline, Table, Stats views all observe same models
3. **Testability**: Commands are isolated, testable units
4. **Extensibility**: Adding new operations = adding new command classes
5. **Qt Integration**: Signals/slots naturally fit observer pattern

---

## Development Best Practices

### When Adding New Features

1. **Model First**: Create data model class with properties
2. **Database Schema**: Add/update database tables
3. **Commands**: Create undoable command classes
4. **UI**: Build widgets/dialogs
5. **Integration**: Wire to menus/actions
6. **Test**: Verify undo/redo works

### File Reference Guide

Use these files as implementation templates:

- **Data Models**: (Phase 2 - to be created)
- **Commands**: `commands/undo_redo_manager.py` (protocol usage)
- **Action Handlers**: `actions/file_actions.py` (error handling, dialogs)
- **Database**: `database/db_manager.py` (property patterns, encapsulation)
- **Main Window**: `main.py` (action connections, UI updates)

---

## Dependencies

From `requirements.txt`:
- `PySide6==6.10.1` - Qt framework for Python
- `PySide6-Addons==6.10.1` - Additional Qt modules
- `PySide6-Essentials==6.10.1` - Core Qt functionality
- `QtPy==2.4.3` - Qt abstraction layer
- `shiboken6==6.10.1` - Python/C++ bindings

**Future Dependencies** (Phase 7-9):
- `matplotlib` or `pyqtgraph` - For statistics charts
- `Pillow` - For image processing (thumbnails, portraits)

---

## Quick Reference: Context Bundles

### For Architecture Discussion
Share:
1. This document (`CODEBASE_SUMMARY.md`)
2. `main.py` (first 100 lines for structure)
3. Database schema sections

### For Code Review
Share these implementation files:
1. `main.py` - Application structure
2. `database/db_manager.py` - Data layer
3. `actions/file_actions.py` - Example action handler
4. `commands/undo_redo_manager.py` - Command pattern

### For Standards Review
Share examples from each category:
1. `main.py` (lines 10-45)
2. `database/db_manager.py` (lines 6-48)
3. `commands/undo_redo_manager.py` (full file)

---

**Last Updated**: 2025-12-08
**Codebase Version**: 0.1.0-dev (Phase 1: ~60% Complete)
**Next Milestone**: Complete Phase 1 foundational menus and dialogs


======================================================================
IMPLEMENTATION CODE
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: main.py (251 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import sys

from PySide6.QtWidgets import QApplication, QMainWindow, QMenuBar
from PySide6.QtGui import QAction

from database.db_manager import DatabaseManager
from actions import FileActions, EditActions, ViewActions, ToolsActions, HelpActions, SettingsActions
from commands.undo_redo_manager import UndoRedoManager
from utils.settings_manager import SettingsManager

class MainWindow(QMainWindow):
    """Main application window for Dynasty Visualizer."""

    def __init__(self) -> None:
        """Initialize the main window and all UI components."""
        super().__init__()

        self.setWindowTitle("Dynasty Visualizer")
        self.resize(1000, 700)

        # Initialize database manager
        self.db = DatabaseManager(self)

        # Initialize undo/redo manager
        self.undo_manager = UndoRedoManager()

        # Initialize settings manager
        self.settings_manager = SettingsManager()

        # Create UI elements
        self._create_menus()

        # Initialize action handlers
        self.file_actions = FileActions(self)
        self.edit_actions = EditActions(self)
        self.view_actions = ViewActions(self)
        self.tools_actions = ToolsActions(self)
        self.settings_actions = SettingsActions(self)
        self.help_actions = HelpActions(self)

        # Connect menu actions to handlers
        self._connect_actions()

        # Update window title and menu states
        self._update_window_title()
        self._update_menu_states()

    # ------------------------------------------------------------------
    # UI Creation
    # ------------------------------------------------------------------

    def _create_menus(self) -> None:
        """Create all menu bars and menu items."""
        menubar = self.menuBar()

        self._create_file_menu(menubar)
        self._create_edit_menu(menubar)
        self._create_view_menu(menubar)
        self._create_tools_menu(menubar)
        self._create_settings_menu(menubar)
        self._create_help_menu(menubar)

    def _create_file_menu(self, menubar: QMenuBar) -> None:
        """Create the File menu with all file operations."""
        file_menu = menubar.addMenu("File")

        self.action_new_dynasty = QAction("New Dynasty", self)
        self.action_new_dynasty.setObjectName("file.new")
        self.action_new_dynasty.setShortcut(self.settings_manager.get_shortcut("file.new"))

        self.action_open_dynasty = QAction("Open Dynasty", self)
        self.action_open_dynasty.setObjectName("file.open")
        self.action_open_dynasty.setShortcut(self.settings_manager.get_shortcut("file.open"))

        self.action_save = QAction("Save", self)
        self.action_save.setObjectName("file.save")
        self.action_save.setShortcut(self.settings_manager.get_shortcut("file.save"))
        
        self.action_save_as = QAction("Save As", self)
        self.action_save_as.setObjectName("file.save_as")
        self.action_save_as.setShortcut(self.settings_manager.get_shortcut("file.save_as"))

        self.action_exit = QAction("Exit", self)
        self.action_exit.setObjectName("file.exit")
        self.action_exit.setShortcut(self.settings_manager.get_shortcut("file.exit"))

        file_menu.addAction(self.action_new_dynasty)
        file_menu.addAction(self.action_open_dynasty)
        file_menu.addSeparator()
        file_menu.addAction(self.action_save)
        file_menu.addAction(self.action_save_as)
        file_menu.addSeparator()
        file_menu.addAction(self.action_exit)

    def _create_edit_menu(self, menubar: QMenuBar) -> None:
        """Create the Edit menu with editing operations."""
        edit_menu = menubar.addMenu("Edit")

        self.action_undo = QAction("Undo", self)
        self.action_undo.setObjectName("edit.undo")
        self.action_undo.setShortcut(self.settings_manager.get_shortcut("edit.undo"))

        self.action_redo = QAction("Redo", self)
        self.action_redo.setObjectName("edit.redo")
        self.action_redo.setShortcut(self.settings_manager.get_shortcut("edit.redo"))
        
        self.action_add_person = QAction("Add Person", self)
        self.action_add_person.setObjectName("edit.add_person")
        self.action_add_person.setShortcut(self.settings_manager.get_shortcut("edit.add_person"))

        self.action_remove_person = QAction("Remove Person", self)
        self.action_remove_person.setObjectName("edit.remove_person")
        self.action_remove_person.setShortcut(self.settings_manager.get_shortcut("edit.remove_person"))

        self.action_add_new_family = QAction("Add New Family", self)
        self.action_add_new_family.setObjectName("edit.add_new_family")
        self.action_add_new_family.setShortcut(self.settings_manager.get_shortcut("edit.add_new_family"))

        edit_menu.addAction(self.action_undo)
        edit_menu.addAction(self.action_redo)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_person)
        edit_menu.addAction(self.action_remove_person)
        edit_menu.addAction(self.action_add_new_family)

    def _create_view_menu(self, menubar: QMenuBar) -> None:
        """Create the View menu with different visualization options."""
        view_menu = menubar.addMenu("View")

        self.action_view_family_trees = QAction("Family Trees", self)
        self.action_view_family_trees.setObjectName("view.family_trees")
        self.action_view_family_trees.setShortcut(self.settings_manager.get_shortcut("view.family_trees"))

        self.action_view_timeline = QAction("Timeline", self)
        self.action_view_timeline.setObjectName("view.timeline")
        self.action_view_timeline.setShortcut(self.settings_manager.get_shortcut("view.timeline"))
        
        self.action_view_dynasty = QAction("Dynasty", self)
        self.action_view_dynasty.setObjectName("view.dynasty")
        self.action_view_dynasty.setShortcut(self.settings_manager.get_shortcut("view.dynasty"))

        self.action_view_data_table = QAction("Data Table", self)
        self.action_view_data_table.setObjectName("view.data_table")
        self.action_view_data_table.setShortcut(self.settings_manager.get_shortcut("view.data_table"))

        view_menu.addAction(self.action_view_family_trees)
        view_menu.addAction(self.action_view_timeline)
        view_menu.addAction(self.action_view_dynasty)
        view_menu.addAction(self.action_view_data_table)

    def _create_tools_menu(self, menubar: QMenuBar) -> None:
        """Create the Tools menu with utility operations."""
        tools_menu = menubar.addMenu("Tools")

        self.action_rebuild_scene = QAction("Rebuild Scene", self)
        self.action_rebuild_scene.setObjectName("tools.rebuild_scene")
        self.action_rebuild_scene.setShortcut(self.settings_manager.get_shortcut("tools.rebuild_scene"))

        self.action_recompute_generations = QAction("Recompute Generations", self)
        self.action_recompute_generations.setObjectName("tools.recompute_generations")
        self.action_recompute_generations.setShortcut(self.settings_manager.get_shortcut("tools.recompute_generations"))
        
        self.action_validate_marriages = QAction("Validate Marriages", self)
        self.action_validate_marriages.setObjectName("tools.validate_marriages")
        self.action_validate_marriages.setShortcut(self.settings_manager.get_shortcut("tools.validate_marriages"))

        self.action_validate_parentage = QAction("Validate Parentage", self)
        self.action_validate_parentage.setObjectName("tools.validate_parentage")
        self.action_validate_parentage.setShortcut(self.settings_manager.get_shortcut("tools.validate_parentage"))

        tools_menu.addAction(self.action_rebuild_scene)
        tools_menu.addAction(self.action_recompute_generations)
        tools_menu.addAction(self.action_validate_marriages)
        tools_menu.addAction(self.action_validate_parentage)

    def _create_settings_menu(self, menubar: QMenuBar) -> None:
        """Create the settings menu with application options."""
        settings_menu = menubar.addMenu("Settings")

        self.action_settings = QAction("Settings", self)
        self.action_settings.setObjectName("settings.settings")
        self.action_settings.setShortcut(self.settings_manager.get_shortcut("settings.settings"))

        self.action_general = QAction("General", self)
        self.action_general.setObjectName("settings.general")
        self.action_general.setShortcut(self.settings_manager.get_shortcut("settings.general"))

        self.action_shortcuts = QAction("Shortcuts", self)
        self.action_shortcuts.setObjectName("settings.shortcuts")
        self.action_shortcuts.setShortcut(self.settings_manager.get_shortcut("settings.shortcuts"))

        self.action_display = QAction("Display", self)
        self.action_display.setObjectName("settings.display")
        self.action_display.setShortcut(self.settings_manager.get_shortcut("settings.display"))

        self.action_appearance = QAction("Appearance", self)
        self.action_appearance.setObjectName("settings.appearance")
        self.action_appearance.setShortcut(self.settings_manager.get_shortcut("settings.appearance"))

        self.action_formats = QAction("Formats", self)
        self.action_formats.setObjectName("settings.formats")
        self.action_formats.setShortcut(self.settings_manager.get_shortcut("settings.formats"))

        settings_menu.addAction(self.action_settings)
        settings_menu.addSeparator()
        settings_menu.addAction(self.action_general)
        settings_menu.addAction(self.action_shortcuts)
        settings_menu.addAction(self.action_display)
        settings_menu.addAction(self.action_appearance)
        settings_menu.addAction(self.action_formats)


    def _create_help_menu(self, menubar: QMenuBar) -> None:
        """Create the Help menu with application information."""
        help_menu = menubar.addMenu("Help")

        self.action_about = QAction("About", self)
        self.action_about.setObjectName("help.about")
        self.action_about.setShortcut(self.settings_manager.get_shortcut("help.about"))
        help_menu.addAction(self.action_about)

    # ------------------------------------------------------------------
    # Action Connections
    # ------------------------------------------------------------------

    def _connect_actions(self) -> None:
        """Connect all menu actions to their handler methods."""
        # File menu connections
        self.action_new_dynasty.triggered.connect(self.file_actions.new_dynasty)
        self.action_open_dynasty.triggered.connect(self.file_actions.open_dynasty)
        self.action_save.triggered.connect(self.file_actions.save)
        self.action_save_as.triggered.connect(self.file_actions.save_as)
        self.action_exit.triggered.connect(self.file_actions.exit_app)

        # Edit menu connections
        self.action_undo.triggered.connect(self.edit_actions.undo)
        self.action_redo.triggered.connect(self.edit_actions.redo)
        self.action_add_person.triggered.connect(self.edit_actions.add_person)
        self.action_remove_person.triggered.connect(self.edit_actions.remove_person)
        self.action_add_new_family.triggered.connect(self.edit_actions.add_new_family)

        # View menu connections
        self.action_view_family_trees.triggered.connect(self.view_actions.family_trees)
        self.action_view_timeline.triggered.connect(self.view_actions.timeline)
        self.action_view_dynasty.triggered.connect(self.view_actions.dynasty)
        self.action_view_data_table.triggered.connect(self.view_actions.data_table)

        # Tools menu connections
        self.action_rebuild_scene.triggered.connect(self.tools_actions.rebuild_scene)
        self.action_recompute_generations.triggered.connect(self.tools_actions.recompute_generations)
        self.action_validate_marriages.triggered.connect(self.tools_actions.validate_marriages)
        self.action_validate_parentage.triggered.connect(self.tools_actions.validate_parentage)

        # Settings menu connections
        self.action_settings.triggered.connect(self.settings_actions.settings)
        self.action_general.triggered.connect(self.settings_actions.general)
        self.action_shortcuts.triggered.connect(self.settings_actions.shortcuts)
        self.action_display.triggered.connect(self.settings_actions.display)
        self.action_appearance.triggered.connect(self.settings_actions.appearance)
        self.action_formats.triggered.connect(self.settings_actions.formats)

        # Help menu connections
        self.action_about.triggered.connect(self.help_actions.about)

    # ------------------------------------------------------------------
    # UI Update Methods
    # ------------------------------------------------------------------

    def _update_window_title(self) -> None:
        """Update the window title to reflect current database state."""
        if self.db.is_open:
            dirty_marker = " *" if self.db.is_dirty else ""
            self.setWindowTitle(f"Dynasty Visualizer - {self.db.database_name}{dirty_marker}")
        else:
            self.setWindowTitle("Dynasty Visualizer")

    def _update_menu_states(self) -> None:
        """Enable or disable menu items based on current state."""
        has_db = self.db.is_open

        # File menu states
        self.action_save.setEnabled(has_db and self.db.is_dirty)
        self.action_save_as.setEnabled(has_db)

        # Edit menu states (disable if no database open)
        self.action_undo.setEnabled(self.undo_manager.can_undo())
        self.action_redo.setEnabled(self.undo_manager.can_redo())
        self.action_add_person.setEnabled(has_db)
        self.action_remove_person.setEnabled(has_db)
        self.action_add_new_family.setEnabled(has_db)

        # View menu states
        self.action_view_family_trees.setEnabled(has_db)
        self.action_view_timeline.setEnabled(has_db)
        self.action_view_dynasty.setEnabled(has_db)
        self.action_view_data_table.setEnabled(has_db)

        # Tools menu states
        self.action_rebuild_scene.setEnabled(has_db)
        self.action_recompute_generations.setEnabled(has_db)
        self.action_validate_marriages.setEnabled(has_db)
        self.action_validate_parentage.setEnabled(has_db)

    # ------------------------------------------------------------------
    # Public Methods
    # ------------------------------------------------------------------

    def refresh_ui(self) -> None:
        """Refresh window title and menu states after database changes."""
        self._update_window_title()
        self._update_menu_states()


def main() -> None:
    """Application entry point."""
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: database/db_manager.py (253 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import sqlite3
import shutil
import os


class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the database manager."""
        self.parent = parent
        self.conn: sqlite3.Connection | None = None
        self.file_path: str | None = None
        self._unsaved_changes: bool = False

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def is_dirty(self) -> bool:
        """Check if there are unsaved changes."""
        return self._unsaved_changes

    @property
    def is_open(self) -> bool:
        """Check if a database is currently open."""
        return self.conn is not None

    @property
    def database_name(self) -> str | None:
        """Get the filename of the current database without path."""
        if self.file_path is None:
            return None
        return os.path.basename(self.file_path)

    @property
    def database_directory(self) -> str | None:
        """Get the directory path of the current database."""
        if self.file_path is None:
            return None
        return os.path.dirname(self.file_path)

    @property
    def has_file_path(self) -> bool:
        """Check if database has an associated file path."""
        return self.file_path is not None

    # ------------------------------------------------------------------
    # Public Methods - Database Lifecycle
    # ------------------------------------------------------------------

    def new_database(self, file_path: str) -> None:
        """Create a brand-new .dyn file with the dynasty schema."""
        if os.path.exists(file_path):
            os.remove(file_path)
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._initialize_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to create database: {e}")

    def open_database(self, file_path: str) -> None:
        """Open an existing .dyn database file."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} does not exist.")
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._migrate_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to open database: {e}")

    def save_database(self, path: str | None = None) -> bool:
        """
        Save the database, optionally to a new path.
        
        If path is provided, saves a copy to that location and switches to it.
        If path is None, commits changes to the current file.
        """
        if self.conn is None:
            return False
        
        # If no path provided, just commit current database
        if path is None:
            self.conn.commit()
            self._unsaved_changes = False
            return True
        
        # Save to new path (save_as behavior)
        if self.file_path is None:
            return False
        
        self.conn.commit()
        self.conn.close()
        
        # Copy database file to new location
        shutil.copy2(self.file_path, path)
        
        # Reopen connection at new path
        self.conn = sqlite3.connect(path)
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.file_path = path
        self._unsaved_changes = False
        return True
    
    def close(self) -> None:
        """Close the current database connection and reset state."""
        if self.conn:
            self.conn.close()
        self.conn = None
        self.file_path = None
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Public Methods - State Management
    # ------------------------------------------------------------------

    def mark_dirty(self) -> None:
        """Mark the database as having unsaved changes."""
        if self.conn is not None:
            self._unsaved_changes = True

    def mark_clean(self) -> None:
        """Mark the database as having no unsaved changes."""
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Private Methods
    # ------------------------------------------------------------------

    def _initialize_schema(self) -> None:
        """Create all required tables for a new dynasty database."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
        
        cursor = self.conn.cursor()

        schema_sql = """
        -- Person table: Core genealogical data
        -- Dates support flexible precision (year, year/month, or year/month/day)
        CREATE TABLE IF NOT EXISTS Person (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            middle_name TEXT DEFAULT '',
            last_name TEXT NOT NULL,
            maiden_name TEXT,
            nickname TEXT DEFAULT '',
            gender TEXT,
            birth_year INTEGER,
            birth_month INTEGER,
            birth_day INTEGER,
            death_year INTEGER,
            death_month INTEGER,
            death_day INTEGER,
            arrival_year INTEGER,
            arrival_month INTEGER,
            arrival_day INTEGER,
            moved_out_year INTEGER,
            moved_out_month INTEGER,
            moved_out_day INTEGER,
            father_id INTEGER,
            mother_id INTEGER,
            family_id INTEGER,
            dynasty_id INTEGER DEFAULT 1,
            is_founder INTEGER DEFAULT 0,
            education INTEGER DEFAULT 0,
            notes TEXT,
            FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
        );

        -- Event table: Life events (jobs, illnesses, moves, etc.)
        CREATE TABLE IF NOT EXISTS Event (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            event_title TEXT NOT NULL,
            start_year INTEGER,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            notes TEXT,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Marriage table: Relationships between people
        CREATE TABLE IF NOT EXISTS Marriage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            spouse1_id INTEGER,
            spouse2_id INTEGER,
            marriage_year INTEGER,
            marriage_month INTEGER,
            marriage_day INTEGER,
            dissolution_year INTEGER,
            dissolution_month INTEGER,
            dissolution_day INTEGER,
            dissolution_reason TEXT,
            marriage_type TEXT DEFAULT 'spouse',
            FOREIGN KEY(spouse1_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL,
            FOREIGN KEY(spouse2_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL
        );

        -- Portrait table: Multiple images per person with date ranges
        CREATE TABLE IF NOT EXISTS Portrait (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            image_path TEXT NOT NULL,
            valid_from_year INTEGER,
            valid_from_month INTEGER,
            valid_from_day INTEGER,
            valid_to_year INTEGER,
            valid_to_month INTEGER,
            valid_to_day INTEGER,
            is_primary INTEGER DEFAULT 0,
            display_order INTEGER DEFAULT 0,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        -- Family table: Dynasty/family groupings
        CREATE TABLE IF NOT EXISTS Family (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            surname TEXT NOT NULL,
            move_in_year INTEGER,
            move_in_month INTEGER,
            move_in_day INTEGER,
            coat_of_arms_path TEXT,
            family_color TEXT,
            is_extinct INTEGER DEFAULT 0,
            notes TEXT
        );

        -- MajorEvent table: Historical events affecting multiple families
        CREATE TABLE IF NOT EXISTS MajorEvent (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT NOT NULL,
            event_type TEXT NOT NULL,
            start_year INTEGER NOT NULL,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            description TEXT,
            color TEXT
        );

        -- PersonPosition table: Custom positions for draggable UI
        CREATE TABLE IF NOT EXISTS PersonPosition (
            person_id INTEGER PRIMARY KEY,
            view_type TEXT NOT NULL,
            x_position REAL NOT NULL,
            y_position REAL NOT NULL,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );
        """
        cursor.executescript(schema_sql)
        self.conn.commit()
    
    def _migrate_schema(self) -> None:
        """Migrate existing database schema to latest version."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
            
        cursor = self.conn.cursor()

        cursor.execute("PRAGMA table_info(Person)")
        existing_columns = {row[1] for row in cursor.fetchall()}

        migrations = [
            # Dec/10/2025 - Person Model updates
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
            ]
        for column_name, sql in migrations:
            if column_name not in existing_columns:
                cursor.execute(sql)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/__init__.py (7 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from .file_actions import FileActions
from .edit_actions import EditActions
from .view_actions import ViewActions
from .tools_actions import ToolsActions
from .help_actions import HelpActions
from .settings_actions import SettingsActions

__all__ = ['FileActions', 'EditActions', 'ViewActions', 'ToolsActions', 'HelpActions', 'SettingsActions']

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/file_actions.py (133 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from PySide6.QtWidgets import QFileDialog, QMessageBox


class FileActions:
    """Handles file menu actions (New, Open, Save, Exit)."""
    
    FILE_FILTER = "Dynasty Files (*.dyn)"
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize file actions handler."""
        self.parent = parent
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _ensure_db(self) -> bool:
        """Check if a database is currently open."""
        if not hasattr(self.parent, 'db') or not self.parent.db.is_open:
            self._show_error("Error", "No database is currently open.")
            return False
        return True
    
    def _get_save_path(self, title: str, default_name: str = "") -> str | None:
        """Show a save file dialog and return the chosen path."""
        default_path = ""
        if default_name:
            default_path = default_name
        elif self.parent.db.database_directory:
            default_path = self.parent.db.database_directory
        
        path, _ = QFileDialog.getSaveFileName(
            self.parent,
            title,
            default_path,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _get_open_path(self, title: str) -> str | None:
        """Show an open file dialog and return the chosen path."""
        default_dir = ""
        if self.parent.db.is_open and self.parent.db.database_directory:
            default_dir = self.parent.db.database_directory
        
        path, _ = QFileDialog.getOpenFileName(
            self.parent,
            title,
            default_dir,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _show_error(self, title: str, message: str) -> None:
        """Display an error message dialog."""
        QMessageBox.critical(self.parent, title, message)
    
    # ------------------------------------------------------------------
    # File Operations
    # ------------------------------------------------------------------
    
    def new_dynasty(self) -> None:
        """Prompt user to create a new dynasty database file."""
        path = self._get_save_path("Create New Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.new_database(path)
            self.parent.refresh_ui()
        except Exception as e:
            self._show_error(
                "Error Creating Database",
                f"Failed to create dynasty file:\n{str(e)}"
            )
    
    def open_dynasty(self) -> None:
        """Prompt user to open an existing dynasty database file."""
        path = self._get_open_path("Open Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.open_database(path)
            self.parent.refresh_ui()
        except FileNotFoundError:
            self._show_error(
                "File Not Found",
                f"The file '{path}' does not exist."
            )
        except Exception as e:
            self._show_error(
                "Error Opening Database",
                f"Failed to open dynasty file:\n{str(e)}"
            )
    
    def save(self) -> bool:
        """Save current database, falling back to save_as if no path set."""
        if not self._ensure_db():
            return False
        
        if not self.parent.db.has_file_path:
            return self.save_as()
        
        try:
            result = self.parent.db.save_database()
            if result:
                self.parent.refresh_ui()
            return result
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def save_as(self) -> bool:
        """Prompt user to save database to a new file."""
        if not self._ensure_db():
            return False
        
        # Suggest current filename if it exists
        default_name = self.parent.db.database_name or ""
        path = self._get_save_path("Save Dynasty File As", default_name)
        if not path:
            return False
        
        try:
            self.parent.db.save_database(path)
            return True
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def exit_app(self) -> None:
        """Prompt to save unsaved changes before closing application."""
        db = self.parent.db
        
        if db.is_open and db.is_dirty:
            msg = QMessageBox(self.parent)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:
                if not self.save():
                    return
            elif choice == QMessageBox.StandardButton.Cancel:
                return
        
        self.parent.close()


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/edit_actions.py (24 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class EditActions:
    """Handles edit menu actions (Undo, Redo, Add/Remove operations)."""
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize edit actions handler."""
        self.parent = parent
    
    def undo(self) -> None:
        """Undo the last action."""
        if self.parent.undo_manager.undo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
    
    def redo(self) -> None:
        """Redo the last undone action."""
        if self.parent.undo_manager.redo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
    
    def add_person(self) -> None:
        """Open dialog to add a new person to the database."""
        pass  # TODO: Implement with AddPersonDialog
    
    def remove_person(self) -> None:
        """Remove the selected person from the database."""
        pass  # TODO: Implement with confirmation dialog
    
    def add_new_family(self) -> None:
        """Create a new family branch in the dynasty."""
        pass  # TODO: Implement family creation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/view_actions.py (17 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ViewActions:
    """Handles view menu actions for switching between visualizations."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize view actions handler."""
        self.parent = parent

    def family_trees(self) -> None:
        """Switch to family trees visualization view."""
        pass  # TODO: Implement family trees view

    def timeline(self) -> None:
        """Switch to timeline visualization view."""
        pass  # TODO: Implement timeline view

    def dynasty(self) -> None:
        """Switch to dynasty visualization view."""
        pass  # TODO: Implement dynasty view

    def data_table(self) -> None:
        """Switch to data table view."""
        pass  # TODO: Implement data table view


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/tools_actions.py (17 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ToolsActions:
    """Handles tools menu actions for validation and scene utilities."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize tools actions handler."""
        self.parent = parent

    def rebuild_scene(self) -> None:
        """Rebuild the current visualization scene from scratch."""
        pass  # TODO: Implement scene rebuild

    def recompute_generations(self) -> None:
        """Recalculate generation levels for all persons."""
        pass  # TODO: Implement generation computation

    def validate_marriages(self) -> None:
        """Check for inconsistencies in marriage records."""
        pass  # TODO: Implement marriage validation

    def validate_parentage(self) -> None:
        """Check for inconsistencies in parent-child relationships."""
        pass  # TODO: Implement parentage validation


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/help_actions.py (8 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HelpActions:
    """Handles help menu actions for application information."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize help actions handler."""
        self.parent = parent

    def about(self) -> None:
        """Display the about dialog with application information."""
        pass  # TODO: Implement about dialog


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: actions/settings_actions.py (23 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SettingsActions:
    """Handles settings menu actions for various configuration options."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize settings actions handler."""
        self.parent = parent

    def settings(self) -> None:
        """Open settings dialog to modify application settings."""
        pass  # TODO: Implement settings dialog interaction

    def general(self) -> None:
        """Open general settings tab."""
        pass  # TODO: Implement general settings tab

    def shortcuts(self) -> None:
        """Open shortcuts settings tab."""
        pass  # TODO: Implement shortcuts settings tab

    def display(self) -> None:
        """Open display settings tab."""
        pass  # TODO: Implement display settings tab

    def appearance(self) -> None:
        """Open appearance settings tab."""
        pass  # TODO: Implement appearance settings tab

    def formats(self) -> None:
        """Open formats settings tab."""
        pass  # TODO: Implement formats settings tab

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: commands/undo_redo_manager.py (43 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from __future__ import annotations
from typing import Protocol


class Command(Protocol):
    """Protocol defining the interface for undoable commands."""

    def run(self) -> None:
        """Execute the command."""
        ...

    def undo(self) -> None:
        """Reverse the command's effects."""
        ...


class UndoRedoManager:
    """Manages undo and redo stacks for command pattern operations."""

    def __init__(self) -> None:
        """Initialize the undo/redo manager with empty stacks."""
        self.undo_stack: list[Command] = []
        self.redo_stack: list[Command] = []

    def execute(self, command: Command) -> None:
        """Execute a command and add it to the undo stack."""
        command.run()
        self.undo_stack.append(command)
        self.redo_stack.clear()

    def undo(self) -> bool:
        """Undo the last executed command."""
        if not self.undo_stack:
            return False
        cmd = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
        return True

    def redo(self) -> bool:
        """Redo the last undone command."""
        if not self.redo_stack:
            return False
        cmd = self.redo_stack.pop()
        cmd.run()
        self.undo_stack.append(cmd)
        return True

    def can_undo(self) -> bool:
        """Check if there are commands available to undo."""
        return len(self.undo_stack) > 0

    def can_redo(self) -> bool:
        """Check if there are commands available to redo."""
        return len(self.redo_stack) > 0


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: utils/settings_manager.py (169 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

"""User preferences and settings management."""

from __future__ import annotations
from typing import Any
from PySide6.QtCore import QSettings

class SettingsManager:
    """Manages user preferences and disk persistence."""

    DEFAULTS = {
        "shortcuts": {
            # File Menu shortcuts
            "file.new": "Ctrl+N",
            "file.open": "Ctrl+O",
            "file.save": "Ctrl+S",
            "file.save_as": "Ctrl+Shift+S",
            "file.exit": "Ctrl+Q",

            # Edit Menu shortcuts
            "edit.undo": "Ctrl+Z",
            "edit.redo": "Ctrl+Y",
            "edit.add_person": "Ctrl+P",
            "edit.remove_person": "Del",
            "edit.add_new_family": "Ctrl+F",

            # View Menu shortcuts
            "view.family_trees": "Ctrl+1",
            "view.timeline": "Ctrl+2",
            "view.dynasty": "Ctrl+3",
            "view.data_table": "Ctrl+4",

            # Tools Menu shortcuts
            "tools.rebuild_scene": "F5",
            "tools.recompute_generations": "Ctrl+R",
            "tools.validate_marriages": "Ctrl+M",
            "tools.validate_parentage": "Ctrl+Shift+P",

            # Settings Menu shortcuts
            "settings.settings": "Ctrl+,",
            "settings.general": "",
            "settings.shortcuts": "",
            "settings.display": "",
            "settings.appearance": "",
            "settings.formats": "",

            # Help Menu shortcuts
            "help.about": "F1",
        },

        "general": {
            # TODO: Define general settings defaults
            # e.g., autosave interval, default file paths, etc.
            # including different header sections as above
        },

        "display": {
            # TODO: Define display settings defaults
            # e.g., default zoom level, layout preferences, etc.
            # including different header sections as above
            # window size, position, maximized state, fonts, themes etc.
        },

        "appearance": {
            # TODO: Define appearance settings defaults
            # e.g., color schemes, node styles, edge styles, Colorblindness modes,
            # Male/Female/Unknown color preferences, generation band colors, genetic line styles, etc.
            # including different header sections as above to keep things organized
        },

        "formats": {
            # TODO: Define format settings defaults
            # e.g., date formats, name display formats, event display formats, etc.
            # Undo/Redo stack size, autosave file format, import/export preferences, etc.
            # including different header sections as above
        },
    }

    def __init__(self) -> None:
        """Initialize settings manager and load user settings."""
        
        self.qsettings = QSettings("DynastyVizualizer", "DynastyVisualizer")

        self.custom_shortcuts: dict[str, str | None] = {}
        self.custom_general: dict[str, Any] = {}
        self.custom_display: dict[str, Any] = {}
        self.custom_appearance: dict[str, Any] = {}
        self.custom_formats: dict[str, Any] = {}
    
        self._load_from_disk()

    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------

    def _get_custom_dict(self, category: str) -> dict[str, Any]:
        """Get the custom dictionary for a given category."""
        category_map = {
            "shortcuts": self.custom_shortcuts,
            "general": self.custom_general,
            "display": self.custom_display,
            "appearance": self.custom_appearance,
            "formats": self.custom_formats,
        }
        return category_map.get(category, {})

    def _load_from_disk(self) -> None:
        """Load user's saved settings from disk."""
        for category in self.DEFAULTS.keys():
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if self.qsettings.contains(key):
                    value = self.qsettings.value(key)
                    custom_dict[key] = value if value else None
            
            self.qsettings.endGroup()
    def _save_to_disk(self) -> None:
        """Save user's custom settings to disk."""
        for category in self.DEFAULTS.keys():
            # Clear existing category on disk
            self.qsettings.beginGroup(category)
            self.qsettings.remove("")
            self.qsettings.endGroup()
            
            # Save only settings that exist in current DEFAULTS
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if key in custom_dict:  
                    value = custom_dict[key]
                    default = self.DEFAULTS[category][key]

                    if value != default:
                        self.qsettings.setValue(key, value if value else "")
            
            self.qsettings.endGroup()
        
        self.qsettings.sync()

    # ------------------------------------------------------------------
    # Shortcut Operations (Specific, Type-Safe)
    # ------------------------------------------------------------------

    def get_shortcut(self, action_name: str) -> str:
        """Get the shortcut for a given action, falling back to default if not customized."""
        return self.get_setting("shortcuts", action_name)

    def set_shortcut(self, action_name: str, shortcut: str) -> None:
        """Set custom shortcut in memory without saving to disk."""
        self.set_setting("shortcuts", action_name, shortcut)

        if shortcut:
            for other_action in list(self.custom_shortcuts.keys()):
                if other_action != action_name:
                    if self.custom_shortcuts[other_action] == shortcut:
                        self.custom_shortcuts[other_action] = None


    # ------------------------------------------------------------------
    # Generic Settings Operations
    # ------------------------------------------------------------------

    def get_setting(self, category: str, key: str) -> Any:
        """Get setting from any category, checking custom then default."""
        # Check custom value first
        custom_dict = self._get_custom_dict(category)
        if key in custom_dict:
            value = custom_dict[key]
            return value if value is not None else ""
        
        # Fall back to default
        if category in self.DEFAULTS and key in self.DEFAULTS[category]:
            return self.DEFAULTS[category][key]
        
        return ""
    
    def set_setting(self, category: str, key: str, value: Any) -> None:
        """Set setting in any category (memory only, not saved to disk)."""
        custom_dict = self._get_custom_dict(category)
        custom_dict[key] = value if value else None

    # ------------------------------------------------------------------
    # Save/Discard/Reset Operations
    # ------------------------------------------------------------------

    def save(self) -> None:
        """Save all custom settings to disk."""
        self._save_to_disk()

    def discard_changes(self) -> None:
        """Discard unsaved changes by reloading from disk."""
        self.custom_shortcuts.clear()
        self.custom_general.clear()
        self.custom_display.clear()
        self.custom_appearance.clear()
        self.custom_formats.clear()
        self._load_from_disk()

    def reset_category_to_defaults(self, category: str) -> None:
        """Reset one category to defaults and save to disk."""
        custom_dict = self._get_custom_dict(category)
        custom_dict.clear()
        self._save_to_disk()

    def reset_all_to_defaults(self) -> None:
        """Reset all categories to defaults and save to disk."""
        for category in self.DEFAULTS.keys():
            self.reset_category_to_defaults(category)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: models/person.py (112 lines)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

"""Data model for Person entities."""

from __future__ import annotations
from dataclasses import dataclass


@dataclass
class Person:
    """Represents a person in a dynasty with flexible date precision."""
    
    # Database identity
    id: int | None = None  # None until saved to database
    dynasty_id: int = 1
    family_id: int | None = None
    
    # Name fields (full structure for flexibility)
    first_name: str = ""
    middle_name: str = ""
    last_name: str = ""
    maiden_name: str = ""
    nickname: str = ""
    
    # Biological information
    sex: str = "Unknown"  # "Male", "Female", "Unknown", "Other"
    
    # Birth date (year should be provided, month/day optional)
    birth_year: int | None = None
    birth_month: int | None = None
    birth_day: int | None = None
    
    # Death date (all optional - None if alive)
    death_year: int | None = None
    death_month: int | None = None
    death_day: int | None = None
    
    # Arrival/departure dates (tracking when joined/left settlement)
    arrival_year: int | None = None
    arrival_month: int | None = None
    arrival_day: int | None = None
    moved_out_year: int | None = None
    moved_out_month: int | None = None
    moved_out_day: int | None = None
    
    # Relationships (parent IDs link to database)
    father_id: int | None = None
    mother_id: int | None = None
    
    # Game-specific fields
    is_founder: bool = False
    education: int = 0  # 0-5 scale from Ostriv
    
    # User notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties
    # ------------------------------------------------------------------
    
    @property
    def full_name(self) -> str:
        """Get full name with optional middle name and nickname."""
        parts = [self.first_name]
        
        if self.middle_name:
            parts.append(self.middle_name)
        
        parts.append(self.last_name)

        name = " ".join(parts)
        
        if self.nickname:
            name += f' "{self.nickname}"'

        return name
    
    @property
    def display_name(self) -> str:
        """Get display name (first + last, no middle or nickname)."""
        return f"{self.first_name} {self.last_name}"
    
    @property
    def is_deceased(self) -> bool:
        """Check if person is deceased."""
        return self.death_year is not None
    
    def get_age(self, current_year: int) -> int | None:
        """
        Calculate age at a given year.
        
        Returns None if birth year unknown or if person died before current year.
        """
        if self.birth_year is None:
            return None
        
        # If person died, use death year as upper bound
        if self.death_year is not None and current_year > self.death_year:
            return None
        
        return current_year - self.birth_year
    
    def is_alive_in_year(self, year: int) -> bool:
        """Check if person was alive in a given year."""
        # Must have been born by that year
        if self.birth_year is None or year < self.birth_year:
            return False
        
        # If no death year, assume still alive
        if self.death_year is None:
            return True
        
        # Check if year is before death
        return year <= self.death_year
    
    def get_age_at_death(self) -> int | None:
        """Calculate age at death, or None if not deceased or birth year unknown."""
        if not self.is_deceased or self.birth_year is None or self.death_year is None:
            return None
        
        return self.death_year - self.birth_year
    
    def get_birth_date_string(self) -> str:
        """Format birth date as string with available precision (European format)."""
        if self.birth_year is None:
            return "Unknown"
        
        if self.birth_day and self.birth_month:
            return f"{self.birth_day:02d}/{self.birth_month:02d}/{self.birth_year}"
        
        if self.birth_month:
            return f"{self.birth_month:02d}/{self.birth_year}"
        
        return str(self.birth_year)
    
    def get_death_date_string(self) -> str:
        """Format death date as string with available precision (European format)."""
        if self.death_year is None:
            return "Alive"
        
        if self.death_day and self.death_month:
            return f"{self.death_day:02d}/{self.death_month:02d}/{self.death_year}"
        
        if self.death_month:
            return f"{self.death_month:02d}/{self.death_year}"
        
        return str(self.death_year)
    
    def get_lifespan_string(self) -> str:
        """Get lifespan as formatted string (e.g., '1420-1475' or '1450-')."""
        birth = str(self.birth_year) if self.birth_year else "?"
        death = str(self.death_year) if self.death_year else ""
        return f"{birth}-{death}"

======================================================================
End of DynastyVizualizer codebase
Total: 12 implementation files, 1057 lines
======================================================================
