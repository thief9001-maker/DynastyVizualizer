======================================================================
DynastyVizualizer - Complete Codebase
======================================================================
Generated: 2026-01-08 02:46
Files: 41/106 implemented | 4499 code lines
Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern
Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)
======================================================================

QUICK CONTEXT:
Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,
undo/redo, flexible dates, special char support, DB migration.
Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database

FILE INDEX:
Core:
	main.py,
Database:
	database\__init__.py,
	database\base_repository.py,
	database\db_manager.py,
	database\event_repository.py,
	database\marriage_repository.py,
	database\person_repository.py,
Models:
	models\__init__.py,
	models\event.py,
	models\family.py,
	models\major_event.py,
	models\marriage.py,
	models\person.py,
	models\portrait.py,
Actions:
	actions\__init__.py,
	actions\edit_actions.py,
	actions\file_actions.py,
	actions\help_actions.py,
	actions\settings_actions.py,
	actions\tools_actions.py,
Commands:
		commands\GUI_commands\__init__.py,
		commands\GUI_commands\change_skin.py,
		commands\GUI_commands\change_view.py,
		commands\GUI_commands\move_node.py,
		commands\GUI_commands\move_person.py,
		commands\GUI_commands\preference_changes.py,
		commands\GUI_commands\rebuild_scene.py,
		commands\GUI_commands\recompute_generation.py,
		commands\GUI_commands\recompute_generations.py,
		commands\GUI_commands\timeline_scroll.py,
	commands\__init__.py,
	commands\base_command.py,
		commands\genealogy_commands\__init__.py,
		commands\genealogy_commands\add_event.py,
		commands\genealogy_commands\add_marriage.py,
		commands\genealogy_commands\add_person.py,
		commands\genealogy_commands\assign_parent.py,
		commands\genealogy_commands\create_child.py,
		commands\genealogy_commands\delete_event.py,
		commands\genealogy_commands\delete_marriage.py,
		commands\genealogy_commands\delete_person.py,
		commands\genealogy_commands\edit_event.py,
		commands\genealogy_commands\edit_marriage.py,
		commands\genealogy_commands\edit_person.py,
		commands\genealogy_commands\end_marriage.py,
		commands\genealogy_commands\unassign_parent.py,
	commands\undo_redo_manager.py,
Dialogs:
	dialogs\__init__.py,
	dialogs\about_dialog.py,
	dialogs\add_person_dialog.py,
	dialogs\create_child_dialog.py,
	dialogs\create_event_dialog.py,
	dialogs\create_marriage_dialog.py,
	dialogs\edit_event_dialog.py,
	dialogs\edit_person_dialog.py,
		dialogs\edit_person_panels\__init__.py,
		dialogs\edit_person_panels\event_panel.py,
		dialogs\edit_person_panels\general_panel.py,
		dialogs\edit_person_panels\relationships_panel.py,
	dialogs\end_marriage_dialog.py,
	dialogs\import_csv_dialog.py,
	dialogs\settings_dialog.py,
Views:
	views\__init__.py,
	views\data_table_view.py,
	views\dynasty_view.py,
		views\stats_view\charts.py,
		views\stats_view\comparison_widget.py,
		views\stats_view\family_dashboard.py,
		views\table_view\event_table.py,
		views\table_view\family_table.py,
		views\table_view\marriage_table.py,
		views\table_view\person_table.py,
	views\timeline_view.py,
		views\timeline_view\event_marker.py,
		views\timeline_view\family_bar.py,
		views\timeline_view\major_event_marker.py,
		views\timeline_view\person_bar.py,
		views\timeline_view\timeline_canvas.py,
		views\tree_view\__init__.py,
		views\tree_view\enhanced_tooltip_panel.py,
		views\tree_view\generation_band.py,
		views\tree_view\layout_engine.py,
		views\tree_view\marriage_node.py,
		views\tree_view\person_box.py,
		views\tree_view\relationship_line.py,
		views\tree_view\tree_canvas.py,
Widgets:
	widgets\__init__.py,
	widgets\date_picker.py,
	widgets\extended_details_panel.py,
	widgets\person_selector.py,
	widgets\portrait_gallery.py,
	widgets\search_bar.py,
Utils:
	utils\__init__.py,
	utils\color_manager.py,
	utils\csv_importer.py,
	utils\date_formatter.py,
	utils\generation_calculator.py,
	utils\relationship_calculator.py,
	utils\settings_manager.py,
	utils\skin_manager.py,
	utils\text_normalizer.py,
	utils\validators.py,
Scripts:
	scripts\create_codebase_summary.py,
	scripts\migrate_database.py,
	scripts\test_edit_person_dialog.py,
	scripts\test_person_box.py,

======================================================================
COMPLETE SOURCE CODE
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… main.py (283 code lines)
"""Main application window for Dynasty Visualizer."""

from __future__ import annotations

import sys
import os
from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QMenuBar, QMessageBox,
    QStackedWidget, QLabel
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QAction

if TYPE_CHECKING:
    pass

from database.db_manager import DatabaseManager
from actions import FileActions, EditActions, ToolsActions, HelpActions, SettingsActions
from commands.undo_redo_manager import UndoRedoManager
from utils.settings_manager import SettingsManager


class MainWindow(QMainWindow):
    """Main application window for Dynasty Visualizer."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "Dynasty Visualizer"
    WINDOW_TITLE_UNTITLED: str = "Dynasty Visualizer - Untitled *"
    WINDOW_TITLE_FORMAT: str = "Dynasty Visualizer - {name}{dirty}"
    WINDOW_WIDTH_DEFAULT: int = 1000
    WINDOW_HEIGHT_DEFAULT: int = 700
    
    # Temp Database
    TEMP_DB_NAME: str = "dynasty_untitled.dyn"
    
    # Menu Names
    MENU_FILE: str = "File"
    MENU_EDIT: str = "Edit"
    MENU_VIEW: str = "View"
    MENU_TOOLS: str = "Tools"
    MENU_SETTINGS: str = "Settings"
    MENU_HELP: str = "Help"
    
    # File Menu Actions
    ACTION_TEXT_NEW_DYNASTY: str = "New Dynasty"
    ACTION_TEXT_OPEN_DYNASTY: str = "Open Dynasty"
    ACTION_TEXT_SAVE: str = "Save"
    ACTION_TEXT_SAVE_AS: str = "Save As"
    ACTION_TEXT_EXIT: str = "Exit"
    ACTION_TEXT_RECENT_FILES: str = "Recent Files"
    ACTION_TEXT_CLEAR_RECENT: str = "Clear Recent Files"
    ACTION_TEXT_NO_RECENT: str = "(No Recent Files)"
    
    # Edit Menu Actions
    ACTION_TEXT_UNDO: str = "Undo"
    ACTION_TEXT_REDO: str = "Redo"
    ACTION_TEXT_ADD_PERSON: str = "Add Person"
    ACTION_TEXT_EDIT_PERSON: str = "Edit Person"
    ACTION_TEXT_REMOVE_PERSON: str = "Remove Person"
    ACTION_TEXT_ADD_FAMILY: str = "Add New Family"
    
    # View Menu Actions
    ACTION_TEXT_FAMILY_TREES: str = "Family Trees"
    ACTION_TEXT_TIMELINE: str = "Timeline"
    ACTION_TEXT_DYNASTY: str = "Dynasty"
    ACTION_TEXT_DATA_TABLE: str = "Data Table"
    
    # Tools Menu Actions
    ACTION_TEXT_REBUILD_SCENE: str = "Rebuild Scene"
    ACTION_TEXT_RECOMPUTE_GENERATIONS: str = "Recompute Generations"
    ACTION_TEXT_VALIDATE_MARRIAGES: str = "Validate Marriages"
    ACTION_TEXT_VALIDATE_PARENTAGE: str = "Validate Parentage"
    
    # Settings Menu Actions
    ACTION_TEXT_SETTINGS: str = "Settings"
    ACTION_TEXT_GENERAL: str = "General"
    ACTION_TEXT_SHORTCUTS: str = "Shortcuts"
    ACTION_TEXT_DISPLAY: str = "Display"
    ACTION_TEXT_APPEARANCE: str = "Appearance"
    ACTION_TEXT_FORMATS: str = "Formats"
    
    # Help Menu Actions
    ACTION_TEXT_ABOUT: str = "About"
    
    # Action Object Names
    ACTION_NAME_FILE_NEW: str = "file.new"
    ACTION_NAME_FILE_OPEN: str = "file.open"
    ACTION_NAME_FILE_SAVE: str = "file.save"
    ACTION_NAME_FILE_SAVE_AS: str = "file.save_as"
    ACTION_NAME_FILE_EXIT: str = "file.exit"
    ACTION_NAME_EDIT_UNDO: str = "edit.undo"
    ACTION_NAME_EDIT_REDO: str = "edit.redo"
    ACTION_NAME_EDIT_ADD_PERSON: str = "edit.add_person"
    ACTION_NAME_EDIT_EDIT_PERSON: str = "edit.edit_person"
    ACTION_NAME_EDIT_REMOVE_PERSON: str = "edit.remove_person"
    ACTION_NAME_EDIT_ADD_FAMILY: str = "edit.add_new_family"
    ACTION_NAME_VIEW_FAMILY_TREES: str = "view.family_trees"
    ACTION_NAME_VIEW_TIMELINE: str = "view.timeline"
    ACTION_NAME_VIEW_DYNASTY: str = "view.dynasty"
    ACTION_NAME_VIEW_DATA_TABLE: str = "view.data_table"
    ACTION_NAME_TOOLS_REBUILD: str = "tools.rebuild_scene"
    ACTION_NAME_TOOLS_RECOMPUTE: str = "tools.recompute_generations"
    ACTION_NAME_TOOLS_VALIDATE_MARRIAGES: str = "tools.validate_marriages"
    ACTION_NAME_TOOLS_VALIDATE_PARENTAGE: str = "tools.validate_parentage"
    ACTION_NAME_SETTINGS_SETTINGS: str = "settings.settings"
    ACTION_NAME_SETTINGS_GENERAL: str = "settings.general"
    ACTION_NAME_SETTINGS_SHORTCUTS: str = "settings.shortcuts"
    ACTION_NAME_SETTINGS_DISPLAY: str = "settings.display"
    ACTION_NAME_SETTINGS_APPEARANCE: str = "settings.appearance"
    ACTION_NAME_SETTINGS_FORMATS: str = "settings.formats"
    ACTION_NAME_HELP_ABOUT: str = "help.about"
    
    # Shortcuts (Temporary - will move to settings)
    SHORTCUT_EDIT_PERSON: str = "Ctrl+E"
    
    # Message Box Titles
    MSG_TITLE_FILE_NOT_FOUND: str = "File Not Found"
    MSG_TITLE_ERROR: str = "Error"
    MSG_TITLE_EDIT_PERSON: str = "Edit Person"
    MSG_TITLE_UNSAVED_CHANGES: str = "Unsaved Changes"
    
    # Message Box Text
    MSG_TEXT_FILE_NOT_FOUND: str = "The file '{path}' no longer exists."
    MSG_TEXT_OPEN_ERROR: str = "Failed to open file:\n{error}"
    MSG_TEXT_SELECT_PERSON: str = "Please select a person to edit."
    MSG_TEXT_UNSAVED_CHANGES: str = "You have unsaved changes. Do you want to save before exiting?"
    
    # Placeholder View Text
    PLACEHOLDER_GENEALOGY: str = "Genealogy View\n(Coming Soon!)"
    PLACEHOLDER_TIMELINE: str = "Timeline View\n(Coming Soon!)"
    PLACEHOLDER_DYNASTY: str = "Dynasty View\n(Coming Soon!)"
    
    # Styles
    STYLE_PLACEHOLDER: str = "font-size: 24px; color: gray;"
    
    # Dirty Marker
    DIRTY_MARKER: str = " *"
    DIRTY_MARKER_EMPTY: str = ""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self) -> None:
        """Initialize main window."""
        super().__init__()
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.resize(self.WINDOW_WIDTH_DEFAULT, self.WINDOW_HEIGHT_DEFAULT)
        
        self.db: DatabaseManager = DatabaseManager(self)
        self.undo_manager: UndoRedoManager = UndoRedoManager()
        self.settings_manager: SettingsManager = SettingsManager()
        
        self.file_actions: FileActions = FileActions(self)
        self.edit_actions: EditActions = EditActions(self)
        self.tools_actions: ToolsActions = ToolsActions(self)
        self.settings_actions: SettingsActions = SettingsActions(self)
        self.help_actions: HelpActions = HelpActions(self)
        
        self._setup_central_widget()
        self._create_menus()
        self._connect_actions()
        
        self._create_untitled_database()
        
        self._show_family_trees()
        
        self._update_window_title()
        self._update_menu_states()
    
    def _create_untitled_database(self) -> None:
        """Create a temporary database for new sessions."""
        import tempfile
        
        temp_dir: str = tempfile.gettempdir()
        temp_file: str = os.path.join(temp_dir, self.TEMP_DB_NAME)
        
        if os.path.exists(temp_file):
            self._remove_temp_file(temp_file)
        
        self.db.new_database(temp_file)
        self.db._temp_file_path = temp_file
        self.db.file_path = None
        
        self.refresh_ui()
    
    def _remove_temp_file(self, temp_file: str) -> None:
        """Remove temporary file if it exists."""
        try:
            os.remove(temp_file)
        except Exception:
            pass
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_central_widget(self) -> None:
        """Setup the central widget with stacked views."""
        self.view_stack: QStackedWidget = QStackedWidget()
        self.setCentralWidget(self.view_stack)
        
        self.genealogy_view = None
        self.timeline_view = None
        self.dynasty_view = None
        self.data_table_view = None
    
    def _create_menus(self) -> None:
        """Create all menu bars and menu items."""
        menubar: QMenuBar = self.menuBar()
        
        self._create_file_menu(menubar)
        self._create_edit_menu(menubar)
        self._create_view_menu(menubar)
        self._create_tools_menu(menubar)
        self._create_settings_menu(menubar)
        self._create_help_menu(menubar)
    
    def _create_file_menu(self, menubar: QMenuBar) -> None:
        """Create the File menu."""
        file_menu = menubar.addMenu(self.MENU_FILE)
        
        self.action_new_dynasty: QAction = self._create_action(
            self.ACTION_TEXT_NEW_DYNASTY,
            self.ACTION_NAME_FILE_NEW
        )
        
        self.action_open_dynasty: QAction = self._create_action(
            self.ACTION_TEXT_OPEN_DYNASTY,
            self.ACTION_NAME_FILE_OPEN
        )
        
        file_menu.addAction(self.action_new_dynasty)
        file_menu.addAction(self.action_open_dynasty)
        
        self.recent_files_menu = file_menu.addMenu(self.ACTION_TEXT_RECENT_FILES)
        self._update_recent_files_menu()
        
        file_menu.addSeparator()
        
        self.action_save: QAction = self._create_action(
            self.ACTION_TEXT_SAVE,
            self.ACTION_NAME_FILE_SAVE
        )
        
        self.action_save_as: QAction = self._create_action(
            self.ACTION_TEXT_SAVE_AS,
            self.ACTION_NAME_FILE_SAVE_AS
        )
        
        file_menu.addAction(self.action_save)
        file_menu.addAction(self.action_save_as)
        file_menu.addSeparator()
        
        self.action_exit: QAction = self._create_action(
            self.ACTION_TEXT_EXIT,
            self.ACTION_NAME_FILE_EXIT
        )
        
        file_menu.addAction(self.action_exit)
    
    def _create_edit_menu(self, menubar: QMenuBar) -> None:
        """Create the Edit menu."""
        edit_menu = menubar.addMenu(self.MENU_EDIT)
        
        self.action_undo: QAction = self._create_action(
            self.ACTION_TEXT_UNDO,
            self.ACTION_NAME_EDIT_UNDO
        )
        
        self.action_redo: QAction = self._create_action(
            self.ACTION_TEXT_REDO,
            self.ACTION_NAME_EDIT_REDO
        )
        
        self.action_add_person: QAction = self._create_action(
            self.ACTION_TEXT_ADD_PERSON,
            self.ACTION_NAME_EDIT_ADD_PERSON
        )
        
        self.action_edit_person: QAction = QAction(self.ACTION_TEXT_EDIT_PERSON, self)
        self.action_edit_person.setObjectName(self.ACTION_NAME_EDIT_EDIT_PERSON)
        self.action_edit_person.setShortcut(self.SHORTCUT_EDIT_PERSON)
        
        self.action_remove_person: QAction = self._create_action(
            self.ACTION_TEXT_REMOVE_PERSON,
            self.ACTION_NAME_EDIT_REMOVE_PERSON
        )
        
        self.action_add_new_family: QAction = self._create_action(
            self.ACTION_TEXT_ADD_FAMILY,
            self.ACTION_NAME_EDIT_ADD_FAMILY
        )
        self.action_add_new_family.setEnabled(False)
        
        edit_menu.addAction(self.action_undo)
        edit_menu.addAction(self.action_redo)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_person)
        edit_menu.addAction(self.action_edit_person)
        edit_menu.addAction(self.action_remove_person)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_new_family)
        
        self.edit_actions.undo_action = self.action_undo
        self.edit_actions.redo_action = self.action_redo
        self.edit_actions.update_undo_redo_actions()
    
    def _create_view_menu(self, menubar: QMenuBar) -> None:
        """Create the View menu."""
        view_menu = menubar.addMenu(self.MENU_VIEW)
        
        self.action_view_family_trees: QAction = self._create_action(
            self.ACTION_TEXT_FAMILY_TREES,
            self.ACTION_NAME_VIEW_FAMILY_TREES
        )
        
        self.action_view_timeline: QAction = self._create_action(
            self.ACTION_TEXT_TIMELINE,
            self.ACTION_NAME_VIEW_TIMELINE
        )
        
        self.action_view_dynasty: QAction = self._create_action(
            self.ACTION_TEXT_DYNASTY,
            self.ACTION_NAME_VIEW_DYNASTY
        )
        
        self.action_view_data_table: QAction = self._create_action(
            self.ACTION_TEXT_DATA_TABLE,
            self.ACTION_NAME_VIEW_DATA_TABLE
        )
        
        view_menu.addAction(self.action_view_family_trees)
        view_menu.addAction(self.action_view_timeline)
        view_menu.addAction(self.action_view_dynasty)
        view_menu.addAction(self.action_view_data_table)
    
    def _create_tools_menu(self, menubar: QMenuBar) -> None:
        """Create the Tools menu."""
        tools_menu = menubar.addMenu(self.MENU_TOOLS)
        
        self.action_rebuild_scene: QAction = self._create_action(
            self.ACTION_TEXT_REBUILD_SCENE,
            self.ACTION_NAME_TOOLS_REBUILD
        )
        
        self.action_recompute_generations: QAction = self._create_action(
            self.ACTION_TEXT_RECOMPUTE_GENERATIONS,
            self.ACTION_NAME_TOOLS_RECOMPUTE
        )
        
        self.action_validate_marriages: QAction = self._create_action(
            self.ACTION_TEXT_VALIDATE_MARRIAGES,
            self.ACTION_NAME_TOOLS_VALIDATE_MARRIAGES
        )
        
        self.action_validate_parentage: QAction = self._create_action(
            self.ACTION_TEXT_VALIDATE_PARENTAGE,
            self.ACTION_NAME_TOOLS_VALIDATE_PARENTAGE
        )
        
        tools_menu.addAction(self.action_rebuild_scene)
        tools_menu.addAction(self.action_recompute_generations)
        tools_menu.addAction(self.action_validate_marriages)
        tools_menu.addAction(self.action_validate_parentage)
    
    def _create_settings_menu(self, menubar: QMenuBar) -> None:
        """Create the Settings menu."""
        settings_menu = menubar.addMenu(self.MENU_SETTINGS)
        
        self.action_settings: QAction = self._create_action(
            self.ACTION_TEXT_SETTINGS,
            self.ACTION_NAME_SETTINGS_SETTINGS
        )
        
        self.action_general: QAction = self._create_action(
            self.ACTION_TEXT_GENERAL,
            self.ACTION_NAME_SETTINGS_GENERAL
        )
        
        self.action_shortcuts: QAction = self._create_action(
            self.ACTION_TEXT_SHORTCUTS,
            self.ACTION_NAME_SETTINGS_SHORTCUTS
        )
        
        self.action_display: QAction = self._create_action(
            self.ACTION_TEXT_DISPLAY,
            self.ACTION_NAME_SETTINGS_DISPLAY
        )
        
        self.action_appearance: QAction = self._create_action(
            self.ACTION_TEXT_APPEARANCE,
            self.ACTION_NAME_SETTINGS_APPEARANCE
        )
        
        self.action_formats: QAction = self._create_action(
            self.ACTION_TEXT_FORMATS,
            self.ACTION_NAME_SETTINGS_FORMATS
        )
        
        settings_menu.addAction(self.action_settings)
        settings_menu.addSeparator()
        settings_menu.addAction(self.action_general)
        settings_menu.addAction(self.action_shortcuts)
        settings_menu.addAction(self.action_display)
        settings_menu.addAction(self.action_appearance)
        settings_menu.addAction(self.action_formats)
    
    def _create_help_menu(self, menubar: QMenuBar) -> None:
        """Create the Help menu."""
        help_menu = menubar.addMenu(self.MENU_HELP)
        
        self.action_about: QAction = self._create_action(
            self.ACTION_TEXT_ABOUT,
            self.ACTION_NAME_HELP_ABOUT
        )
        
        help_menu.addAction(self.action_about)
    
    def _create_action(self, text: str, object_name: str) -> QAction:
        """Create a QAction with text, object name, and shortcut from settings."""
        action: QAction = QAction(text, self)
        action.setObjectName(object_name)
        shortcut: str = self.settings_manager.get_shortcut(object_name)
        if shortcut:
            action.setShortcut(shortcut)
        return action
    
    # ------------------------------------------------------------------
    # Action Connections
    # ------------------------------------------------------------------
    
    def _connect_actions(self) -> None:
        """Connect all menu actions to their handler methods."""
        self.action_new_dynasty.triggered.connect(self.file_actions.new_dynasty)
        self.action_open_dynasty.triggered.connect(self.file_actions.open_dynasty)
        self.action_save.triggered.connect(self.file_actions.save)
        self.action_save_as.triggered.connect(self.file_actions.save_as)
        self.action_exit.triggered.connect(self.file_actions.exit_app)
        
        self.action_undo.triggered.connect(self.edit_actions.undo)
        self.action_redo.triggered.connect(self.edit_actions.redo)
        self.action_add_person.triggered.connect(self.edit_actions.add_person)
        self.action_edit_person.triggered.connect(self._edit_selected_person)
        self.action_remove_person.triggered.connect(self.edit_actions.remove_person)
        self.action_add_new_family.triggered.connect(self.edit_actions.add_new_family)
        
        self.action_view_family_trees.triggered.connect(self._show_family_trees)
        self.action_view_timeline.triggered.connect(self._show_timeline)
        self.action_view_dynasty.triggered.connect(self._show_dynasty)
        self.action_view_data_table.triggered.connect(self._show_data_table)
        
        self.action_rebuild_scene.triggered.connect(self.tools_actions.rebuild_scene)
        self.action_recompute_generations.triggered.connect(self.tools_actions.recompute_generations)
        self.action_validate_marriages.triggered.connect(self.tools_actions.validate_marriages)
        self.action_validate_parentage.triggered.connect(self.tools_actions.validate_parentage)
        
        self.action_settings.triggered.connect(self.settings_actions.settings)
        self.action_general.triggered.connect(self.settings_actions.general)
        self.action_shortcuts.triggered.connect(self.settings_actions.shortcuts)
        self.action_display.triggered.connect(self.settings_actions.display)
        self.action_appearance.triggered.connect(self.settings_actions.appearance)
        self.action_formats.triggered.connect(self.settings_actions.formats)
        
        self.action_about.triggered.connect(self.help_actions.about)
    
    # ------------------------------------------------------------------
    # Recent Files Management
    # ------------------------------------------------------------------
    
    def _update_recent_files_menu(self) -> None:
        """Update the Recent Files submenu with current list."""
        self.recent_files_menu.clear()
        
        recent: list[str] = self.settings_manager.get_recent_files()
        
        if recent:
            self._populate_recent_files(recent)
        else:
            self._show_no_recent_files()
    
    def _populate_recent_files(self, recent: list[str]) -> None:
        """Populate recent files menu with file actions."""
        for path in recent:
            filename: str = os.path.basename(path)
            action: QAction = QAction(filename, self)
            action.setData(path)
            action.triggered.connect(lambda checked, p=path: self._open_recent_file(p))
            self.recent_files_menu.addAction(action)
        
        self.recent_files_menu.addSeparator()
        
        clear_action: QAction = QAction(self.ACTION_TEXT_CLEAR_RECENT, self)
        clear_action.triggered.connect(self._clear_recent_files)
        self.recent_files_menu.addAction(clear_action)
    
    def _show_no_recent_files(self) -> None:
        """Show placeholder when no recent files exist."""
        no_recent: QAction = QAction(self.ACTION_TEXT_NO_RECENT, self)
        no_recent.setEnabled(False)
        self.recent_files_menu.addAction(no_recent)
    
    def _open_recent_file(self, path: str) -> None:
        """Open a file from recent files list."""
        if not os.path.exists(path):
            self._show_file_not_found_error(path)
            return
        
        self._attempt_open_file(path)
    
    def _show_file_not_found_error(self, path: str) -> None:
        """Show error message when file is not found."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_FILE_NOT_FOUND,
            self.MSG_TEXT_FILE_NOT_FOUND.format(path=path)
        )
        self._remove_from_recent_files(path)
    
    def _attempt_open_file(self, path: str) -> None:
        """Attempt to open file and handle errors."""
        try:
            self.db.open_database(path)
            self.refresh_ui()
            self.file_actions._refresh_all_views()
            self.settings_manager.add_recent_file(path)
            self._update_recent_files_menu()
        except Exception as e:
            self._show_open_error(e)
    
    def _show_open_error(self, error: Exception) -> None:
        """Show error message when file fails to open."""
        QMessageBox.critical(
            self,
            self.MSG_TITLE_ERROR,
            self.MSG_TEXT_OPEN_ERROR.format(error=str(error))
        )
    
    def _remove_from_recent_files(self, path: str) -> None:
        """Remove a file from recent files list."""
        recent: list[str] = self.settings_manager.get_recent_files()
        
        if path not in recent:
            return
        
        recent.remove(path)
        self.settings_manager.clear_recent_files()
        
        for p in recent:
            self.settings_manager.add_recent_file(p)
        
        self._update_recent_files_menu()
    
    def _clear_recent_files(self) -> None:
        """Clear the recent files list."""
        self.settings_manager.clear_recent_files()
        self._update_recent_files_menu()
    
    # ------------------------------------------------------------------
    # View Management
    # ------------------------------------------------------------------
    
    def _show_family_trees(self) -> None:
        """Switch to family trees view."""
        if self.genealogy_view is None:
            self.genealogy_view = self._create_placeholder_view(self.PLACEHOLDER_GENEALOGY)
            self.view_stack.addWidget(self.genealogy_view)
        
        self.view_stack.setCurrentWidget(self.genealogy_view)
    
    def _show_timeline(self) -> None:
        """Switch to timeline view."""
        if self.timeline_view is None:
            self.timeline_view = self._create_placeholder_view(self.PLACEHOLDER_TIMELINE)
            self.view_stack.addWidget(self.timeline_view)
        
        self.view_stack.setCurrentWidget(self.timeline_view)
    
    def _show_dynasty(self) -> None:
        """Switch to dynasty view."""
        if self.dynasty_view is None:
            self.dynasty_view = self._create_placeholder_view(self.PLACEHOLDER_DYNASTY)
            self.view_stack.addWidget(self.dynasty_view)
        
        self.view_stack.setCurrentWidget(self.dynasty_view)
    
    def _create_placeholder_view(self, text: str) -> QLabel:
        """Create a placeholder view with text."""
        placeholder: QLabel = QLabel(text)
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet(self.STYLE_PLACEHOLDER)
        return placeholder
    
    def _show_data_table(self) -> None:
        """Switch to data table view."""
        if self.data_table_view is None:
            from views.data_table_view import DataTableView
            self.data_table_view = DataTableView(self.db, self)
            self.view_stack.addWidget(self.data_table_view)
        
        self.data_table_view.refresh_data()
        self.view_stack.setCurrentWidget(self.data_table_view)
    
    def _edit_selected_person(self) -> None:
        """Edit the currently selected person in the active view."""
        if self._is_data_table_active():
            self.data_table_view._edit_selected_person()  # type: ignore[union-attr]
        else:
            self._show_select_person_message()
    
    def _is_data_table_active(self) -> bool:
        """Check if data table view is currently active."""
        return (
            self.data_table_view is not None and 
            self.view_stack.currentWidget() == self.data_table_view
        )
    
    def _show_select_person_message(self) -> None:
        """Show message to select a person."""
        QMessageBox.information(
            self,
            self.MSG_TITLE_EDIT_PERSON,
            self.MSG_TEXT_SELECT_PERSON
        )
    
    # ------------------------------------------------------------------
    # UI Update Methods
    # ------------------------------------------------------------------
    
    def _update_window_title(self) -> None:
        """Update the window title to reflect current database state."""
        if not self.db.is_open:
            self.setWindowTitle(self.WINDOW_TITLE)
            return
        
        if self.db.file_path is None:
            self.setWindowTitle(self.WINDOW_TITLE_UNTITLED)
            return
        
        dirty_marker: str = self.DIRTY_MARKER if self.db.is_dirty else self.DIRTY_MARKER_EMPTY
        title: str = self.WINDOW_TITLE_FORMAT.format(
            name=self.db.database_name,
            dirty=dirty_marker
        )
        self.setWindowTitle(title)
    
    def _update_menu_states(self) -> None:
        """Enable or disable menu items based on current state."""
        has_db: bool = self.db.is_open
        
        self.action_save.setEnabled(has_db)
        self.action_save_as.setEnabled(has_db)
        
        self.action_undo.setEnabled(self.undo_manager.can_undo())
        self.action_redo.setEnabled(self.undo_manager.can_redo())
        self.action_add_person.setEnabled(has_db)
        self.action_edit_person.setEnabled(has_db)
        self.action_remove_person.setEnabled(has_db)
        
        self.action_view_family_trees.setEnabled(has_db)
        self.action_view_timeline.setEnabled(has_db)
        self.action_view_dynasty.setEnabled(has_db)
        self.action_view_data_table.setEnabled(has_db)
        
        self.action_rebuild_scene.setEnabled(has_db)
        self.action_recompute_generations.setEnabled(has_db)
        self.action_validate_marriages.setEnabled(has_db)
        self.action_validate_parentage.setEnabled(has_db)
    
    def refresh_ui(self) -> None:
        """Refresh window title and menu states after database changes."""
        self._update_window_title()
        self._update_menu_states()
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def closeEvent(self, event) -> None:
        """Handle window close event."""
        if not self._has_unsaved_changes():
            event.accept()
            return
        
        choice = self._prompt_save_before_close()
        
        if choice == QMessageBox.StandardButton.Save:
            if self.file_actions.save():
                event.accept()
            else:
                event.ignore()
        elif choice == QMessageBox.StandardButton.Discard:
            event.accept()
        else:
            event.ignore()
    
    def _has_unsaved_changes(self) -> bool:
        """Check if there are unsaved changes."""
        return self.db.is_open and self.db.is_dirty
    
    def _prompt_save_before_close(self) -> QMessageBox.StandardButton:
        """Prompt user to save changes before closing."""
        msg: QMessageBox = QMessageBox(self)
        msg.setWindowTitle(self.MSG_TITLE_UNSAVED_CHANGES)
        msg.setText(self.MSG_TEXT_UNSAVED_CHANGES)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Save |
            QMessageBox.StandardButton.Discard |
            QMessageBox.StandardButton.Cancel
        )
        result: int = msg.exec()
        return QMessageBox.StandardButton(result)


# ------------------------------------------------------------------
# Application Entry Point
# ------------------------------------------------------------------

def main() -> None:
    """Application entry point."""
    app: QApplication = QApplication(sys.argv)
    window: MainWindow = MainWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ database\__init__.py (4 code lines)
from .db_manager import DatabaseManager
from .person_repository import PersonRepository
from .base_repository import BaseRepository

__all__ = ['DatabaseManager', 'PersonRepository', 'BaseRepository']

>> âœ… database\base_repository.py (41 code lines)
"""Base repository with shared database operations."""
from __future__ import annotations

import sqlite3
from typing import TYPE_CHECKING, TypeVar, Generic, Protocol
from abc import ABC, abstractmethod

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager

class HasID(Protocol):
    """Protocol for entities that have an ID attribute."""
    id: int | None

T = TypeVar('T', bound=HasID)

class BaseRepository(ABC, Generic[T]):
    """Base class for all repository classes with common operations."""

    # Constants - Error Messages
    ERROR_NO_CONNECTION: str = "Database connection not established."
    ERROR_NO_ID_FOR_UPDATE: str = "Cannot update {entity} without ID."
    ERROR_NO_ID_FOR_INSERT: str = "{entity} must have an ID for insert_with_id."

    # Constants - Default Values
    DEFAULT_ID_ON_ERROR: int = -1
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize repository with database manager."""
        self.db: DatabaseManager = db_manager
    
    # ------------------------------------------------------------------
    # Abstract Methods - Must Be Implemented by Child Classes
    # ------------------------------------------------------------------
    
    @abstractmethod
    def _row_to_entity(self, row: sqlite3.Row) -> T:
        """Convert database row to entity object."""
        pass
    
    @abstractmethod
    def _entity_to_values_without_id(self, entity: T) -> tuple:
        """Extract entity data as tuple for INSERT (without ID)."""
        pass
    
    @abstractmethod
    def _entity_to_values_with_id(self, entity: T) -> tuple:
        """Extract entity data as tuple for INSERT with explicit ID."""
        pass
    
    @abstractmethod
    def _entity_to_values_for_update(self, entity: T) -> tuple:
        """Extract entity data as tuple for UPDATE (ID at end)."""
        pass
    
    @abstractmethod
    def _get_insert_sql(self) -> str:
        """Get SQL for INSERT operation."""
        pass
    
    @abstractmethod
    def _get_insert_with_id_sql(self) -> str:
        """Get SQL for INSERT with explicit ID."""
        pass
    
    @abstractmethod
    def _get_select_by_id_sql(self) -> str:
        """Get SQL for SELECT by ID."""
        pass
    
    @abstractmethod
    def _get_update_sql(self) -> str:
        """Get SQL for UPDATE operation."""
        pass
    
    @abstractmethod
    def _get_delete_sql(self) -> str:
        """Get SQL for DELETE operation."""
        pass
    
    @abstractmethod
    def _get_entity_name(self) -> str:
        """Get entity name for error messages."""
        pass
    
    # ------------------------------------------------------------------
    # Helper Methods - Database Access
    # ------------------------------------------------------------------
    
    def _get_cursor(self) -> sqlite3.Cursor:
        """Get database cursor or raise if connection unavailable."""
        if self.db.conn is None:
            raise RuntimeError(self.ERROR_NO_CONNECTION)
        return self.db.conn.cursor()
    
    def _ensure_connection(self) -> None:
        """Ensure database connection exists or raise."""
        if self.db.conn is None:
            raise RuntimeError(self.ERROR_NO_CONNECTION)
    
    # ------------------------------------------------------------------
    # Common CRUD Operations
    # ------------------------------------------------------------------
    
    def insert(self, entity: T) -> int:
        """Insert new entity into database and return assigned ID."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        values: tuple = self._entity_to_values_without_id(entity)
        
        cursor.execute(self._get_insert_sql(), values)
        entity_id: int | None = cursor.lastrowid
        
        self.db.mark_dirty()
        return entity_id if entity_id is not None else self.DEFAULT_ID_ON_ERROR
    
    def insert_with_id(self, entity: T) -> None:
        """Insert entity with specific ID (for redo operations)."""
        self._ensure_connection()

        if not hasattr(entity, 'id') or entity.id is None:
            entity_name = self._get_entity_name()
            raise ValueError(self.ERROR_NO_ID_FOR_INSERT.format(entity=entity_name))
        
        cursor: sqlite3.Cursor = self._get_cursor()
        values: tuple = self._entity_to_values_with_id(entity)
        
        cursor.execute(self._get_insert_with_id_sql(), values)
        self.db.mark_dirty()
    
    def get_by_id(self, entity_id: int) -> T | None:
        """Retrieve entity by ID, return None if not found."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self._get_select_by_id_sql(), (entity_id,))
        row: sqlite3.Row | None = cursor.fetchone()
        
        if row is None:
            return None
        
        return self._row_to_entity(row)
    
    def update(self, entity: T) -> None:
        """Update existing entity in database."""
        self._ensure_connection()

        if not hasattr(entity, 'id') or entity.id is None:
            entity_name = self._get_entity_name()
            raise ValueError(self.ERROR_NO_ID_FOR_UPDATE.format(entity=entity_name))
        
        cursor: sqlite3.Cursor = self._get_cursor()
        values: tuple = self._entity_to_values_for_update(entity)
        
        cursor.execute(self._get_update_sql(), values)
        self.db.mark_dirty()
    
    def delete(self, entity_id: int) -> None:
        """Delete entity from database by ID."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self._get_delete_sql(), (entity_id,))
        self.db.mark_dirty()

>> âœ… database\db_manager.py (75 code lines)
"""Manages SQLite-based .dyn dynasty database files."""

from __future__ import annotations

import sqlite3
import shutil
import os
from typing import TYPE_CHECKING

from utils.date_formatter import DateFormatter

if TYPE_CHECKING:
    from main import MainWindow


class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""

    def __init__(self, parent: MainWindow) -> None:
        """Initialize database manager with parent window reference."""
        self.parent: MainWindow = parent
        self.conn: sqlite3.Connection | None = None
        self.file_path: str | None = None
        self._temp_file_path: str | None = None
        self._unsaved_changes: bool = False

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def is_dirty(self) -> bool:
        """Check if there are unsaved changes."""
        return self._unsaved_changes

    @property
    def is_open(self) -> bool:
        """Check if a database is currently open."""
        return self.conn is not None

    @property
    def database_name(self) -> str | None:
        """Get the filename of the current database without path."""
        return os.path.basename(self.file_path) if self.file_path else None

    @property
    def database_directory(self) -> str | None:
        """Get the directory path of the current database."""
        return os.path.dirname(self.file_path) if self.file_path else None

    @property
    def has_file_path(self) -> bool:
        """Check if database has an associated file path."""
        return self.file_path is not None

    # ------------------------------------------------------------------
    # Database Lifecycle
    # ------------------------------------------------------------------

    def new_database(self, file_path: str) -> None:
        """Create a brand-new .dyn file with the dynasty schema."""
        if os.path.exists(file_path):
            os.remove(file_path)
        
        self._connect_to_database(file_path)
        self._initialize_schema()
        self._unsaved_changes = False

    def open_database(self, file_path: str) -> None:
        """Open an existing .dyn database file."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Database file not found: {file_path}")
        
        self._connect_to_database(file_path)
        self._migrate_schema()
        self._unsaved_changes = False

    def save_database(self, path: str | None = None) -> bool:
        """Save database, optionally to a new path."""
        if self.conn is None:
            raise RuntimeError("Cannot save: no database connection")
        
        if path is None:
            self.conn.commit()
            self._unsaved_changes = False
            return True
        
        self._save_to_new_path(path)
        return True

    def close(self) -> None:
        """Close the current database connection and reset state."""
        if self.conn:
            self.conn.close()
        self.conn = None
        self.file_path = None
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # State Management
    # ------------------------------------------------------------------

    def mark_dirty(self) -> None:
        """Mark the database as having unsaved changes."""
        if self.conn is not None:
            self._unsaved_changes = True

    def mark_clean(self) -> None:
        """Mark the database as having no unsaved changes."""
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Connection Management
    # ------------------------------------------------------------------

    def _connect_to_database(self, file_path: str) -> None:
        """Establish connection to database file with proper configuration."""
        try:
            self.conn = sqlite3.connect(file_path)
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to connect to database: {e}") from e
        
        self.conn.row_factory = sqlite3.Row
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.file_path = file_path

    def _save_to_new_path(self, new_path: str) -> None:
        """Save database to a new file path."""
        if self.conn is None:
            raise RuntimeError("Cannot save: no database connection")
        
        self.conn.commit()
        current_path: str | None = self.file_path or self._temp_file_path
        
        if not current_path or not os.path.exists(current_path):
            raise RuntimeError("Cannot save: no source database file")
        
        self.conn.close()
        shutil.copy2(current_path, new_path)
        
        self._connect_to_database(new_path)
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Schema Initialization
    # ------------------------------------------------------------------

    def _initialize_schema(self) -> None:
        """Create all required tables for a new dynasty database."""
        if self.conn is None:
            raise RuntimeError("Cannot initialize schema: no database connection")
        
        cursor: sqlite3.Cursor = self.conn.cursor()
        cursor.executescript(self._get_schema_sql())
        self.conn.commit()

    @staticmethod
    def _get_schema_sql() -> str:
        """Get the complete database schema as SQL."""
        return """
        CREATE TABLE IF NOT EXISTS Person (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            middle_name TEXT DEFAULT '',
            last_name TEXT NOT NULL,
            maiden_name TEXT,
            nickname TEXT DEFAULT '',
            gender TEXT,
            birth_year INTEGER,
            birth_month INTEGER,
            birth_day INTEGER,
            death_year INTEGER,
            death_month INTEGER,
            death_day INTEGER,
            arrival_year INTEGER,
            arrival_month INTEGER,
            arrival_day INTEGER,
            moved_out_year INTEGER,
            moved_out_month INTEGER,
            moved_out_day INTEGER,
            father_id INTEGER,
            mother_id INTEGER,
            family_id INTEGER,
            dynasty_id INTEGER DEFAULT 1,
            is_founder INTEGER DEFAULT 0,
            education INTEGER DEFAULT 0,
            is_favorite INTEGER DEFAULT 0,
            notes TEXT,
            FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
        );

        CREATE TABLE IF NOT EXISTS Event (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            event_title TEXT NOT NULL,
            start_year INTEGER,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            notes TEXT,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS Marriage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            spouse1_id INTEGER,
            spouse2_id INTEGER,
            marriage_year INTEGER,
            marriage_month INTEGER,
            marriage_day INTEGER,
            dissolution_year INTEGER,
            dissolution_month INTEGER,
            dissolution_day INTEGER,
            dissolution_reason TEXT,
            marriage_type TEXT DEFAULT 'spouse',
            notes TEXT,
            FOREIGN KEY(spouse1_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL,
            FOREIGN KEY(spouse2_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL
        );

        CREATE TABLE IF NOT EXISTS Portrait (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            image_path TEXT NOT NULL,
            valid_from_year INTEGER,
            valid_from_month INTEGER,
            valid_from_day INTEGER,
            valid_to_year INTEGER,
            valid_to_month INTEGER,
            valid_to_day INTEGER,
            is_primary INTEGER DEFAULT 0,
            display_order INTEGER DEFAULT 0,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS Family (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            surname TEXT NOT NULL,
            move_in_year INTEGER,
            move_in_month INTEGER,
            move_in_day INTEGER,
            coat_of_arms_path TEXT,
            family_color TEXT,
            is_extinct INTEGER DEFAULT 0,
            notes TEXT
        );

        CREATE TABLE IF NOT EXISTS MajorEvent (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT NOT NULL,
            event_type TEXT NOT NULL,
            start_year INTEGER NOT NULL,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            description TEXT,
            color TEXT
        );

        CREATE TABLE IF NOT EXISTS PersonPosition (
            person_id INTEGER PRIMARY KEY,
            view_type TEXT NOT NULL,
            x_position REAL NOT NULL,
            y_position REAL NOT NULL,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );
        """
    
    # ------------------------------------------------------------------
    # Schema Migration
    # ------------------------------------------------------------------
    
    def _migrate_schema(self) -> None:
        """Migrate existing database schema to latest version."""
        if self.conn is None:
            raise RuntimeError("Cannot migrate schema: no database connection")
        
        cursor: sqlite3.Cursor = self.conn.cursor()
        
        self._migrate_person_table(cursor)
        self._migrate_marriage_table(cursor)
        self._migrate_event_table_data(cursor)
        self._migrate_person_table_data(cursor)
        self._migrate_marriage_table_data(cursor)

        self.conn.commit()
    
    def _migrate_person_table(self, cursor: sqlite3.Cursor) -> None:
        """Apply Person table schema migrations."""
        existing_columns: set[str] = self._get_table_columns(cursor, "Person")
        
        migrations: list[tuple[str, str]] = [
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
            ("is_favorite", "ALTER TABLE Person ADD COLUMN is_favorite INTEGER DEFAULT 0"),
        ]
        
        self._apply_column_migrations(cursor, existing_columns, migrations)
    
    def _migrate_marriage_table(self, cursor: sqlite3.Cursor) -> None:
        """Apply Marriage table schema migrations."""
        existing_columns: set[str] = self._get_table_columns(cursor, "Marriage")
        
        migrations: list[tuple[str, str]] = [
            ("notes", "ALTER TABLE Marriage ADD COLUMN notes TEXT"),
        ]
        
        self._apply_column_migrations(cursor, existing_columns, migrations)

    def _migrate_event_table_data(self, cursor: sqlite3.Cursor) -> None:
        """Normalize Event table month data."""
        self._normalize_month_columns(
            cursor,
            table="Event",
            id_column="id",
            month_columns=["start_month", "end_month"],
        )
    
    def _migrate_person_table_data(self, cursor: sqlite3.Cursor) -> None:
        """Normalize Person table month data."""
        self._normalize_month_columns(
            cursor,
            table="Person",
            id_column="id",
            month_columns=["birth_month", "death_month", "arrival_month", "moved_out_month"],
        )

    def _migrate_marriage_table_data(self, cursor: sqlite3.Cursor) -> None:
        """Normalize Marriage table month data."""
        self._normalize_month_columns(
            cursor,
            table="Marriage",
            id_column="id",
            month_columns=["marriage_month", "dissolution_month"],
        )
    
    # ------------------------------------------------------------------
    # Migration Utilities
    # ------------------------------------------------------------------

    def _normalize_month_columns(
        self,
        cursor: sqlite3.Cursor,
        *,
        table: str,
        id_column: str,
        month_columns: list[str],
    ) -> None:
        """Normalize month columns to integer values for a table."""
        columns_list: list[str] = [id_column] + month_columns
        columns_str: str = ", ".join(columns_list)
        where_clause: str = " OR ".join(f"{col} IS NOT NULL" for col in month_columns)

        cursor.execute(f"SELECT {columns_str} FROM {table} WHERE {where_clause}")

        for row in cursor.fetchall():
            row_id: int = row[id_column]
            updates: dict[str, int | None] = {
                col: DateFormatter.normalize_month(row[col]) for col in month_columns
            }

            set_clause: str = ", ".join(f"{col} = ?" for col in updates)
            values: list[int | None] = list(updates.values()) + [row_id]

            cursor.execute(f"UPDATE {table} SET {set_clause} WHERE {id_column} = ?", values)
    
    @staticmethod
    def _get_table_columns(cursor: sqlite3.Cursor, table_name: str) -> set[str]:
        """Get set of column names for a table."""
        cursor.execute(f"PRAGMA table_info({table_name})")
        return {row[1] for row in cursor.fetchall()}
    
    @staticmethod
    def _apply_column_migrations(
        cursor: sqlite3.Cursor,
        existing_columns: set[str],
        migrations: list[tuple[str, str]],
    ) -> None:
        """Apply column addition migrations if columns don't exist."""
        for column_name, sql in migrations:
            if column_name not in existing_columns:
                cursor.execute(sql)

>> âœ… database\event_repository.py (25 code lines)
"""Repository for Event database operations."""

from __future__ import annotations

import sqlite3

from database.base_repository import BaseRepository
from models.event import Event


class EventRepository(BaseRepository[Event]):
    """Handle database operations for events."""
    
    # ------------------------------------------------------------------
    # SQL Query Templates
    # ------------------------------------------------------------------
    
    SQL_INSERT: str = """
        INSERT INTO Event (
            person_id, event_type, event_title,
            start_year, start_month, start_day,
            end_year, end_month, end_day, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_INSERT_WITH_ID: str = """
        INSERT INTO Event (
            id, person_id, event_type, event_title,
            start_year, start_month, start_day,
            end_year, end_month, end_day, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_SELECT_BY_ID: str = """
        SELECT * FROM Event WHERE id = ?
    """
    
    SQL_SELECT_BY_PERSON: str = """
        SELECT * FROM Event
        WHERE person_id = ?
        ORDER BY start_year, start_month, start_day
    """
    
    SQL_UPDATE: str = """
        UPDATE Event SET
            person_id = ?,
            event_type = ?,
            event_title = ?,
            start_year = ?,
            start_month = ?,
            start_day = ?,
            end_year = ?,
            end_month = ?,
            end_day = ?,
            notes = ?
        WHERE id = ?
    """
    
    SQL_DELETE: str = "DELETE FROM Event WHERE id = ?"
    
    # ------------------------------------------------------------------
    # Default Values
    # ------------------------------------------------------------------
    
    DEFAULT_EVENT_TYPE: str = ""
    DEFAULT_EVENT_TITLE: str = ""
    DEFAULT_NOTES: str = ""
    
    # ------------------------------------------------------------------
    # Abstract Method Implementations (Required by BaseRepository)
    # ------------------------------------------------------------------
    
    def _row_to_entity(self, row: sqlite3.Row) -> Event:
        """Convert database row to Event object."""
        return Event(
            id=row['id'],
            person_id=row['person_id'],
            event_type=row['event_type'] or self.DEFAULT_EVENT_TYPE,
            event_title=row['event_title'] or self.DEFAULT_EVENT_TITLE,
            start_year=self._to_int(row['start_year']),
            start_month=self._to_int(row['start_month']),
            start_day=self._to_int(row['start_day']),
            end_year=self._to_int(row['end_year']),
            end_month=self._to_int(row['end_month']),
            end_day=self._to_int(row['end_day']),
            notes=row['notes'] or self.DEFAULT_NOTES
        )
    
    def _entity_to_values_without_id(self, entity: Event) -> tuple:
        """Extract event data as tuple for INSERT (without ID)."""
        return (
            entity.person_id, entity.event_type, entity.event_title,
            entity.start_year, entity.start_month, entity.start_day,
            entity.end_year, entity.end_month, entity.end_day, entity.notes
        )
    
    def _entity_to_values_with_id(self, entity: Event) -> tuple:
        """Extract event data as tuple for INSERT with explicit ID."""
        return (
            entity.id,
            entity.person_id, entity.event_type, entity.event_title,
            entity.start_year, entity.start_month, entity.start_day,
            entity.end_year, entity.end_month, entity.end_day, entity.notes
        )
    
    def _entity_to_values_for_update(self, entity: Event) -> tuple:
        """Extract event data as tuple for UPDATE (ID at end)."""
        return (
            entity.person_id, entity.event_type, entity.event_title,
            entity.start_year, entity.start_month, entity.start_day,
            entity.end_year, entity.end_month, entity.end_day, entity.notes,
            entity.id
        )
    
    def _get_insert_sql(self) -> str:
        """Get SQL for INSERT operation."""
        return self.SQL_INSERT
    
    def _get_insert_with_id_sql(self) -> str:
        """Get SQL for INSERT with explicit ID."""
        return self.SQL_INSERT_WITH_ID
    
    def _get_select_by_id_sql(self) -> str:
        """Get SQL for SELECT by ID."""
        return self.SQL_SELECT_BY_ID
    
    def _get_update_sql(self) -> str:
        """Get SQL for UPDATE operation."""
        return self.SQL_UPDATE
    
    def _get_delete_sql(self) -> str:
        """Get SQL for DELETE operation."""
        return self.SQL_DELETE
    
    def _get_entity_name(self) -> str:
        """Get entity name for error messages."""
        return "Event"
    
    # ------------------------------------------------------------------
    # Event-Specific Query Operations
    # ------------------------------------------------------------------
    
    def get_by_person(self, person_id: int) -> list[Event]:
        """Get all events for a person, sorted chronologically."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_BY_PERSON, (person_id,))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    @staticmethod
    def _to_int(value: int | None) -> int | None:
        """Convert database value to int or None."""
        return int(value) if value is not None else None

>> âœ… database\marriage_repository.py (44 code lines)
"""Repository for Marriage database operations."""

from __future__ import annotations

import sqlite3

from database.base_repository import BaseRepository
from models.marriage import Marriage


class MarriageRepository(BaseRepository[Marriage]):
    """Handle database operations for marriages."""
    
    # ------------------------------------------------------------------
    # SQL Query Templates
    # ------------------------------------------------------------------
    
    SQL_INSERT: str = """
        INSERT INTO Marriage (
            spouse1_id, spouse2_id,
            marriage_year, marriage_month, marriage_day,
            dissolution_year, dissolution_month, dissolution_day,
            dissolution_reason, marriage_type, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_INSERT_WITH_ID: str = """
        INSERT INTO Marriage (
            id, spouse1_id, spouse2_id,
            marriage_year, marriage_month, marriage_day,
            dissolution_year, dissolution_month, dissolution_day,
            dissolution_reason, marriage_type, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_SELECT_BY_ID: str = """
        SELECT * FROM Marriage WHERE id = ?
    """
    
    SQL_SELECT_BY_PERSON: str = """
        SELECT * FROM Marriage
        WHERE spouse1_id = ? OR spouse2_id = ?
        ORDER BY marriage_year, marriage_month
    """
    
    SQL_SELECT_ACTIVE_BY_PERSON: str = """
        SELECT * FROM Marriage
        WHERE (spouse1_id = ? OR spouse2_id = ?)
          AND dissolution_year IS NULL
        ORDER BY marriage_year, marriage_month
    """
    
    SQL_UPDATE: str = """
        UPDATE Marriage SET
            spouse1_id = ?,
            spouse2_id = ?,
            marriage_year = ?,
            marriage_month = ?,
            marriage_day = ?,
            dissolution_year = ?,
            dissolution_month = ?,
            dissolution_day = ?,
            dissolution_reason = ?,
            marriage_type = ?,
            notes = ?
        WHERE id = ?
    """
    
    SQL_DELETE: str = "DELETE FROM Marriage WHERE id = ?"
    
    SQL_END_MARRIAGE: str = """
        UPDATE Marriage SET
            dissolution_year = ?,
            dissolution_month = ?,
            dissolution_day = ?,
            dissolution_reason = ?
        WHERE id = ?
    """
    
    # ------------------------------------------------------------------
    # Default Values
    # ------------------------------------------------------------------
    
    DEFAULT_MARRIAGE_TYPE: str = "spouse"
    DEFAULT_NOTES: str = ""
    DEFAULT_DISSOLUTION_REASON: str = ""
    
    # ------------------------------------------------------------------
    # Abstract Method Implementations (Required by BaseRepository)
    # ------------------------------------------------------------------
    
    def _row_to_entity(self, row: sqlite3.Row) -> Marriage:
        """Convert database row to Marriage object."""
        return Marriage(
            id=row['id'],
            spouse1_id=row['spouse1_id'],
            spouse2_id=row['spouse2_id'],
            marriage_year=row['marriage_year'],
            marriage_month=row['marriage_month'],
            marriage_day=row['marriage_day'],
            dissolution_year=row['dissolution_year'],
            dissolution_month=row['dissolution_month'],
            dissolution_day=row['dissolution_day'],
            dissolution_reason=row['dissolution_reason'] or self.DEFAULT_DISSOLUTION_REASON,
            marriage_type=row['marriage_type'] or self.DEFAULT_MARRIAGE_TYPE,
            notes=row['notes'] or self.DEFAULT_NOTES
        )
    
    def _entity_to_values_without_id(self, entity: Marriage) -> tuple:
        """Extract marriage data as tuple for INSERT (without ID)."""
        return (
            entity.spouse1_id, entity.spouse2_id,
            entity.marriage_year, entity.marriage_month, entity.marriage_day,
            entity.dissolution_year, entity.dissolution_month, entity.dissolution_day,
            entity.dissolution_reason, entity.marriage_type, entity.notes
        )
    
    def _entity_to_values_with_id(self, entity: Marriage) -> tuple:
        """Extract marriage data as tuple for INSERT with explicit ID."""
        return (
            entity.id,
            entity.spouse1_id, entity.spouse2_id,
            entity.marriage_year, entity.marriage_month, entity.marriage_day,
            entity.dissolution_year, entity.dissolution_month, entity.dissolution_day,
            entity.dissolution_reason, entity.marriage_type, entity.notes
        )
    
    def _entity_to_values_for_update(self, entity: Marriage) -> tuple:
        """Extract marriage data as tuple for UPDATE (ID at end)."""
        return (
            entity.spouse1_id, entity.spouse2_id,
            entity.marriage_year, entity.marriage_month, entity.marriage_day,
            entity.dissolution_year, entity.dissolution_month, entity.dissolution_day,
            entity.dissolution_reason, entity.marriage_type, entity.notes,
            entity.id
        )
    
    def _get_insert_sql(self) -> str:
        """Get SQL for INSERT operation."""
        return self.SQL_INSERT
    
    def _get_insert_with_id_sql(self) -> str:
        """Get SQL for INSERT with explicit ID."""
        return self.SQL_INSERT_WITH_ID
    
    def _get_select_by_id_sql(self) -> str:
        """Get SQL for SELECT by ID."""
        return self.SQL_SELECT_BY_ID
    
    def _get_update_sql(self) -> str:
        """Get SQL for UPDATE operation."""
        return self.SQL_UPDATE
    
    def _get_delete_sql(self) -> str:
        """Get SQL for DELETE operation."""
        return self.SQL_DELETE
    
    def _get_entity_name(self) -> str:
        """Get entity name for error messages."""
        return "Marriage"
    
    # ------------------------------------------------------------------
    # Marriage-Specific Query Operations
    # ------------------------------------------------------------------
    
    def get_by_person(self, person_id: int) -> list[Marriage]:
        """Get all marriages for a person (as either spouse)."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_BY_PERSON, (person_id, person_id))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    def get_active_marriages(self, person_id: int) -> list[Marriage]:
        """Get all active (not ended) marriages for a person."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_ACTIVE_BY_PERSON, (person_id, person_id))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    def end_marriage(
        self,
        marriage_id: int,
        dissolution_year: int,
        dissolution_month: int | None = None,
        dissolution_day: int | None = None,
        reason: str = ""
    ) -> None:
        """End a marriage by setting dissolution date and reason."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(
            self.SQL_END_MARRIAGE,
            (dissolution_year, dissolution_month, dissolution_day, reason, marriage_id)
        )
        self.db.mark_dirty()
    
    @staticmethod
    def get_spouse_id(marriage: Marriage, person_id: int) -> int | None:
        """Get the spouse ID for a given person in a marriage."""
        if marriage.spouse1_id == person_id:
            return marriage.spouse2_id
        elif marriage.spouse2_id == person_id:
            return marriage.spouse1_id
        return None

>> âœ… database\person_repository.py (55 code lines)
"""Database repository for Person entity operations."""

from __future__ import annotations

import sqlite3
from typing import TYPE_CHECKING

from database.base_repository import BaseRepository
from models.person import Person

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class PersonRepository(BaseRepository[Person]):
    """Handles all database operations for Person objects."""
    
    # ------------------------------------------------------------------
    # SQL Query Templates
    # ------------------------------------------------------------------
    
    SQL_INSERT: str = """
        INSERT INTO Person (
            first_name, middle_name, last_name, maiden_name, nickname,
            gender, birth_year, birth_month, birth_day,
            death_year, death_month, death_day,
            arrival_year, arrival_month, arrival_day,
            moved_out_year, moved_out_month, moved_out_day,
            father_id, mother_id, family_id,
            dynasty_id, is_founder, education, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_INSERT_WITH_ID: str = """
        INSERT INTO Person (
            id, first_name, middle_name, last_name, maiden_name, nickname,
            gender, birth_year, birth_month, birth_day,
            death_year, death_month, death_day,
            arrival_year, arrival_month, arrival_day,
            moved_out_year, moved_out_month, moved_out_day,
            father_id, mother_id, family_id,
            dynasty_id, is_founder, education, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """
    
    SQL_SELECT_BY_ID: str = "SELECT * FROM Person WHERE id = ?"
    
    SQL_SELECT_ALL: str = "SELECT * FROM Person ORDER BY last_name, first_name"
    
    SQL_SELECT_BY_NAME: str = """
        SELECT * FROM Person 
        WHERE first_name = ? AND last_name = ?
        ORDER BY birth_year
    """
    
    SQL_SELECT_CHILDREN: str = """
        SELECT * FROM Person 
        WHERE father_id = ? OR mother_id = ?
        ORDER BY birth_year, birth_month, birth_day
    """
    
    SQL_SELECT_ALIVE_IN_YEAR: str = """
        SELECT * FROM Person
        WHERE birth_year <= ? 
        AND (death_year IS NULL OR death_year >= ?)
        ORDER BY birth_year
    """
    
    SQL_UPDATE: str = """
        UPDATE Person SET
            first_name = ?, middle_name = ?, last_name = ?,
            maiden_name = ?, nickname = ?,
            gender = ?, birth_year = ?, birth_month = ?, birth_day = ?,
            death_year = ?, death_month = ?, death_day = ?,
            arrival_year = ?, arrival_month = ?, arrival_day = ?,
            moved_out_year = ?, moved_out_month = ?, moved_out_day = ?,
            father_id = ?, mother_id = ?, family_id = ?,
            dynasty_id = ?, is_founder = ?, education = ?, notes = ?
        WHERE id = ?
    """
    
    SQL_DELETE: str = "DELETE FROM Person WHERE id = ?"
    
    # ------------------------------------------------------------------
    # Default Values
    # ------------------------------------------------------------------
    
    DEFAULT_DYNASTY_ID: int = 1
    FOUNDER_FLAG_TRUE: int = 1
    FOUNDER_FLAG_FALSE: int = 0
    DEFAULT_EDUCATION: int = 0
    DEFAULT_NOTES: str = ""
    
    # ------------------------------------------------------------------
    # Abstract Method Implementations (Required by BaseRepository)
    # ------------------------------------------------------------------
    
    def _row_to_entity(self, row: sqlite3.Row) -> Person:
        """Convert database row to Person object."""
        return Person(
            id=row['id'],
            first_name=row['first_name'],
            middle_name=row['middle_name'],
            last_name=row['last_name'],
            maiden_name=row['maiden_name'],
            nickname=row['nickname'],
            gender=row['gender'],
            birth_year=row['birth_year'],
            birth_month=row['birth_month'],
            birth_day=row['birth_day'],
            death_year=row['death_year'],
            death_month=row['death_month'],
            death_day=row['death_day'],
            arrival_year=row['arrival_year'],
            arrival_month=row['arrival_month'],
            arrival_day=row['arrival_day'],
            moved_out_year=row['moved_out_year'],
            moved_out_month=row['moved_out_month'],
            moved_out_day=row['moved_out_day'],
            father_id=row['father_id'],
            mother_id=row['mother_id'],
            family_id=row['family_id'],
            dynasty_id=row['dynasty_id'] or self.DEFAULT_DYNASTY_ID,
            is_founder=bool(row['is_founder']),
            education=row['education'] or self.DEFAULT_EDUCATION,
            notes=row['notes'] or self.DEFAULT_NOTES
        )
    
    def _entity_to_values_without_id(self, entity: Person) -> tuple:
        """Extract person data as tuple for INSERT (without ID)."""
        return (
            entity.first_name, entity.middle_name, entity.last_name,
            entity.maiden_name, entity.nickname,
            entity.gender, entity.birth_year, entity.birth_month, entity.birth_day,
            entity.death_year, entity.death_month, entity.death_day,
            entity.arrival_year, entity.arrival_month, entity.arrival_day,
            entity.moved_out_year, entity.moved_out_month, entity.moved_out_day,
            entity.father_id, entity.mother_id, entity.family_id,
            entity.dynasty_id,
            self.FOUNDER_FLAG_TRUE if entity.is_founder else self.FOUNDER_FLAG_FALSE,
            entity.education,
            entity.notes
        )

    def _entity_to_values_with_id(self, entity: Person) -> tuple:
        """Extract person data as tuple for INSERT with explicit ID."""
        return (
            entity.id,
            entity.first_name, entity.middle_name, entity.last_name,
            entity.maiden_name, entity.nickname,
            entity.gender, entity.birth_year, entity.birth_month, entity.birth_day,
            entity.death_year, entity.death_month, entity.death_day,
            entity.arrival_year, entity.arrival_month, entity.arrival_day,
            entity.moved_out_year, entity.moved_out_month, entity.moved_out_day,
            entity.father_id, entity.mother_id, entity.family_id,
            entity.dynasty_id,
            self.FOUNDER_FLAG_TRUE if entity.is_founder else self.FOUNDER_FLAG_FALSE,
            entity.education,
            entity.notes
        )

    def _entity_to_values_for_update(self, entity: Person) -> tuple:
        """Extract person data as tuple for UPDATE (ID at end)."""
        return (
            entity.first_name, entity.middle_name, entity.last_name,
            entity.maiden_name, entity.nickname,
            entity.gender, entity.birth_year, entity.birth_month, entity.birth_day,
            entity.death_year, entity.death_month, entity.death_day,
            entity.arrival_year, entity.arrival_month, entity.arrival_day,
            entity.moved_out_year, entity.moved_out_month, entity.moved_out_day,
            entity.father_id, entity.mother_id, entity.family_id,
            entity.dynasty_id,
            self.FOUNDER_FLAG_TRUE if entity.is_founder else self.FOUNDER_FLAG_FALSE,
            entity.education,
            entity.notes,
            entity.id
        )
    
    def _get_insert_sql(self) -> str:
        """Get SQL for INSERT operation."""
        return self.SQL_INSERT
    
    def _get_insert_with_id_sql(self) -> str:
        """Get SQL for INSERT with explicit ID."""
        return self.SQL_INSERT_WITH_ID
    
    def _get_select_by_id_sql(self) -> str:
        """Get SQL for SELECT by ID."""
        return self.SQL_SELECT_BY_ID
    
    def _get_update_sql(self) -> str:
        """Get SQL for UPDATE operation."""
        return self.SQL_UPDATE
    
    def _get_delete_sql(self) -> str:
        """Get SQL for DELETE operation."""
        return self.SQL_DELETE
    
    def _get_entity_name(self) -> str:
        """Get entity name for error messages."""
        return "Person"
    
    # ------------------------------------------------------------------
    # Person-Specific Query Operations
    # ------------------------------------------------------------------
    
    def get_all(self) -> list[Person]:
        """Retrieve all people from database."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_ALL)
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    def get_by_name(self, first_name: str, last_name: str) -> list[Person]:
        """Find people by first and last name."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_BY_NAME, (first_name, last_name))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    def get_children(self, parent_id: int) -> list[Person]:
        """Retrieve all children of a given parent."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_CHILDREN, (parent_id, parent_id))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]
    
    def get_alive_in_year(self, year: int) -> list[Person]:
        """Retrieve all people alive in a given year."""
        self._ensure_connection()
        
        cursor: sqlite3.Cursor = self._get_cursor()
        cursor.execute(self.SQL_SELECT_ALIVE_IN_YEAR, (year, year))
        rows: list[sqlite3.Row] = cursor.fetchall()
        
        return [self._row_to_entity(row) for row in rows]


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MODELS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ models\__init__.py (0 code lines)


>> âœ… models\event.py (45 code lines)
"""Data model for Event entities."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle


@dataclass
class Event:
    """Represents a life event for a person."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    EVENT_TYPE_BIRTH: str = "Birth"
    EVENT_TYPE_MARRIAGE: str = "Marriage"
    EVENT_TYPE_DEATH: str = "Death"
    EVENT_TYPE_JOB: str = "Job"
    EVENT_TYPE_MOVE: str = "Move"
    EVENT_TYPE_EDUCATION: str = "Education"
    EVENT_TYPE_OTHER: str = "Other"
    
    DATE_UNKNOWN: str = "Unknown"
    DATE_ONGOING: str = "Ongoing"
    DATE_PRESENT: str = "Present"
    
    # ------------------------------------------------------------------
    # Database Identity
    # ------------------------------------------------------------------
    
    id: int | None = None
    
    # ------------------------------------------------------------------
    # Associated Person
    # ------------------------------------------------------------------
    
    person_id: int | None = None
    
    # ------------------------------------------------------------------
    # Event Details
    # ------------------------------------------------------------------
    
    event_type: str = ""
    event_title: str = ""
    
    # ------------------------------------------------------------------
    # Start Date
    # ------------------------------------------------------------------
    
    start_year: int | None = None
    start_month: int | None = None
    start_day: int | None = None
    
    # ------------------------------------------------------------------
    # End Date
    # ------------------------------------------------------------------
    
    end_year: int | None = None
    end_month: int | None = None
    end_day: int | None = None
    
    # ------------------------------------------------------------------
    # Notes
    # ------------------------------------------------------------------
    
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties - Status
    # ------------------------------------------------------------------
    
    @property
    def is_ongoing(self) -> bool:
        """Check if the event is currently ongoing (no end date)."""
        return self.end_year is None
    
    # ------------------------------------------------------------------
    # Computed Properties - Date Formatting
    # ------------------------------------------------------------------
    
    @property
    def start_date_string(self) -> str:
        """Format start date as readable string."""
        if self.start_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.start_year,
            month=self.start_month,
            day=self.start_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def end_date_string(self) -> str:
        """Format end date as readable string."""
        if self.end_year is None:
            return self.DATE_ONGOING if self.start_year else ""
        
        date_parts: DateParts = DateParts(
            year=self.end_year,
            month=self.end_month,
            day=self.end_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def date_range_string(self) -> str:
        """Get formatted date range for display."""
        if self.is_ongoing:
            return f"{self.start_date_string} - {self.DATE_PRESENT}"
        elif self.end_year:
            return f"{self.start_date_string} - {self.end_date_string}"
        else:
            return self.start_date_string
    
    # ------------------------------------------------------------------
    # Computed Properties - Duration
    # ------------------------------------------------------------------
    
    @property
    def duration_years(self) -> int | None:
        """Calculate event duration in years (None if ongoing or no dates)."""
        if self.start_year is None:
            return None
        
        if self.end_year:
            return self.end_year - self.start_year
        
        return None

>> ðŸ“‹ models\family.py (15 code lines)
"""Data model for Family dynasties."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle


@dataclass
class Family:
    """Represents a family dynasty grouping."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    DATE_UNKNOWN: str = "Unknown"
    DEFAULT_FAMILY_NAME: str = "Unknown Family"
    FAMILY_NAME_SUFFIX: str = " Family"
    
    # Database Identity
    id: int | None = None

    # Family Identification
    surname: str = ""

    # Move-In Date 
    move_in_year: int | None = None
    move_in_month: int | None = None
    move_in_day: int | None = None
    
    # Visual Representation
    coat_of_arms_path: str = ""
    family_color: str = ""

    # Status
    is_extinct: bool = False
    
    # Notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties - Dates
    # ------------------------------------------------------------------
    
    @property
    def move_in_date_string(self) -> str:
        """Format move-in date as readable string."""
        if self.move_in_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.move_in_year,
            month=self.move_in_month,
            day=self.move_in_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    # ------------------------------------------------------------------
    # Computed Properties - Display
    # ------------------------------------------------------------------
    
    @property
    def display_name(self) -> str:
        """Get family display name."""
        return f"{self.surname}{self.FAMILY_NAME_SUFFIX}" if self.surname else self.DEFAULT_FAMILY_NAME

>> âœ… models\major_event.py (53 code lines)
"""Data model for MajorEvent entities."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle


@dataclass
class MajorEvent:
    """Represents a major historical event affecting multiple families."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    EVENT_TYPE_WAR: str = "War"
    EVENT_TYPE_PLAGUE: str = "Plague"
    EVENT_TYPE_FAMINE: str = "Famine"
    EVENT_TYPE_DISASTER: str = "Disaster"
    EVENT_TYPE_CELEBRATION: str = "Celebration"
    EVENT_TYPE_POLITICAL: str = "Political"
    EVENT_TYPE_OTHER: str = "Other"
    
    DATE_UNKNOWN: str = "Unknown"
    DATE_ONGOING: str = "Ongoing"
    DATE_PRESENT: str = "Present"
    
    # ------------------------------------------------------------------
    # Database Identity
    # ------------------------------------------------------------------
    
    id: int | None = None
    
    # ------------------------------------------------------------------
    # Event Details
    # ------------------------------------------------------------------
    
    event_name: str = ""
    event_type: str = ""
    description: str = ""
    
    # ------------------------------------------------------------------
    # Start Date
    # ------------------------------------------------------------------
    
    start_year: int | None = None
    start_month: int | None = None
    start_day: int | None = None
    
    # ------------------------------------------------------------------
    # End Date
    # ------------------------------------------------------------------
    
    end_year: int | None = None
    end_month: int | None = None
    end_day: int | None = None
    
    # ------------------------------------------------------------------
    # Visual Representation
    # ------------------------------------------------------------------
    
    color: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties - Status
    # ------------------------------------------------------------------
    
    @property
    def is_ongoing(self) -> bool:
        """Check if the event is currently ongoing."""
        return self.end_year is None
    
    # ------------------------------------------------------------------
    # Computed Properties - Date Formatting
    # ------------------------------------------------------------------
    
    @property
    def start_date_string(self) -> str:
        """Format start date as readable string."""
        if self.start_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.start_year,
            month=self.start_month,
            day=self.start_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def end_date_string(self) -> str:
        """Format end date as readable string."""
        if self.end_year is None:
            return self.DATE_ONGOING
        
        date_parts: DateParts = DateParts(
            year=self.end_year,
            month=self.end_month,
            day=self.end_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def date_range_string(self) -> str:
        """Get formatted date range for display."""
        if self.is_ongoing:
            return f"{self.start_date_string} - {self.DATE_PRESENT}"
        elif self.end_year:
            return f"{self.start_date_string} - {self.end_date_string}"
        else:
            return self.start_date_string
    
    # ------------------------------------------------------------------
    # Computed Properties - Duration
    # ------------------------------------------------------------------
    
    @property
    def duration_years(self) -> int | None:
        """Calculate event duration in years (None if ongoing or no dates)."""
        if self.start_year is None:
            return None
        
        if self.end_year:
            return self.end_year - self.start_year
        
        return None
    
    @property
    def duration_string(self) -> str:
        """Get human-readable duration."""
        duration: int | None = self.duration_years
        
        if duration is None:
            if self.is_ongoing:
                return self.DATE_ONGOING
            return self.DATE_UNKNOWN
        
        if duration == 0:
            return "Less than 1 year"
        
        return f"{duration} year{'s' if duration != 1 else ''}"

>> âœ… models\marriage.py (82 code lines)
"""Data model for Marriage relationships."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle


@dataclass
class Marriage:
    """Represents a marriage relationship between two people."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    DEFAULT_MARRIAGE_TYPE: str = "spouse"
    
    MARRIAGE_TYPE_SPOUSE: str = "spouse"
    MARRIAGE_TYPE_PARTNER: str = "partner"
    MARRIAGE_TYPE_COMMON_LAW: str = "common-law"
    
    DISSOLUTION_DEATH: str = "Death"
    DISSOLUTION_DIVORCE: str = "Divorce"
    DISSOLUTION_ANNULMENT: str = "Annulment"
    
    STATUS_ACTIVE: str = "Active"
    STATUS_ENDED: str = "Ended"
    
    DATE_UNKNOWN: str = "Unknown"
    DATE_ONGOING: str = "Ongoing"
    DURATION_UNKNOWN: str = "Unknown duration"
    DURATION_ONGOING: str = "Ongoing"
    DURATION_LESS_THAN_MONTH: str = "Less than 1 month"
    
    APPROX_DAYS_PER_MONTH: int = 30
    MONTHS_PER_YEAR: int = 12
    DEFAULT_MONTH: int = 1
    DEFAULT_DAY: int = 1
    
    # Database Identity
    id: int | None = None
    
    # Spouses
    spouse1_id: int | None = None
    spouse2_id: int | None = None
    
    # Marriage Date
    marriage_year: int | None = None
    marriage_month: int | None = None
    marriage_day: int | None = None
    
    # Dissolution Date
    dissolution_year: int | None = None
    dissolution_month: int | None = None
    dissolution_day: int | None = None
    dissolution_reason: str = ""
    
    # Marriage Type
    marriage_type: str = DEFAULT_MARRIAGE_TYPE
    
    # Notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties - Status
    # ------------------------------------------------------------------
    
    @property
    def is_active(self) -> bool:
        """Check if the marriage is currently active (not dissolved)."""
        return self.dissolution_year is None
    
    @property
    def status_string(self) -> str:
        """Get marriage status as readable string."""
        if self.is_active:
            return self.STATUS_ACTIVE
        
        if self.dissolution_reason:
            return f"{self.STATUS_ENDED} ({self.dissolution_reason})"
        
        return self.STATUS_ENDED
    
    # ------------------------------------------------------------------
    # Computed Properties - Date Formatting
    # ------------------------------------------------------------------
    
    @property
    def marriage_date_string(self) -> str:
        """Format marriage date as readable string."""
        if self.marriage_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.marriage_year,
            month=self.marriage_month,
            day=self.marriage_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def dissolution_date_string(self) -> str:
        """Format dissolution date as readable string."""
        if self.dissolution_year is None:
            return ""
        
        date_parts: DateParts = DateParts(
            year=self.dissolution_year,
            month=self.dissolution_month,
            day=self.dissolution_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    # ------------------------------------------------------------------
    # Computed Properties - Duration
    # ------------------------------------------------------------------
    
    @property
    def duration_years(self) -> int | None:
        """Calculate marriage duration in years only (for sorting/filtering)."""
        if self.marriage_year is None or self.is_active or self.dissolution_year is None:
            return None
        
        return self.dissolution_year - self.marriage_year
    
    @property
    def duration_string(self) -> str:
        """Calculate marriage duration as readable string with years, months, days."""
        if self.marriage_year is None:
            return self.DURATION_UNKNOWN
        
        if self.is_active or self.dissolution_year is None:
            return self.DURATION_ONGOING
        
        start_year: int = self.marriage_year
        start_month: int = self.marriage_month or self.DEFAULT_MONTH
        start_day: int = self.marriage_day or self.DEFAULT_DAY
        
        end_year: int = self.dissolution_year
        end_month: int = self.dissolution_month or self.DEFAULT_MONTH
        end_day: int = self.dissolution_day or self.DEFAULT_DAY
        
        years: int = end_year - start_year
        months: int = end_month - start_month
        days: int = end_day - start_day
        
        if days < 0:
            months -= 1
            days += self.APPROX_DAYS_PER_MONTH
        
        if months < 0:
            years -= 1
            months += self.MONTHS_PER_YEAR
        
        parts: list[str] = []
        
        if years > 0:
            parts.append(f"{years} year{'s' if years != 1 else ''}")
        
        if months > 0:
            parts.append(f"{months} month{'s' if months != 1 else ''}")
        
        if days > 0 and self.marriage_day and self.dissolution_day:
            parts.append(f"{days} day{'s' if days != 1 else ''}")
        
        if not parts:
            return self.DURATION_LESS_THAN_MONTH
        
        return ", ".join(parts)

>> âœ… models\person.py (69 code lines)
"""Data model for Person entities."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle, DateOrder


@dataclass
class Person:
    """Represents a person in a dynasty with flexible date precision."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    DEFAULT_GENDER: str = "Unknown"
    DEFAULT_DYNASTY_ID: int = 1
    DEFAULT_EDUCATION: int = 0
    
    GENDER_MALE: str = "Male"
    GENDER_FEMALE: str = "Female"
    GENDER_UNKNOWN: str = "Unknown"
    GENDER_OTHER: str = "Other"
    
    DATE_UNKNOWN: str = "Unknown"
    DATE_ALIVE: str = "Alive"
    DATE_SEPARATOR: str = "-"
    DATE_PLACEHOLDER: str = "?"
    
    # Database Identity
    id: int | None = None
    dynasty_id: int = DEFAULT_DYNASTY_ID
    family_id: int | None = None
    
    # Name Fields
    first_name: str = ""
    middle_name: str = ""
    last_name: str = ""
    maiden_name: str = ""
    nickname: str = ""
    
    # Biological Information
    gender: str = DEFAULT_GENDER
    
    # Birth Date
    birth_year: int | None = None
    birth_month: int | None = None
    birth_day: int | None = None
    
    # Death Date
    death_year: int | None = None
    death_month: int | None = None
    death_day: int | None = None
    
    # Arrival/Departure Dates
    arrival_year: int | None = None
    arrival_month: int | None = None
    arrival_day: int | None = None
    moved_out_year: int | None = None
    moved_out_month: int | None = None
    moved_out_day: int | None = None
    
    # Relationships
    father_id: int | None = None
    mother_id: int | None = None
    
    # Game-Specific Fields
    is_founder: bool = False
    education: int = DEFAULT_EDUCATION
    
    # User Notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties - Names
    # ------------------------------------------------------------------
    
    @property
    def full_name(self) -> str:
        """Get full name with optional middle name and nickname."""
        parts: list[str] = [self.first_name]
        
        if self.middle_name:
            parts.append(self.middle_name)
        
        parts.append(self.last_name)
        name: str = " ".join(parts)
        
        if self.nickname:
            name += f' "{self.nickname}"'
        
        return name
    
    @property
    def display_name(self) -> str:
        """Get display name (first + last, no middle or nickname)."""
        return f"{self.first_name} {self.last_name}"
    
    # ------------------------------------------------------------------
    # Computed Properties - Life Status
    # ------------------------------------------------------------------
    
    @property
    def is_deceased(self) -> bool:
        """Check if person is deceased."""
        return self.death_year is not None
    
    def is_alive_in_year(self, year: int) -> bool:
        """Check if person was alive in a given year."""
        if self.birth_year is None or year < self.birth_year:
            return False
        
        if self.death_year is None:
            return True
        
        return year <= self.death_year
    
    # ------------------------------------------------------------------
    # Computed Properties - Age Calculations
    # ------------------------------------------------------------------
    
    def get_age(self, current_year: int) -> int | None:
        """Calculate age at a given year."""
        if self.birth_year is None:
            return None
        
        if self.death_year is not None and current_year > self.death_year:
            return None
        
        return current_year - self.birth_year
    
    def get_age_at_death(self) -> int | None:
        """Calculate age at death, or None if not deceased or birth year unknown."""
        if not self.is_deceased or self.birth_year is None or self.death_year is None:
            return None
        
        return self.death_year - self.birth_year
    
    # ------------------------------------------------------------------
    # Computed Properties - Date Formatting
    # ------------------------------------------------------------------
    
    @property
    def birth_date_string(self) -> str:
        """Format birth date as readable string."""
        if self.birth_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.birth_year,
            month=self.birth_month,
            day=self.birth_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            order=DateOrder.DMY,
            month_style=MonthStyle.NUMERIC_PADDED,
            separator="/",
            pad_day=True
        )
    
    @property
    def death_date_string(self) -> str:
        """Format death date as readable string."""
        if self.death_year is None:
            return self.DATE_ALIVE
        
        date_parts: DateParts = DateParts(
            year=self.death_year,
            month=self.death_month,
            day=self.death_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            order=DateOrder.DMY,
            month_style=MonthStyle.NUMERIC_PADDED,
            separator="/",
            pad_day=True
        )
    
    @property
    def lifespan_string(self) -> str:
        """Get lifespan as formatted string (e.g., '1420-1475' or '1450-')."""
        birth: str = str(self.birth_year) if self.birth_year else self.DATE_PLACEHOLDER
        death: str = str(self.death_year) if self.death_year else ""
        return f"{birth}{self.DATE_SEPARATOR}{death}"

>> âœ… models\portrait.py (56 code lines)
"""Data model for Portrait entities."""

from __future__ import annotations

from dataclasses import dataclass

from utils.date_formatter import DateFormatter, DateParts, MonthStyle


@dataclass
class Portrait:
    """Represents a portrait image for a person."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    DATE_UNKNOWN: str = "Unknown"
    DATE_PRESENT: str = "Present"
    
    DEFAULT_DISPLAY_ORDER: int = 0
    
    # Database Identity
    id: int | None = None
    
    # Associated Person
    person_id: int | None = None
    
    # Image Path
    image_path: str = ""
    
    # Valid From Date
    valid_from_year: int | None = None
    valid_from_month: int | None = None
    valid_from_day: int | None = None
    
    # Valid To Date
    valid_to_year: int | None = None
    valid_to_month: int | None = None
    valid_to_day: int | None = None
    
    # Display Properties
    is_primary: bool = False
    display_order: int = DEFAULT_DISPLAY_ORDER
    
    # ------------------------------------------------------------------
    # Computed Properties - Date Formatting
    # ------------------------------------------------------------------
    
    @property
    def valid_from_date_string(self) -> str:
        """Format valid-from date as readable string."""
        if self.valid_from_year is None:
            return self.DATE_UNKNOWN
        
        date_parts: DateParts = DateParts(
            year=self.valid_from_year,
            month=self.valid_from_month,
            day=self.valid_from_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def valid_to_date_string(self) -> str:
        """Format valid-to date as readable string."""
        if self.valid_to_year is None:
            return self.DATE_PRESENT
        
        date_parts: DateParts = DateParts(
            year=self.valid_to_year,
            month=self.valid_to_month,
            day=self.valid_to_day
        )
        
        return DateFormatter.format_display(
            date=date_parts,
            month_style=MonthStyle.FULL_NAME,
            separator=" "
        )
    
    @property
    def validity_range_string(self) -> str:
        """Get formatted validity range for display."""
        return f"{self.valid_from_date_string} - {self.valid_to_date_string}"
    
    # ------------------------------------------------------------------
    # Validity Checking
    # ------------------------------------------------------------------
    
    def is_valid_for_date(
        self,
        year: int,
        month: int | None = None,
        day: int | None = None
    ) -> bool:
        """Check if portrait is valid for a given date."""
        if not self._is_after_or_equal_to_start(year, month, day):
            return False
        
        if not self._is_before_or_equal_to_end(year, month, day):
            return False
        
        return True
    
    def _is_after_or_equal_to_start(
        self,
        year: int,
        month: int | None,
        day: int | None
    ) -> bool:
        """Check if date is after or equal to valid_from date."""
        if self.valid_from_year is None:
            return True
        
        if year < self.valid_from_year:
            return False
        
        if year > self.valid_from_year:
            return True
        
        if self.valid_from_month is None or month is None:
            return True
        
        if month < self.valid_from_month:
            return False
        
        if month > self.valid_from_month:
            return True
        
        if self.valid_from_day is None or day is None:
            return True
        
        return day >= self.valid_from_day
    
    def _is_before_or_equal_to_end(
        self,
        year: int,
        month: int | None,
        day: int | None
    ) -> bool:
        """Check if date is before or equal to valid_to date."""
        if self.valid_to_year is None:
            return True
        
        if year > self.valid_to_year:
            return False
        
        if year < self.valid_to_year:
            return True
        
        if self.valid_to_month is None or month is None:
            return True
        
        if month > self.valid_to_month:
            return False
        
        if month < self.valid_to_month:
            return True
        
        if self.valid_to_day is None or day is None:
            return True
        
        return day <= self.valid_to_day


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ actions\__init__.py (6 code lines)
from .file_actions import FileActions
from .edit_actions import EditActions
from .tools_actions import ToolsActions
from .help_actions import HelpActions
from .settings_actions import SettingsActions

__all__ = ['FileActions', 'EditActions', 'ToolsActions', 'HelpActions', 'SettingsActions']

>> âœ… actions\edit_actions.py (40 code lines)
"""Handles edit menu actions (Undo, Redo, Add/Remove operations)."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QDialog
from PySide6.QtGui import QAction

if TYPE_CHECKING:
    from main import MainWindow
    from models.person import Person

from dialogs.add_person_dialog import AddPersonDialog
from commands.genealogy_commands import AddPersonCommand


class EditActions:
    """Handles edit menu actions (Undo, Redo, Add/Remove operations)."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Action Text Formats
    ACTION_TEXT_UNDO_DEFAULT: str = "Undo"
    ACTION_TEXT_REDO_DEFAULT: str = "Redo"
    ACTION_TEXT_UNDO_FORMAT: str = "Undo {description}"
    ACTION_TEXT_REDO_FORMAT: str = "Redo {description}"
    
    # Dialog Results
    DIALOG_ACCEPTED: int = 1
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize edit actions handler."""
        self.parent: MainWindow = parent
        
        self.undo_action: QAction | None = None
        self.redo_action: QAction | None = None
    
    # ------------------------------------------------------------------
    # Undo/Redo Menu Updates
    # ------------------------------------------------------------------
    
    def update_undo_redo_actions(self) -> None:
        """Update Undo/Redo menu items with current action descriptions."""
        if not self._has_undo_redo_actions():
            return
        
        self._update_undo_action()
        self._update_redo_action()
    
    def _has_undo_redo_actions(self) -> bool:
        """Check if undo/redo action references are set."""
        return self.undo_action is not None and self.redo_action is not None
    
    def _update_undo_action(self) -> None:
        """Update undo action text and enabled state."""
        if self.undo_action is None:
            return
        
        undo_manager = self.parent.undo_manager
        
        if not undo_manager.can_undo():
            self.undo_action.setText(self.ACTION_TEXT_UNDO_DEFAULT)
            self.undo_action.setEnabled(False)
            return
        
        next_undo = undo_manager.peek_undo()
        if not next_undo:
            self.undo_action.setText(self.ACTION_TEXT_UNDO_DEFAULT)
            self.undo_action.setEnabled(False)
            return
        
        self.undo_action.setText(
            self.ACTION_TEXT_UNDO_FORMAT.format(description=next_undo.description())
        )
        self.undo_action.setEnabled(True)
    
    def _update_redo_action(self) -> None:
        """Update redo action text and enabled state."""
        if self.redo_action is None:
            return
        
        undo_manager = self.parent.undo_manager
        
        if not undo_manager.can_redo():
            self.redo_action.setText(self.ACTION_TEXT_REDO_DEFAULT)
            self.redo_action.setEnabled(False)
            return
        
        next_redo = undo_manager.peek_redo()
        if not next_redo:
            self.redo_action.setText(self.ACTION_TEXT_REDO_DEFAULT)
            self.redo_action.setEnabled(False)
            return
        
        self.redo_action.setText(
            self.ACTION_TEXT_REDO_FORMAT.format(description=next_redo.description())
        )
        self.redo_action.setEnabled(True)
    
    # ------------------------------------------------------------------
    # Undo/Redo Operations
    # ------------------------------------------------------------------
    
    def undo(self) -> None:
        """Undo the last action."""
        if not self.parent.undo_manager.undo():
            return
        
        self._refresh_after_undo_redo()
    
    def redo(self) -> None:
        """Redo the last undone action."""
        if not self.parent.undo_manager.redo():
            return
        
        self._refresh_after_undo_redo()
    
    def _refresh_after_undo_redo(self) -> None:
        """Refresh UI after undo or redo operation."""
        self.parent.db.mark_dirty()
        self.parent.refresh_ui()
        self.update_undo_redo_actions()
    
    # ------------------------------------------------------------------
    # Person Operations
    # ------------------------------------------------------------------
    
    def add_person(self) -> None:
        """Open dialog to add a new person to the database."""
        dialog: AddPersonDialog = AddPersonDialog(self.parent.db)
        
        if not self._dialog_accepted(dialog):
            return
        
        person: Person | None = dialog.get_person()
        if not person:
            return
        
        self._execute_add_person_command(person)
    
    def _dialog_accepted(self, dialog: QDialog) -> bool:
        """Check if dialog was accepted."""
        return dialog.exec() == self.DIALOG_ACCEPTED
    
    def _execute_add_person_command(self, person: Person) -> None:
        """Execute command to add person to database."""
        command: AddPersonCommand = AddPersonCommand(self.parent.db, person)
        self.parent.undo_manager.execute(command)
        self.parent.refresh_ui()
        self.update_undo_redo_actions()
    
    def remove_person(self) -> None:
        """Remove the selected person from the database."""
        pass
    
    # ------------------------------------------------------------------
    # Family Operations
    # ------------------------------------------------------------------
    
    def add_new_family(self) -> None:
        """Create a new family branch in the dynasty."""
        pass

>> âœ… actions\file_actions.py (100 code lines)
"""Handles file menu actions (New, Open, Save, Exit)."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QFileDialog, QMessageBox

if TYPE_CHECKING:
    from main import MainWindow


class FileActions:
    """Handles file menu actions (New, Open, Save, Exit)."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # File Filters
    FILE_FILTER_DYNASTY: str = "Dynasty Files (*.dyn)"
    
    # Dialog Titles
    DIALOG_TITLE_OPEN: str = "Open Dynasty File"
    DIALOG_TITLE_SAVE_AS: str = "Save Dynasty File As"
    
    # Message Box Titles
    MSG_TITLE_ERROR: str = "Error"
    MSG_TITLE_UNSAVED_CHANGES: str = "Unsaved Changes"
    MSG_TITLE_FILE_NOT_FOUND: str = "File Not Found"
    MSG_TITLE_ERROR_OPENING: str = "Error Opening Database"
    MSG_TITLE_ERROR_SAVING: str = "Error Saving Database"
    
    # Message Box Text
    MSG_TEXT_NO_DATABASE: str = "No database is currently open."
    MSG_TEXT_UNSAVED_NEW: str = "You have unsaved changes. Do you want to save before creating a new dynasty?"
    MSG_TEXT_UNSAVED_EXIT: str = "You have unsaved changes. Do you want to save before exiting?"
    MSG_TEXT_FILE_NOT_FOUND: str = "The file '{path}' does not exist."
    MSG_TEXT_OPEN_ERROR: str = "Failed to open dynasty file:\n{error}"
    MSG_TEXT_SAVE_ERROR: str = "Failed to save dynasty file:\n{error}"
    
    # Default Values
    DEFAULT_PATH_EMPTY: str = ""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize file actions handler."""
        self.parent: MainWindow = parent
    
    # ------------------------------------------------------------------
    # Database Validation
    # ------------------------------------------------------------------
    
    def _ensure_db(self) -> bool:
        """Check if a database is currently open."""
        if not hasattr(self.parent, 'db'):
            self._show_error(self.MSG_TITLE_ERROR, self.MSG_TEXT_NO_DATABASE)
            return False
        
        if not self.parent.db.is_open:
            self._show_error(self.MSG_TITLE_ERROR, self.MSG_TEXT_NO_DATABASE)
            return False
        
        return True
    
    # ------------------------------------------------------------------
    # File Dialog Helpers
    # ------------------------------------------------------------------
    
    def _get_save_path(self, title: str, default_name: str = "") -> str | None:
        """Show a save file dialog and return the chosen path."""
        default_path: str = self._build_save_default_path(default_name)
        
        path, _ = QFileDialog.getSaveFileName(
            self.parent,
            title,
            default_path,
            self.FILE_FILTER_DYNASTY
        )
        
        return path if path else None
    
    def _build_save_default_path(self, default_name: str) -> str:
        """Build default path for save dialog."""
        if default_name:
            return default_name
        
        if self.parent.db.database_directory:
            return self.parent.db.database_directory
        
        return self.DEFAULT_PATH_EMPTY
    
    def _get_open_path(self, title: str) -> str | None:
        """Show an open file dialog and return the chosen path."""
        default_dir: str = self._get_default_open_directory()
        
        path, _ = QFileDialog.getOpenFileName(
            self.parent,
            title,
            default_dir,
            self.FILE_FILTER_DYNASTY
        )
        
        return path if path else None
    
    def _get_default_open_directory(self) -> str:
        """Get default directory for open dialog."""
        if not self.parent.db.is_open:
            return self.DEFAULT_PATH_EMPTY
        
        if not self.parent.db.database_directory:
            return self.DEFAULT_PATH_EMPTY
        
        return self.parent.db.database_directory
    
    # ------------------------------------------------------------------
    # UI Helpers
    # ------------------------------------------------------------------
    
    def _show_error(self, title: str, message: str) -> None:
        """Display an error message dialog."""
        QMessageBox.critical(self.parent, title, message)
    
    def _refresh_all_views(self) -> None:
        """Refresh all active views with new database data."""
        if self.parent.data_table_view:
            self.parent.data_table_view.refresh_data()
    
    # ------------------------------------------------------------------
    # Unsaved Changes Handling
    # ------------------------------------------------------------------
    
    def _prompt_save_before_new(self) -> bool:
        """Prompt to save changes before creating new database."""
        if not self.parent.db.is_dirty:
            return True
        
        reply = self._show_unsaved_changes_dialog(self.MSG_TEXT_UNSAVED_NEW)
        
        if reply == QMessageBox.StandardButton.Cancel:
            return False
        
        if reply == QMessageBox.StandardButton.Save:
            return self.save()
        
        return True
    
    def _show_unsaved_changes_dialog(self, message: str) -> QMessageBox.StandardButton:
        """Show dialog for unsaved changes with Save/Discard/Cancel options."""
        reply = QMessageBox.question(
            self.parent,
            self.MSG_TITLE_UNSAVED_CHANGES,
            message,
            QMessageBox.StandardButton.Save |
            QMessageBox.StandardButton.Discard |
            QMessageBox.StandardButton.Cancel
        )
        return reply
    
    # ------------------------------------------------------------------
    # Recent Files Management
    # ------------------------------------------------------------------
    
    def _add_to_recent_files(self, path: str | None) -> None:
        """Add file path to recent files list."""
        if not path:
            return
        
        self.parent.settings_manager.add_recent_file(path)
        self.parent._update_recent_files_menu()
    
    # ------------------------------------------------------------------
    # File Operations
    # ------------------------------------------------------------------
    
    def new_dynasty(self) -> None:
        """Create a new untitled dynasty database."""
        if not self._prompt_save_before_new():
            return
        
        self.parent.db.close()
        self.parent._create_untitled_database()
        self.parent.refresh_ui()
        self._refresh_all_views()
        self.parent._show_family_trees()
    
    def open_dynasty(self) -> None:
        """Prompt user to open an existing dynasty database file."""
        path: str | None = self._get_open_path(self.DIALOG_TITLE_OPEN)
        
        if not path:
            return
        
        self._attempt_open_database(path)
    
    def _attempt_open_database(self, path: str) -> None:
        """Attempt to open database file and handle errors."""
        try:
            self._open_database_success(path)
        except FileNotFoundError:
            self._show_file_not_found_error(path)
        except Exception as e:
            self._show_open_error(e)
    
    def _open_database_success(self, path: str) -> None:
        """Handle successful database open."""
        self.parent.db.open_database(path)
        self.parent.refresh_ui()
        self._refresh_all_views()
        self._add_to_recent_files(path)
    
    def _show_file_not_found_error(self, path: str) -> None:
        """Show error when file is not found."""
        self._show_error(
            self.MSG_TITLE_FILE_NOT_FOUND,
            self.MSG_TEXT_FILE_NOT_FOUND.format(path=path)
        )
    
    def _show_open_error(self, error: Exception) -> None:
        """Show error when opening database fails."""
        self._show_error(
            self.MSG_TITLE_ERROR_OPENING,
            self.MSG_TEXT_OPEN_ERROR.format(error=str(error))
        )
    
    def save(self) -> bool:
        """Save current database, falling back to save_as if no path set."""
        if not self._ensure_db():
            return False
        
        if not self.parent.db.has_file_path:
            return self.save_as()
        
        return self._attempt_save_database()
    
    def _attempt_save_database(self, path: str | None = None) -> bool:
        """Attempt to save database and handle errors."""
        try:
            return self._save_database_success(path)
        except Exception as e:
            self._show_save_error(e)
            return False
    
    def _save_database_success(self, path: str | None = None) -> bool:
        """Handle successful database save."""
        result: bool = self.parent.db.save_database(path) 
        
        if not result:
            return False
        
        self.parent.refresh_ui()
        self._add_to_recent_files(self.parent.db.file_path)
        
        return True
    
    def _show_save_error(self, error: Exception) -> None:
        """Show error when saving database fails."""
        self._show_error(
            self.MSG_TITLE_ERROR_SAVING,
            self.MSG_TEXT_SAVE_ERROR.format(error=str(error))
        )
    
    def save_as(self) -> bool:
        """Prompt user to save database to a new file."""
        if not self._ensure_db():
            return False
        
        default_name: str = self.parent.db.database_name or self.DEFAULT_PATH_EMPTY
        path: str | None = self._get_save_path(self.DIALOG_TITLE_SAVE_AS, default_name)
        
        if not path:
            return False
        
        return self._attempt_save_database(path)
    
    def exit_app(self) -> None:
        """Prompt to save unsaved changes before closing application."""
        if not self._check_exit_conditions():
            return
        
        self.parent.close()
    
    def _check_exit_conditions(self) -> bool:
        """Check if application can exit, prompting for save if needed."""
        if not self._has_unsaved_changes():
            return True
        
        return self._prompt_save_before_exit()
    
    def _has_unsaved_changes(self) -> bool:
        """Check if there are unsaved changes."""
        db = self.parent.db
        return db.is_open and db.is_dirty
    
    def _prompt_save_before_exit(self) -> bool:
        """Prompt to save changes before exiting."""
        choice = self._show_unsaved_changes_dialog(self.MSG_TEXT_UNSAVED_EXIT)
        
        if choice == QMessageBox.StandardButton.Cancel:
            return False
        
        if choice == QMessageBox.StandardButton.Save:
            return self.save()
        
        return True

>> ðŸ“‹ actions\help_actions.py (14 code lines)
"""Handles help menu actions for application information."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QMessageBox

if TYPE_CHECKING:
    from main import MainWindow


class HelpActions:
    """Handles help menu actions for application information."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Dialog Titles
    DIALOG_TITLE_ABOUT: str = "About Dynasty Visualizer"
    
    # Dialog Text
    DIALOG_TEXT_ABOUT: str = (
        "<h2>Dynasty Visualizer</h2>"
        "<p>Version 0.2.0</p>"
        "<p>A genealogy tracking application for Ostriv settlements.</p>"
        "<p>Created by Alex</p>"
        "<p>Â© 2025</p>"
    )
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize help actions handler."""
        self.parent: MainWindow = parent
    
    # ------------------------------------------------------------------
    # Help Actions
    # ------------------------------------------------------------------
    
    def about(self) -> None:
        """Display the about dialog with application information."""
        QMessageBox.about(
            self.parent,
            self.DIALOG_TITLE_ABOUT,
            self.DIALOG_TEXT_ABOUT
        )

>> ðŸ“‹ actions\settings_actions.py (19 code lines)
"""Handles settings menu actions for various configuration options."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QMessageBox

if TYPE_CHECKING:
    from main import MainWindow


class SettingsActions:
    """Handles settings menu actions for various configuration options."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Message Box Titles
    MSG_TITLE_NOT_IMPLEMENTED: str = "Not Yet Implemented"
    
    # Message Box Text
    MSG_TEXT_SETTINGS: str = "Settings dialog coming soon!"
    MSG_TEXT_GENERAL: str = "General settings coming soon!"
    MSG_TEXT_SHORTCUTS: str = "Shortcuts configuration coming soon!"
    MSG_TEXT_DISPLAY: str = "Display settings coming soon!"
    MSG_TEXT_APPEARANCE: str = "Appearance settings coming soon!"
    MSG_TEXT_FORMATS: str = "Format settings coming soon!"
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize settings actions handler."""
        self.parent: MainWindow = parent
    
    # ------------------------------------------------------------------
    # Settings Actions
    # ------------------------------------------------------------------
    
    def settings(self) -> None:
        """Open settings dialog to modify application settings."""
        self._show_not_implemented(self.MSG_TEXT_SETTINGS)
    
    def general(self) -> None:
        """Open general settings tab."""
        self._show_not_implemented(self.MSG_TEXT_GENERAL)
    
    def shortcuts(self) -> None:
        """Open shortcuts settings tab."""
        self._show_not_implemented(self.MSG_TEXT_SHORTCUTS)
    
    def display(self) -> None:
        """Open display settings tab."""
        self._show_not_implemented(self.MSG_TEXT_DISPLAY)
    
    def appearance(self) -> None:
        """Open appearance settings tab."""
        self._show_not_implemented(self.MSG_TEXT_APPEARANCE)
    
    def formats(self) -> None:
        """Open formats settings tab."""
        self._show_not_implemented(self.MSG_TEXT_FORMATS)
    
    # ------------------------------------------------------------------
    # UI Helpers
    # ------------------------------------------------------------------
    
    def _show_not_implemented(self, message: str) -> None:
        """Show a 'not yet implemented' message dialog."""
        QMessageBox.information(
            self.parent,
            self.MSG_TITLE_NOT_IMPLEMENTED,
            message
        )

>> ðŸ“‹ actions\tools_actions.py (16 code lines)
"""Handles tools menu actions for validation and scene utilities."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QMessageBox

if TYPE_CHECKING:
    from main import MainWindow


class ToolsActions:
    """Handles tools menu actions for validation and scene utilities."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Message Box Titles
    MSG_TITLE_NOT_IMPLEMENTED: str = "Not Yet Implemented"
    MSG_TITLE_VALIDATION_COMPLETE: str = "Validation Complete"
    
    # Message Box Text
    MSG_TEXT_REBUILD_SCENE: str = "Rebuild scene functionality coming soon!"
    MSG_TEXT_RECOMPUTE_GENERATIONS: str = "Generation computation coming soon!"
    MSG_TEXT_VALIDATE_MARRIAGES: str = "Marriage validation coming soon!"
    MSG_TEXT_VALIDATE_PARENTAGE: str = "Parentage validation coming soon!"
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize tools actions handler."""
        self.parent: MainWindow = parent
    
    # ------------------------------------------------------------------
    # Scene Actions
    # ------------------------------------------------------------------
    
    def rebuild_scene(self) -> None:
        """Rebuild the current visualization scene from scratch."""
        self._show_not_implemented(self.MSG_TEXT_REBUILD_SCENE)
    
    def recompute_generations(self) -> None:
        """Recalculate generation levels for all persons."""
        self._show_not_implemented(self.MSG_TEXT_RECOMPUTE_GENERATIONS)
    
    # ------------------------------------------------------------------
    # Validation Actions
    # ------------------------------------------------------------------
    
    def validate_marriages(self) -> None:
        """Check for inconsistencies in marriage records."""
        self._show_not_implemented(self.MSG_TEXT_VALIDATE_MARRIAGES)
    
    def validate_parentage(self) -> None:
        """Check for inconsistencies in parent-child relationships."""
        self._show_not_implemented(self.MSG_TEXT_VALIDATE_PARENTAGE)
    
    # ------------------------------------------------------------------
    # UI Helpers
    # ------------------------------------------------------------------
    
    def _show_not_implemented(self, message: str) -> None:
        """Show a 'not yet implemented' message dialog."""
        QMessageBox.information(
            self.parent,
            self.MSG_TITLE_NOT_IMPLEMENTED,
            message
        )


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\base_command.py (11 code lines)
"""Base class for all undoable commands."""

from __future__ import annotations

import re


class BaseCommand:
    """Base class for all undoable commands."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    COMMAND_SUFFIX: str = "Command"
    REGEX_CAMEL_TO_SPACED: str = r'([a-z])([A-Z])'
    REGEX_REPLACEMENT: str = r'\1 \2'
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self) -> None:
        """Initialize base command."""
        self._executed: bool = False
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description for UI display."""
        class_name: str = self._get_class_name_without_suffix()
        spaced: str = self._convert_camel_case_to_spaced(class_name)
        return spaced
    
    def _get_class_name_without_suffix(self) -> str:
        """Get class name with 'Command' suffix removed."""
        class_name: str = self.__class__.__name__
        
        if class_name.endswith(self.COMMAND_SUFFIX):
            return class_name[:-len(self.COMMAND_SUFFIX)]
        
        return class_name
    
    def _convert_camel_case_to_spaced(self, text: str) -> str:
        """Convert CamelCase to spaced text."""
        return re.sub(self.REGEX_CAMEL_TO_SPACED, self.REGEX_REPLACEMENT, text)
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Execute the command."""
        raise NotImplementedError("Subclasses must implement run()")
    
    def undo(self) -> None:
        """Reverse the command's effects."""
        raise NotImplementedError("Subclasses must implement undo()")

>> âœ… commands\genealogy_commands\__init__.py (26 code lines)
from .add_event import AddEventCommand
from .add_marriage import AddMarriageCommand
from .add_person import AddPersonCommand
from .assign_parent import AssignParentCommand
from .create_child import CreateChildCommand
from .delete_event import DeleteEventCommand
from .edit_event import EditEventCommand
from .edit_marriage import EditMarriageCommand
from .edit_person import EditPersonCommand
from .end_marriage import EndMarriageCommand
from .delete_person import DeletePersonCommand
from .unassign_parent import UnassignParentCommand

__all__ = [
    "AddEventCommand",
    "AddMarriageCommand",
    "AddPersonCommand",
    "AssignParentCommand",
    "CreateChildCommand",
    "DeleteEventCommand",
    "EditEventCommand",
    "EditMarriageCommand",
    "EditPersonCommand",
    "EndMarriageCommand",
    "DeletePersonCommand",
    "UnassignParentCommand"
]

>> ðŸ“‹ commands\genealogy_commands\add_event.py (4 code lines)
"""Command for adding an event to a person."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.event import Event

from commands.base_command import BaseCommand
from database.event_repository import EventRepository


class AddEventCommand(BaseCommand):
    """Add a life event to a person."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, event: Event) -> None:
        """Initialize the add event command."""
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.event: Event = event
        self.event_id: int | None = None
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Insert the event into the database."""
        event_repo: EventRepository = EventRepository(self.db_manager)
        self.event_id = event_repo.insert(self.event)
    
    def undo(self) -> None:
        """Remove the event from the database."""
        if self.event_id is None:
            return
        
        event_repo: EventRepository = EventRepository(self.db_manager)
        event_repo.delete(self.event_id)

>> ðŸ“‹ commands\genealogy_commands\add_marriage.py (4 code lines)
"""Command for creating a marriage between two people."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.marriage import Marriage

from commands.base_command import BaseCommand
from database.marriage_repository import MarriageRepository


class AddMarriageCommand(BaseCommand):
    """Create a marriage relationship between two people."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, marriage: Marriage) -> None:
        """Initialize the create marriage command."""
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.marriage: Marriage = marriage
        self.marriage_id: int | None = None
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Insert the marriage into the database."""
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        self.marriage_id = marriage_repo.insert(self.marriage)
    
    def undo(self) -> None:
        """Remove the marriage from the database."""
        if self.marriage_id is None:
            return
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.delete(self.marriage_id)

>> ðŸ“‹ commands\genealogy_commands\add_person.py (10 code lines)
"""Command for adding a new person to the database."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository


class AddPersonCommand(BaseCommand):
    """Add a new person to the dynasty database with undo support."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, person: Person) -> None:
        """Initialize the add person command."""
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.person_id: int | None = None
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Insert the person into the database and store the assigned ID."""
        repo: PersonRepository = PersonRepository(self.db_manager)
        
        if self.person_id is None:
            self._insert_new_person(repo)
        else:
            self._reinsert_person_with_id(repo)
    
    def _insert_new_person(self, repo: PersonRepository) -> None:
        """Insert person as new record and store generated ID."""
        self.person_id = repo.insert(self.person)
        self.person.id = self.person_id
    
    def _reinsert_person_with_id(self, repo: PersonRepository) -> None:
        """Reinsert person with previously assigned ID (for redo)."""
        self.person.id = self.person_id
        repo.insert_with_id(self.person)
    
    def undo(self) -> None:
        """Remove the person from the database."""
        if self.person_id is None:
            return
        
        repo: PersonRepository = PersonRepository(self.db_manager)
        repo.delete(self.person_id)

>> âœ… commands\genealogy_commands\assign_parent.py (25 code lines)
"""Command for assigning a parent to a person."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository


class AssignParentCommand(BaseCommand):
    """Set or change a person's father or mother."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    PARENT_TYPE_FATHER: str = "father"
    PARENT_TYPE_MOTHER: str = "mother"
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent_id: int,
        parent_type: str
    ) -> None:
        """
        Initialize assign parent command.
        
        Args:
            db_manager: Database manager instance
            person: Person to assign parent to
            parent_id: ID of parent to assign
            parent_type: "father" or "mother"
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.parent_id: int = parent_id
        self.parent_type: str = parent_type
        self.old_parent_id: int | None = self._get_current_parent_id()
    
    def _get_current_parent_id(self) -> int | None:
        """Get current parent ID before assignment."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            return self.person.father_id
        return self.person.mother_id
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Assign the parent relationship in database."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            self.person.father_id = self.parent_id
        else:
            self.person.mother_id = self.parent_id
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.update(self.person)
    
    def undo(self) -> None:
        """Restore original parent relationship."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            self.person.father_id = self.old_parent_id
        else:
            self.person.mother_id = self.old_parent_id
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.update(self.person)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        parent_label: str = "Father" if self.parent_type == self.PARENT_TYPE_FATHER else "Mother"
        return f"Assign {parent_label}"

>> ðŸ“‹ commands\genealogy_commands\create_child.py (11 code lines)
"""Command for creating a child with automatic parent assignment."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository


class CreateChildCommand(BaseCommand):
    """Create a new person as child of specified parents."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, child: Person) -> None:
        """
        Initialize create child command.
        
        Args:
            db_manager: Database manager instance
            child: Child person object with parent relationships
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.child: Person = child
        self.created_person_id: int | None = None
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Create new person with parent relationships in database."""
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        
        if self.created_person_id is None:
            self.created_person_id = person_repo.insert(self.child)
            self.child.id = self.created_person_id
        else:
            self.child.id = self.created_person_id
            person_repo.insert_with_id(self.child)
    
    def undo(self) -> None:
        """Delete the created child."""
        if self.created_person_id is None:
            return
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.delete(self.created_person_id)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return f"Create Child: {self.child.first_name} {self.child.last_name}"

>> ðŸ“‹ commands\genealogy_commands\delete_event.py (12 code lines)
"""Command for deleting an event from the database."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.event import Event

from commands.base_command import BaseCommand
from database.event_repository import EventRepository


class DeleteEventCommand(BaseCommand):
    """Remove an event from the database."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, event: Event) -> None:
        """
        Initialize delete event command.
        
        Args:
            db_manager: Database manager instance
            event: Event to delete
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.event: Event = event
        self.deleted_event_data: dict = self._capture_event_data()
    
    def _capture_event_data(self) -> dict:
        """Capture complete event data for undo."""
        return {
            'id': self.event.id,
            'person_id': self.event.person_id,
            'event_type': self.event.event_type,
            'event_title': self.event.event_title,
            'start_year': self.event.start_year,
            'start_month': self.event.start_month,
            'end_year': self.event.end_year,
            'end_month': self.event.end_month,
            'notes': self.event.notes
        }
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Delete the event from database."""
        if self.event.id is None:
            return
        
        event_repo: EventRepository = EventRepository(self.db_manager)
        event_repo.delete(self.event.id)
    
    def undo(self) -> None:
        """Restore the deleted event."""
        from models.event import Event
        
        restored_event: Event = Event(**self.deleted_event_data)
        event_repo: EventRepository = EventRepository(self.db_manager)
        event_repo.insert_with_id(restored_event)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return f"Delete Event: {self.event.event_title}"

>> ðŸ“‹ commands\genealogy_commands\delete_marriage.py (12 code lines)
"""Command for deleting a marriage from the database."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.marriage import Marriage

from commands.base_command import BaseCommand
from database.marriage_repository import MarriageRepository


class DeleteMarriageCommand(BaseCommand):
    """Remove a marriage relationship from the database."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, marriage: Marriage) -> None:
        """
        Initialize delete marriage command.
        
        Args:
            db_manager: Database manager instance
            marriage: Marriage to delete
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.marriage: Marriage = marriage
        self.deleted_marriage_data: dict = self._capture_marriage_data()
    
    def _capture_marriage_data(self) -> dict:
        """Capture complete marriage data for undo."""
        return {
            'id': self.marriage.id,
            'spouse1_id': self.marriage.spouse1_id,
            'spouse2_id': self.marriage.spouse2_id,
            'marriage_year': self.marriage.marriage_year,
            'marriage_month': self.marriage.marriage_month,
            'dissolution_year': self.marriage.dissolution_year,
            'dissolution_month': self.marriage.dissolution_month,
            'dissolution_day': self.marriage.dissolution_day,
            'dissolution_reason': self.marriage.dissolution_reason
        }
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Delete the marriage from database."""
        if self.marriage.id is None:
            return
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.delete(self.marriage.id)
    
    def undo(self) -> None:
        """Restore the deleted marriage."""
        from models.marriage import Marriage
        
        restored_marriage: Marriage = Marriage(**self.deleted_marriage_data)
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.insert_with_id(restored_marriage)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return "Delete Marriage"

>> ðŸ“‹ commands\genealogy_commands\delete_person.py (12 code lines)
"""Command for removing a person from the database."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository


class DeletePersonCommand(BaseCommand):
    """Delete a person from the dynasty database."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, person: Person) -> None:
        """
        Initialize delete person command.
        
        Args:
            db_manager: Database manager instance
            person: Person to delete
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.deleted_person_data: dict = self._capture_person_data()
    
    def _capture_person_data(self) -> dict:
        """Capture complete person data for undo."""
        return {
            'id': self.person.id,
            'first_name': self.person.first_name,
            'middle_name': self.person.middle_name,
            'last_name': self.person.last_name,
            'maiden_name': self.person.maiden_name,
            'nickname': self.person.nickname,
            'gender': self.person.gender,
            'birth_year': self.person.birth_year,
            'birth_month': self.person.birth_month,
            'birth_day': self.person.birth_day,
            'death_year': self.person.death_year,
            'death_month': self.person.death_month,
            'death_day': self.person.death_day,
            'arrival_year': self.person.arrival_year,
            'arrival_month': self.person.arrival_month,
            'arrival_day': self.person.arrival_day,
            'moved_out_year': self.person.moved_out_year,
            'moved_out_month': self.person.moved_out_month,
            'moved_out_day': self.person.moved_out_day,
            'father_id': self.person.father_id,
            'mother_id': self.person.mother_id,
            'family_id': self.person.family_id,
            'dynasty_id': self.person.dynasty_id,
            'is_founder': self.person.is_founder,
            'education': self.person.education,
            'notes': self.person.notes
        }
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Remove the person from the database."""
        if self.person.id is None:
            return
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.delete(self.person.id)
    
    def undo(self) -> None:
        """Restore the deleted person."""
        from models.person import Person
        
        restored_person: Person = Person(**self.deleted_person_data)
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.insert_with_id(restored_person)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return f"Delete Person: {self.person.first_name} {self.person.last_name}"

>> ðŸ“‹ commands\genealogy_commands\edit_event.py (16 code lines)
"""Command for editing an existing event."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.event import Event

from commands.base_command import BaseCommand
from database.event_repository import EventRepository


class EditEventCommand(BaseCommand):
    """Edit details of an existing event with undo support."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        event: Event,
        original_event_data: dict
    ) -> None:
        """
        Initialize edit event command.
        
        Args:
            db_manager: Database manager instance
            event: Modified event object
            original_event_data: Original event data for undo
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.event: Event = event
        self.original_event_data: dict = original_event_data
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Update event in database."""
        event_repo: EventRepository = EventRepository(self.db_manager)
        event_repo.update(self.event)
    
    def undo(self) -> None:
        """Restore original event data."""
        from models.event import Event
        
        original_event: Event = Event(**self.original_event_data)
        event_repo: EventRepository = EventRepository(self.db_manager)
        event_repo.update(original_event)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return f"Edit Event: {self.event.event_title}"

>> ðŸ“‹ commands\genealogy_commands\edit_marriage.py (16 code lines)
"""Command for editing an existing marriage."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.marriage import Marriage

from commands.base_command import BaseCommand
from database.marriage_repository import MarriageRepository


class EditMarriageCommand(BaseCommand):
    """Edit details of an existing marriage relationship."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        marriage: Marriage,
        original_marriage_data: dict
    ) -> None:
        """
        Initialize edit marriage command.
        
        Args:
            db_manager: Database manager instance
            marriage: Modified marriage object
            original_marriage_data: Original marriage data for undo
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.marriage: Marriage = marriage
        self.original_marriage_data: dict = original_marriage_data
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Update marriage details in database."""
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.update(self.marriage)
    
    def undo(self) -> None:
        """Restore original marriage details."""
        from models.marriage import Marriage
        
        original_marriage: Marriage = Marriage(**self.original_marriage_data)
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.update(original_marriage)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return "Edit Marriage"

>> âœ… commands\genealogy_commands\edit_person.py (46 code lines)
"""Command for editing an existing person and related data."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person
    from models.marriage import Marriage
    from models.event import Event

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository
from database.marriage_repository import MarriageRepository
from database.event_repository import EventRepository


class EditPersonCommand(BaseCommand):
    """
    Composite command for editing person and all related changes.
    
    Bundles:
    - Person data changes (name, dates, etc.)
    - Marriage changes (new, modified, deleted)
    - Event changes (new, modified, deleted)
    - Parent relationship changes
    """
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        original_person_data: dict,
        new_marriages: list[Marriage],
        modified_marriages: dict[int, Marriage],
        deleted_marriage_ids: list[int],
        new_events: list[Event],
        modified_events: dict[int, Event],
        deleted_event_ids: list[int],
        original_marriages: list[Marriage],
        original_events: list[Event]
    ) -> None:
        """
        Initialize edit person command with all changes.
        
        Args:
            db_manager: Database manager instance
            person: Modified person object
            original_person_data: Original person data for undo
            new_marriages: New marriages to insert
            modified_marriages: Existing marriages that were modified
            deleted_marriage_ids: Marriage IDs to delete
            new_events: New events to insert
            modified_events: Existing events that were modified
            deleted_event_ids: Event IDs to delete
            original_marriages: Original marriage data for undo
            original_events: Original event data for undo
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.original_person_data: dict = original_person_data
        
        self.new_marriages: list[Marriage] = new_marriages
        self.modified_marriages: dict[int, Marriage] = modified_marriages
        self.deleted_marriage_ids: list[int] = deleted_marriage_ids
        
        self.new_events: list[Event] = new_events
        self.modified_events: dict[int, Event] = modified_events
        self.deleted_event_ids: list[int] = deleted_event_ids
        
        self.original_marriages: list[Marriage] = original_marriages
        self.original_events: list[Event] = original_events
        
        self.inserted_marriage_ids: list[int] = []
        self.inserted_event_ids: list[int] = []
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Execute all changes to person and related data."""
        self._update_person()
        self._apply_marriage_changes()
        self._apply_event_changes()
    
    def _update_person(self) -> None:
        """Update person data in database."""
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.update(self.person)
    
    def _apply_marriage_changes(self) -> None:
        """Apply all marriage changes."""
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        
        for marriage_id in self.deleted_marriage_ids:
            marriage_repo.delete(marriage_id)
        
        for marriage in self.new_marriages:
            marriage_id: int = marriage_repo.insert(marriage)
            self.inserted_marriage_ids.append(marriage_id)
        
        for marriage_id, marriage in self.modified_marriages.items():
            marriage_repo.update(marriage)
    
    def _apply_event_changes(self) -> None:
        """Apply all event changes."""
        event_repo: EventRepository = EventRepository(self.db_manager)
        
        for event_id in self.deleted_event_ids:
            event_repo.delete(event_id)
        
        for event in self.new_events:
            event_id: int = event_repo.insert(event)
            self.inserted_event_ids.append(event_id)
        
        for event_id, event in self.modified_events.items():
            event_repo.update(event)
    
    # ------------------------------------------------------------------
    # Command Undo
    # ------------------------------------------------------------------
    
    def undo(self) -> None:
        """Undo all changes and restore original state."""
        self._restore_person()
        self._restore_marriages()
        self._restore_events()
    
    def _restore_person(self) -> None:
        """Restore original person data."""
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        
        from models.person import Person
        original_person: Person = Person(**self.original_person_data)
        person_repo.update(original_person)
    
    def _restore_marriages(self) -> None:
        """Restore original marriages."""
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        
        for marriage_id in self.inserted_marriage_ids:
            marriage_repo.delete(marriage_id)
        
        for marriage in self.original_marriages:
            if marriage.id in self.deleted_marriage_ids:
                marriage_repo.insert_with_id(marriage)
            elif marriage.id in self.modified_marriages:
                marriage_repo.update(marriage)
    
    def _restore_events(self) -> None:
        """Restore original events."""
        event_repo: EventRepository = EventRepository(self.db_manager)
        
        for event_id in self.inserted_event_ids:
            event_repo.delete(event_id)
        
        for event in self.original_events:
            if event.id in self.deleted_event_ids:
                event_repo.insert_with_id(event)
            elif event.id in self.modified_events:
                event_repo.update(event)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return f"Edit {self.person.first_name} {self.person.last_name}"

>> âœ… commands\genealogy_commands\end_marriage.py (24 code lines)
"""Command for ending a marriage with divorce or death."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.marriage import Marriage

from commands.base_command import BaseCommand
from database.marriage_repository import MarriageRepository


class EndMarriageCommand(BaseCommand):
    """Mark a marriage as ended with a specific date."""
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        marriage: Marriage,
        end_year: int | None,
        end_month: int | None,
        end_reason: str
    ) -> None:
        """
        Initialize end marriage command.
        
        Args:
            db_manager: Database manager instance
            marriage: Marriage to end
            end_year: Dissolution year
            end_month: Dissolution month
            end_reason: Reason for dissolution
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.marriage: Marriage = marriage
        self.end_year: int | None = end_year
        self.end_month: int | None = end_month
        self.end_reason: str = end_reason
        
        self.old_end_year: int | None = marriage.dissolution_year
        self.old_end_month: int | None = marriage.dissolution_month
        self.old_end_reason: str = marriage.dissolution_reason or ""
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Set the marriage end date in database."""
        self.marriage.dissolution_year = self.end_year
        self.marriage.dissolution_month = self.end_month
        self.marriage.dissolution_reason = self.end_reason
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.update(self.marriage)
    
    def undo(self) -> None:
        """Restore original marriage end date."""
        self.marriage.dissolution_year = self.old_end_year
        self.marriage.dissolution_month = self.old_end_month
        self.marriage.dissolution_reason = self.old_end_reason
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriage_repo.update(self.marriage)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        return "End Marriage"

>> âœ… commands\genealogy_commands\unassign_parent.py (23 code lines)
"""Command for removing a parent assignment from a person."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from commands.base_command import BaseCommand
from database.person_repository import PersonRepository


class UnassignParentCommand(BaseCommand):
    """Remove a person's father or mother relationship."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    PARENT_TYPE_FATHER: str = "father"
    PARENT_TYPE_MOTHER: str = "mother"
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent_type: str
    ) -> None:
        """
        Initialize unassign parent command.
        
        Args:
            db_manager: Database manager instance
            person: Person to remove parent from
            parent_type: "father" or "mother"
        """
        super().__init__()
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.parent_type: str = parent_type
        self.old_parent_id: int | None = self._get_current_parent_id()
    
    def _get_current_parent_id(self) -> int | None:
        """Get current parent ID before unassignment."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            return self.person.father_id
        return self.person.mother_id
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def run(self) -> None:
        """Remove the parent relationship from database."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            self.person.father_id = None
        else:
            self.person.mother_id = None
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.update(self.person)
    
    def undo(self) -> None:
        """Restore the parent relationship."""
        if self.parent_type == self.PARENT_TYPE_FATHER:
            self.person.father_id = self.old_parent_id
        else:
            self.person.mother_id = self.old_parent_id
        
        person_repo: PersonRepository = PersonRepository(self.db_manager)
        person_repo.update(self.person)
    
    # ------------------------------------------------------------------
    # Description
    # ------------------------------------------------------------------
    
    def description(self) -> str:
        """Return human-readable description."""
        parent_label: str = "Father" if self.parent_type == self.PARENT_TYPE_FATHER else "Mother"
        return f"Remove {parent_label}"

>> ðŸ“‹ commands\GUI_commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\change_skin.py (3 code lines)
"""Command for changing the application color scheme."""

from commands.base_command import BaseCommand


class ChangeSkinCommand(BaseCommand):
    """Switch between different UI color schemes."""

    def __init__(self, new_skin: str, old_skin: str) -> None:
        """Initialize the change skin command."""
        self.new_skin = new_skin
        self.old_skin = old_skin
        # TODO: Add reference to skin manager

    def run(self) -> None:
        """Apply the new color scheme."""
        # TODO: Load new skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass

    def undo(self) -> None:
        """Restore previous color scheme."""
        # TODO: Load old skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass


>> ðŸ“‹ commands\GUI_commands\change_view.py (3 code lines)
"""Command for switching between different visualization views."""

from commands.base_command import BaseCommand


class ChangeViewCommand(BaseCommand):
    """Switch between tree, timeline, table, and stats views."""

    def __init__(self, new_view: str, old_view: str) -> None:
        """Initialize the change view command."""
        self.new_view = new_view  # "tree", "timeline", "table", "stats"
        self.old_view = old_view
        # TODO: Add reference to main window

    def run(self) -> None:
        """Switch to the new visualization view."""
        # TODO: Hide current view widget
        # TODO: Show new view widget
        # TODO: Update menu checkmarks
        pass

    def undo(self) -> None:
        """Switch back to the previous view."""
        # TODO: Hide current view widget
        # TODO: Show old view widget
        # TODO: Update menu checkmarks
        pass


>> ðŸ“‹ commands\GUI_commands\move_node.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\move_person.py (10 code lines)
"""Command for moving a person box in the tree view."""

from commands.base_command import BaseCommand


class MovePersonCommand(BaseCommand):
    """Move a person's visual position in the tree canvas."""

    def __init__(
        self,
        person_id: int,
        new_x: float,
        new_y: float,
        old_x: float,
        old_y: float,
    ) -> None:
        """Initialize the move person command."""
        self.person_id = person_id
        self.new_x = new_x
        self.new_y = new_y
        self.old_x = old_x
        self.old_y = old_y
        # TODO: Add reference to canvas/scene for visual updates

    def run(self) -> None:
        """Move person box to new position."""
        # TODO: Update PersonPosition table in database
        # TODO: Update visual position on canvas
        pass

    def undo(self) -> None:
        """Restore person box to original position."""
        # TODO: Update PersonPosition table with old coordinates
        # TODO: Update visual position on canvas
        pass


>> ðŸ“‹ commands\GUI_commands\preference_changes.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\rebuild_scene.py (3 code lines)
"""Command for rebuilding the entire visualization scene."""

from commands.base_command import BaseCommand


class RebuildSceneCommand(BaseCommand):
    """Rebuild the current view from database state."""

    def __init__(self, database_connection, view_type: str) -> None:
        """Initialize the rebuild scene command."""
        self.db = database_connection
        self.view_type = view_type  # "tree", "timeline", "table", "stats"
        # TODO: Store current scene state for undo

    def run(self) -> None:
        """Clear and rebuild the visualization scene."""
        # TODO: Clear current scene/view
        # TODO: Reload all data from database
        # TODO: Recreate all visual elements
        pass

    def undo(self) -> None:
        """Restore previous scene state."""
        # TODO: Restore from saved scene state
        pass


>> ðŸ“‹ commands\GUI_commands\recompute_generation.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\recompute_generations.py (3 code lines)
"""Command for recalculating generation levels for all people."""

from commands.base_command import BaseCommand


class RecomputeGenerationsCommand(BaseCommand):
    """Recalculate generation numbers for entire family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the recompute generations command."""
        self.db = database_connection
        self.old_generations: dict[int, int] = {}
        # TODO: Store original generation assignments for undo

    def run(self) -> None:
        """Calculate and update generation levels."""
        # TODO: Use GenerationCalculator to compute levels
        # TODO: Update Person table with new generation values
        # TODO: Update tree view layout
        pass

    def undo(self) -> None:
        """Restore original generation assignments."""
        # TODO: Restore generation values from old_generations
        # TODO: Update tree view layout
        pass


>> ðŸ“‹ commands\GUI_commands\timeline_scroll.py (0 code lines)


>> âœ… commands\undo_redo_manager.py (22 code lines)
"""Manages undo and redo stacks for command pattern operations."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from commands.base_command import BaseCommand


class UndoRedoManager:
    """Manages undo and redo stacks for command pattern operations."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    STACK_EMPTY_INDEX: int = 0
    STACK_LAST_INDEX: int = -1
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self) -> None:
        """Initialize the undo/redo manager with empty stacks."""
        self.undo_stack: list[BaseCommand] = []
        self.redo_stack: list[BaseCommand] = []
    
    # ------------------------------------------------------------------
    # Command Execution
    # ------------------------------------------------------------------
    
    def execute(self, command: BaseCommand) -> None:
        """Execute a command and add it to the undo stack."""
        command.run()
        self.undo_stack.append(command)
        self.redo_stack.clear()
    
    # ------------------------------------------------------------------
    # Undo/Redo Operations
    # ------------------------------------------------------------------
    
    def undo(self) -> bool:
        """Undo the last executed command."""
        if not self.can_undo():
            return False
        
        cmd: BaseCommand = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
        
        return True
    
    def redo(self) -> bool:
        """Redo the last undone command."""
        if not self.can_redo():
            return False
        
        cmd: BaseCommand = self.redo_stack.pop()
        cmd.run()
        self.undo_stack.append(cmd)
        
        return True
    
    # ------------------------------------------------------------------
    # Stack State Queries
    # ------------------------------------------------------------------
    
    def can_undo(self) -> bool:
        """Check if there are commands available to undo."""
        return len(self.undo_stack) > self.STACK_EMPTY_INDEX
    
    def can_redo(self) -> bool:
        """Check if there are commands available to redo."""
        return len(self.redo_stack) > self.STACK_EMPTY_INDEX
    
    def peek_undo(self) -> BaseCommand | None:
        """Get the next command that would be undone without executing it."""
        if not self.can_undo():
            return None
        
        return self.undo_stack[self.STACK_LAST_INDEX]
    
    def peek_redo(self) -> BaseCommand | None:
        """Get the next command that would be redone without executing it."""
        if not self.can_redo():
            return None
        
        return self.redo_stack[self.STACK_LAST_INDEX]
    
    # ------------------------------------------------------------------
    # Stack Management
    # ------------------------------------------------------------------
    
    def clear(self) -> None:
        """Clear both undo and redo stacks."""
        self.undo_stack.clear()
        self.redo_stack.clear()
    
    def clear_undo_stack(self) -> None:
        """Clear only the undo stack."""
        self.undo_stack.clear()
    
    def clear_redo_stack(self) -> None:
        """Clear only the redo stack."""
        self.redo_stack.clear()


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIALOGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ dialogs\__init__.py (0 code lines)
"""Dialog implementations for user interactions."""

from .add_person_dialog import AddPersonDialog
from .end_marriage_dialog import EndMarriageDialog
from .create_marriage_dialog import CreateMarriageDialog
from .create_child_dialog import CreateChildDialog
from .create_event_dialog import CreateEventDialog
from .edit_event_dialog import EditEventDialog

__all__ = [
    'AddPersonDialog',
    'EndMarriageDialog',
    'CreateMarriageDialog',
    'CreateChildDialog',
    'CreateEventDialog',
    'EditEventDialog'
]

>> âœ… dialogs\about_dialog.py (30 code lines)
"""About dialog showing application information."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDialogButtonBox
from PySide6.QtCore import Qt

if TYPE_CHECKING:
    from main import MainWindow


class AboutDialog(QDialog):
    """Dialog displaying application information and credits."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "About Dynasty Visualizer"
    WINDOW_MIN_WIDTH: int = 400
    
    # Text Content
    APP_NAME: str = "Dynasty Visualizer"
    APP_VERSION: str = "0.2.0"
    APP_DESCRIPTION: str = "A genealogy tracking application for Ostriv settlements"
    AUTHOR: str = "Created by Alex"
    COPYRIGHT: str = "Â© 2025"
    GITHUB_LINK: str = "<a href='https://github.com/yourusername/dynasty-visualizer'>GitHub Repository</a>"
    
    # HTML Content
    ABOUT_TEXT_FORMAT: str = (
        "<center>"
        "<h2>{app_name}</h2>"
        "<p><b>Version:</b> {version}</p>"
        "<p>{description}</p>"
        "<p>{author}</p>"
        "<p>{copyright}</p>"
        "<p>{github}</p>"
        "</center>"
    )
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: MainWindow) -> None:
        """Initialize the about dialog."""
        super().__init__(parent)
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog UI."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        about_text: str = self._create_about_text()
        about_label: QLabel = QLabel(about_text)
        about_label.setTextFormat(Qt.TextFormat.RichText)
        about_label.setOpenExternalLinks(True)
        about_label.setWordWrap(True)
        
        layout.addWidget(about_label)
        
        button_box: QDialogButtonBox = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        button_box.accepted.connect(self.accept)
        layout.addWidget(button_box)
    
    def _create_about_text(self) -> str:
        """Create formatted about text."""
        return self.ABOUT_TEXT_FORMAT.format(
            app_name=self.APP_NAME,
            version=self.APP_VERSION,
            description=self.APP_DESCRIPTION,
            author=self.AUTHOR,
            copyright=self.COPYRIGHT,
            github=self.GITHUB_LINK
        )

>> âœ… dialogs\add_person_dialog.py (126 code lines)
"""Dialog for adding a new person to the database."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QComboBox, QTextEdit,
    QPushButton, QLabel, QDialogButtonBox, QCheckBox, QWidget, QMessageBox
)
from PySide6.QtCore import Qt

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from database.person_repository import PersonRepository
from widgets.date_picker import DatePicker


class AddPersonDialog(QDialog):
    """Dialog for adding a new person with essential information."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "Add New Person"
    WINDOW_MIN_WIDTH: int = 500
    
    # Labels
    LABEL_SPECIAL_CHARS: str = "Special Characters:"
    LABEL_FIRST_NAME: str = "First Name: *"
    LABEL_MIDDLE_NAME: str = "Middle Name:"
    LABEL_LAST_NAME: str = "Last Name: *"
    LABEL_GENDER: str = "Gender:"
    LABEL_BIRTH_DATE: str = "Birth Date: *"
    LABEL_ARRIVAL_DATE: str = "Arrival Date:"
    LABEL_NOTES: str = "Notes:"
    LABEL_EMPTY: str = ""
    
    # Checkboxes
    CHECKBOX_BORN_IN_TOWN: str = "Born in Town"
    
    # Placeholders
    PLACEHOLDER_REQUIRED: str = "Required"
    PLACEHOLDER_OPTIONAL: str = "Optional"
    PLACEHOLDER_NOTES: str = "Optional notes about this person..."
    
    # Special Characters
    SPECIAL_CHARS: list[str] = ['Ã¡', 'Ã½', 'Ã³', 'Ã©', 'Ã­']
    CHAR_BUTTON_MAX_WIDTH: int = 40
    CHAR_BUTTON_TOOLTIP_FORMAT: str = "Insert '{char}' at cursor"
    
    # Gender Options
    GENDER_UNKNOWN: str = "Unknown"
    GENDER_MALE: str = "Male"
    GENDER_FEMALE: str = "Female"
    GENDER_OTHER: str = "Other"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    
    # Message Box Text
    MSG_TEXT_FIRST_NAME_REQUIRED: str = "First name is required."
    MSG_TEXT_LAST_NAME_REQUIRED: str = "Last name is required."
    MSG_TEXT_BIRTH_YEAR_RANGE: str = "Birth year must be between {min} and {max}."
    
    # Layout
    NOTES_MAX_HEIGHT: int = 80
    
    # Date Validation
    BIRTH_YEAR_MIN: int = 1500
    BIRTH_YEAR_MAX: int = 2000
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize add person dialog."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person_repo: PersonRepository = PersonRepository(db_manager)
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._person: Person | None = None
        
        self._setup_ui()
        self._connect_signals()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create and arrange all dialog widgets."""
        self.main_layout: QVBoxLayout = QVBoxLayout(self)
        
        self.main_layout.addLayout(self._create_special_char_toolbar())
        self.main_layout.addWidget(self._create_separator())
        self.main_layout.addLayout(self._create_form_layout())
        self.main_layout.addWidget(self._create_button_box())
    
    def _create_special_char_toolbar(self) -> QHBoxLayout:
        """Create toolbar with special character buttons."""
        toolbar: QHBoxLayout = QHBoxLayout()
        
        label: QLabel = QLabel(self.LABEL_SPECIAL_CHARS)
        toolbar.addWidget(label)
        
        for char in self.SPECIAL_CHARS:
            btn: QPushButton = self._create_special_char_button(char)
            toolbar.addWidget(btn)
        
        toolbar.addStretch()
        
        return toolbar
    
    def _create_special_char_button(self, char: str) -> QPushButton:
        """Create a button for inserting a special character."""
        btn: QPushButton = QPushButton(char)
        btn.setMaximumWidth(self.CHAR_BUTTON_MAX_WIDTH)
        btn.setToolTip(self.CHAR_BUTTON_TOOLTIP_FORMAT.format(char=char))
        btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        btn.clicked.connect(lambda checked, c=char: self._insert_special_char(c))
        return btn
    
    def _create_separator(self) -> QLabel:
        """Create horizontal separator line."""
        separator: QLabel = QLabel()
        separator.setFrameShape(QLabel.Shape.HLine)
        separator.setFrameShadow(QLabel.Shadow.Sunken)
        return separator
    
    def _create_form_layout(self) -> QFormLayout:
        """Create the main form with input fields."""
        form: QFormLayout = QFormLayout()
        
        self._create_name_fields(form)
        self._create_gender_field(form)
        self._create_born_in_town_checkbox(form)
        self._create_date_fields(form)
        self._create_notes_field(form)
        
        return form
    
    def _create_name_fields(self, form: QFormLayout) -> None:
        """Create name input fields."""
        self.first_name_input: QLineEdit = QLineEdit()
        self.first_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        form.addRow(self.LABEL_FIRST_NAME, self.first_name_input)
        
        self.middle_name_input: QLineEdit = QLineEdit()
        self.middle_name_input.setPlaceholderText(self.PLACEHOLDER_OPTIONAL)
        form.addRow(self.LABEL_MIDDLE_NAME, self.middle_name_input)
        
        self.last_name_input: QLineEdit = QLineEdit()
        self.last_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        form.addRow(self.LABEL_LAST_NAME, self.last_name_input)
    
    def _create_gender_field(self, form: QFormLayout) -> None:
        """Create gender selection field."""
        self.gender_input: QComboBox = QComboBox()
        self.gender_input.addItems([
            self.GENDER_UNKNOWN,
            self.GENDER_MALE,
            self.GENDER_FEMALE,
            self.GENDER_OTHER
        ])
        form.addRow(self.LABEL_GENDER, self.gender_input)
    
    def _create_born_in_town_checkbox(self, form: QFormLayout) -> None:
        """Create born in town checkbox."""
        self.born_in_town_check: QCheckBox = QCheckBox(self.CHECKBOX_BORN_IN_TOWN)
        self.born_in_town_check.setChecked(False)
        form.addRow(self.LABEL_EMPTY, self.born_in_town_check)
    
    def _create_date_fields(self, form: QFormLayout) -> None:
        """Create date input fields."""
        self.birth_date_picker: DatePicker = DatePicker()
        form.addRow(self.LABEL_BIRTH_DATE, self.birth_date_picker)
        
        self.arrival_date_label: QLabel = QLabel(self.LABEL_ARRIVAL_DATE)
        self.arrival_date_picker: DatePicker = DatePicker()
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
    
    def _create_notes_field(self, form: QFormLayout) -> None:
        """Create notes text field."""
        self.notes_input: QTextEdit = QTextEdit()
        self.notes_input.setPlaceholderText(self.PLACEHOLDER_NOTES)
        self.notes_input.setMaximumHeight(self.NOTES_MAX_HEIGHT)
        form.addRow(self.LABEL_NOTES, self.notes_input)
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create OK and Cancel buttons."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        
        return button_box
    
    # ------------------------------------------------------------------
    # Signal Handlers
    # ------------------------------------------------------------------
    
    def _connect_signals(self) -> None:
        """Connect widget signals to handlers."""
        self.born_in_town_check.stateChanged.connect(self._update_date_visibility)
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show or hide arrival date based on 'Born in Town' checkbox."""
        is_born_in_town: bool = self.born_in_town_check.isChecked()
        
        self.arrival_date_label.setVisible(not is_born_in_town)
        self.arrival_date_picker.setVisible(not is_born_in_town)
        
        self._update_birth_date_precision(is_born_in_town)
        self._resize_dialog()
    
    def _update_birth_date_precision(self, is_born_in_town: bool) -> None:
        """Update birth date precision hint based on birth location."""
        if is_born_in_town:
            self.birth_date_picker.unknown_check.setChecked(False)
        else:
            self.birth_date_picker.unknown_check.setChecked(True)
    
    def _resize_dialog(self) -> None:
        """Resize dialog to fit content."""
        self.main_layout.invalidate()
        self.main_layout.activate()
        self.resize(self.minimumSizeHint())
    
    def _insert_special_char(self, char: str) -> None:
        """Insert a special character at the cursor position."""
        focused = self.focusWidget()
        
        if not isinstance(focused, QLineEdit):
            return
        
        focused.insert(char)
        focused.setFocus()
    
    def _handle_accept(self) -> None:
        """Validate inputs and create Person object before accepting."""
        if not self._validate_inputs():
            return
        
        self._create_person()
        self._save_person_to_database()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate required fields and show error if invalid."""
        if not self._validate_first_name():
            return False
        
        if not self._validate_last_name():
            return False
        
        if not self._validate_birth_year():
            return False
        
        return True
    
    def _validate_first_name(self) -> bool:
        """Validate first name is not empty."""
        if not self.first_name_input.text().strip():
            self._show_error(self.MSG_TEXT_FIRST_NAME_REQUIRED)
            self.first_name_input.setFocus()
            return False
        
        return True
    
    def _validate_last_name(self) -> bool:
        """Validate last name is not empty."""
        if not self.last_name_input.text().strip():
            self._show_error(self.MSG_TEXT_LAST_NAME_REQUIRED)
            self.last_name_input.setFocus()
            return False
        
        return True
    
    def _validate_birth_year(self) -> bool:
        """Validate birth year is within acceptable range."""
        birth_year, _ = self.birth_date_picker.get_date()
        
        if birth_year < self.BIRTH_YEAR_MIN or birth_year > self.BIRTH_YEAR_MAX:
            self._show_error(
                self.MSG_TEXT_BIRTH_YEAR_RANGE.format(
                    min=self.BIRTH_YEAR_MIN,
                    max=self.BIRTH_YEAR_MAX
                )
            )
            return False
        
        return True
    
    def _show_error(self, message: str) -> None:
        """Display an error message to the user."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_TITLE_VALIDATION_ERROR)
        msg.setText(message)
        msg.exec()
    
    # ------------------------------------------------------------------
    # Person Creation
    # ------------------------------------------------------------------
    
    def _create_person(self) -> None:
        """Create person object from input fields."""
        from models.person import Person
        
        birth_year, birth_month = self.birth_date_picker.get_date()
        arrival_year, arrival_month = self._get_arrival_date()
        
        self._person = Person(
            first_name=self.first_name_input.text().strip(),
            middle_name=self.middle_name_input.text().strip(),
            last_name=self.last_name_input.text().strip(),
            birth_year=birth_year,
            birth_month=birth_month,
            arrival_year=arrival_year,
            arrival_month=arrival_month,
            gender=self.gender_input.currentText(),
            notes=self.notes_input.toPlainText().strip()
        )
    
    def _get_arrival_date(self) -> tuple[int | None, int | None]:
        """Get arrival date or None if born in town."""
        if self.born_in_town_check.isChecked():
            return None, None
        
        return self.arrival_date_picker.get_date()
    
    def _save_person_to_database(self) -> None:
        """Save the created person to database."""
        if self._person is None:
            return
        
        person_id: int = self.person_repo.insert(self._person)
        self._person.id = person_id
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_person(self) -> Person | None:
        """Return the created Person object."""
        return self._person

>> âœ… dialogs\create_child_dialog.py (138 code lines)
"""Dialog for creating a new child."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit,
    QComboBox, QLabel, QDialogButtonBox, QWidget, QMessageBox, 
    QCheckBox, QFrame
)
from PySide6.QtCore import QSignalBlocker, Qt

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from database.person_repository import PersonRepository
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateChildDialog(QDialog):
    """Dialog for creating a new child with pre-filled parents."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "Create Child"
    WINDOW_MIN_WIDTH: int = 550
    
    # Labels
    LABEL_PARENTS: str = "<b>Parents:</b>"
    LABEL_PARENT_1: str = "Parent 1:"
    LABEL_PARENT_2: str = "Parent 2:"
    LABEL_CHILD_INFO: str = "<b>Child Information:</b>"
    LABEL_FIRST_NAME: str = "First Name: *"
    LABEL_LAST_NAME: str = "Last Name: *"
    LABEL_GENDER: str = "Gender:"
    LABEL_BIRTH_DATE: str = "Birth Date:"
    LABEL_ARRIVAL_DATE: str = "Arrival Date:"
    LABEL_WIDTH: int = 85
    
    # Checkboxes
    CHECKBOX_IMMIGRANT: str = "Immigrant"
    
    # Placeholders
    PLACEHOLDER_REQUIRED: str = "Required"
    
    # Gender Options
    GENDER_UNKNOWN: str = "Unknown"
    GENDER_MALE: str = "Male"
    GENDER_FEMALE: str = "Female"
    GENDER_OTHER: str = "Other"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    
    # Message Box Text
    MSG_TEXT_FIRST_NAME_REQUIRED: str = "First name is required."
    MSG_TEXT_LAST_NAME_REQUIRED: str = "Last name is required."
    
    # Layout
    SPACING_INDENT: int = 20
    GENDER_COMBO_MIN_WIDTH: int = 120
    
    # Default Values
    DEFAULT_YEAR: int = 1721
    DEFAULT_MONTH: int = 1
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        parent1: Person,
        parent2_id: int | None = None,
        parent_widget: QWidget | None = None
    ) -> None:
        """Initialize create child dialog."""
        super().__init__(parent_widget)
        
        self.db_manager: DatabaseManager = db_manager
        self.person_repo: PersonRepository = PersonRepository(db_manager)
        self.parent1: Person = parent1
        self.parent2_id: int | None = parent2_id
        
        self.created_person: Person | None = None
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        self._create_parents_section(layout)
        self._create_divider(layout)
        self._create_child_info_section(layout)
        
        layout.addStretch()
        
        self._create_button_box(layout)
        
        self._update_immigrant_state()
    
    def _create_parents_section(self, layout: QVBoxLayout) -> None:
        """Create parents section."""
        parents_header: QLabel = QLabel(self.LABEL_PARENTS)
        layout.addWidget(parents_header)
        
        self._create_parent1_row(layout)
        self._create_parent2_row(layout)
    
    def _create_parent1_row(self, layout: QVBoxLayout) -> None:
        """Create parent 1 display row."""
        parent1_layout: QHBoxLayout = QHBoxLayout()
        parent1_layout.addSpacing(self.SPACING_INDENT)
        
        parent1_label_text: QLabel = QLabel(self.LABEL_PARENT_1)
        parent1_label_text.setMinimumWidth(self.LABEL_WIDTH)
        parent1_layout.addWidget(parent1_label_text)
        
        parent1_name: QLabel = QLabel(f"<b>{self.parent1.display_name}</b>")
        parent1_layout.addWidget(parent1_name)
        parent1_layout.addStretch()
        
        layout.addLayout(parent1_layout)
    
    def _create_parent2_row(self, layout: QVBoxLayout) -> None:
        """Create parent 2 selector row."""
        parent2_layout: QHBoxLayout = QHBoxLayout()
        parent2_layout.addSpacing(self.SPACING_INDENT)
        
        parent2_label_text: QLabel = QLabel(self.LABEL_PARENT_2)
        parent2_label_text.setMinimumWidth(self.LABEL_WIDTH)
        parent2_layout.addWidget(parent2_label_text)
        
        self.parent2_selector: PersonSelector = PersonSelector(self.db_manager)
        if self.parent2_id:
            with QSignalBlocker(self.parent2_selector):
                self.parent2_selector.set_person(self.parent2_id)
        parent2_layout.addWidget(self.parent2_selector)
        
        layout.addLayout(parent2_layout)
    
    def _create_divider(self, layout: QVBoxLayout) -> None:
        """Create horizontal divider line."""
        line: QFrame = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        layout.addWidget(line)
    
    def _create_child_info_section(self, layout: QVBoxLayout) -> None:
        """Create child information section."""
        child_header: QLabel = QLabel(self.LABEL_CHILD_INFO)
        layout.addWidget(child_header)
        
        self._create_first_name_row(layout)
        self._create_last_name_row(layout)
        self._create_gender_row(layout)
        self._create_birth_date_row(layout)
        self._create_immigrant_checkbox(layout)
        self._create_arrival_date_row(layout)
    
    def _create_first_name_row(self, layout: QVBoxLayout) -> None:
        """Create first name input row."""
        first_name_layout: QHBoxLayout = QHBoxLayout()
        first_name_layout.addSpacing(self.SPACING_INDENT)
        
        first_name_label: QLabel = QLabel(self.LABEL_FIRST_NAME)
        first_name_label.setMinimumWidth(self.LABEL_WIDTH)
        first_name_layout.addWidget(first_name_label)
        
        self.first_name_input: QLineEdit = QLineEdit()
        self.first_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        first_name_layout.addWidget(self.first_name_input)
        
        layout.addLayout(first_name_layout)
    
    def _create_last_name_row(self, layout: QVBoxLayout) -> None:
        """Create last name input row."""
        last_name_layout: QHBoxLayout = QHBoxLayout()
        last_name_layout.addSpacing(self.SPACING_INDENT)
        
        last_name_label: QLabel = QLabel(self.LABEL_LAST_NAME)
        last_name_label.setMinimumWidth(self.LABEL_WIDTH)
        last_name_layout.addWidget(last_name_label)
        
        self.last_name_input: QLineEdit = QLineEdit()
        self.last_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        self.last_name_input.setText(self.parent1.last_name)
        last_name_layout.addWidget(self.last_name_input)
        
        layout.addLayout(last_name_layout)
    
    def _create_gender_row(self, layout: QVBoxLayout) -> None:
        """Create gender selection row."""
        gender_layout: QHBoxLayout = QHBoxLayout()
        gender_layout.addSpacing(self.SPACING_INDENT)
        
        gender_label: QLabel = QLabel(self.LABEL_GENDER)
        gender_label.setMinimumWidth(self.LABEL_WIDTH)
        gender_layout.addWidget(gender_label)
        
        self.gender_input: QComboBox = QComboBox()
        self.gender_input.addItems([
            self.GENDER_UNKNOWN,
            self.GENDER_MALE,
            self.GENDER_FEMALE,
            self.GENDER_OTHER
        ])
        self.gender_input.setMinimumWidth(self.GENDER_COMBO_MIN_WIDTH)
        gender_layout.addWidget(self.gender_input)
        gender_layout.addStretch()
        
        layout.addLayout(gender_layout)
    
    def _create_birth_date_row(self, layout: QVBoxLayout) -> None:
        """Create birth date picker row."""
        birth_date_layout: QHBoxLayout = QHBoxLayout()
        birth_date_layout.addSpacing(self.SPACING_INDENT)
        
        birth_date_label: QLabel = QLabel(self.LABEL_BIRTH_DATE)
        birth_date_label.setMinimumWidth(self.LABEL_WIDTH)
        birth_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        birth_date_layout.addWidget(birth_date_label)
        
        self.birth_date_picker: DatePicker = DatePicker()
        self.birth_date_picker.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        birth_date_layout.addWidget(self.birth_date_picker)
        birth_date_layout.addStretch()
        
        layout.addLayout(birth_date_layout)
    
    def _create_immigrant_checkbox(self, layout: QVBoxLayout) -> None:
        """Create immigrant checkbox."""
        immigrant_layout: QHBoxLayout = QHBoxLayout()
        immigrant_layout.addSpacing(self.SPACING_INDENT)
        
        self.immigrant_check: QCheckBox = QCheckBox(self.CHECKBOX_IMMIGRANT)
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        immigrant_layout.addWidget(self.immigrant_check)
        immigrant_layout.addStretch()
        
        layout.addLayout(immigrant_layout)
    
    def _create_arrival_date_row(self, layout: QVBoxLayout) -> None:
        """Create arrival date picker row."""
        arrival_date_layout: QHBoxLayout = QHBoxLayout()
        arrival_date_layout.addSpacing(self.SPACING_INDENT)
        
        self.arrival_date_label: QLabel = QLabel(self.LABEL_ARRIVAL_DATE)
        self.arrival_date_label.setMinimumWidth(self.LABEL_WIDTH)
        self.arrival_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        arrival_date_layout.addWidget(self.arrival_date_label)
        
        self.arrival_date_picker: DatePicker = DatePicker()
        self.arrival_date_picker.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        arrival_date_layout.addWidget(self.arrival_date_picker)
        arrival_date_layout.addStretch()
        
        layout.addLayout(arrival_date_layout)
    
    def _create_button_box(self, layout: QVBoxLayout) -> None:
        """Create dialog button box."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_state()
    
    def _update_immigrant_state(self) -> None:
        """Update visibility based on immigrant status."""
        is_immigrant: bool = self.immigrant_check.isChecked()
        
        self.birth_date_picker.unknown_check.setVisible(False)
        self.birth_date_picker.month_spin.setEnabled(not is_immigrant)
        
        if is_immigrant:
            self.birth_date_picker.unknown_check.setChecked(True)
        else:
            self.birth_date_picker.unknown_check.setChecked(False)
        
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)
        self.arrival_date_picker.unknown_check.setVisible(False)
    
    def _handle_accept(self) -> None:
        """Validate and create child."""
        if not self._validate_inputs():
            return
        
        self._create_child()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate all input fields."""
        if not self._validate_first_name():
            return False
        
        if not self._validate_last_name():
            return False
        
        return True
    
    def _validate_first_name(self) -> bool:
        """Validate first name is not empty."""
        first_name: str = self.first_name_input.text().strip()
        
        if not first_name:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_FIRST_NAME_REQUIRED
            )
            return False
        
        return True
    
    def _validate_last_name(self) -> bool:
        """Validate last name is not empty."""
        last_name: str = self.last_name_input.text().strip()
        
        if not last_name:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_LAST_NAME_REQUIRED
            )
            return False
        
        return True
    
    # ------------------------------------------------------------------
    # Child Creation
    # ------------------------------------------------------------------
    
    def _create_child(self) -> None:
        """Create child person object."""
        from models.person import Person
        
        first_name: str = self.first_name_input.text().strip()
        last_name: str = self.last_name_input.text().strip()
        gender: str = self.gender_input.currentText()
        
        birth_year, birth_month = self._get_birth_date()
        arrival_year, arrival_month = self._get_arrival_date()
        father_id, mother_id = self._determine_parent_ids()
        
        new_person: Person = Person(
            first_name=first_name,
            last_name=last_name,
            gender=gender,
            birth_year=birth_year,
            birth_month=birth_month,
            arrival_year=arrival_year,
            arrival_month=arrival_month,
            father_id=father_id,
            mother_id=mother_id,
            dynasty_id=self.parent1.dynasty_id
        )
        
        person_id: int = self.person_repo.insert(new_person)
        new_person.id = person_id
        
        self.created_person = new_person
    
    def _get_birth_date(self) -> tuple[int | None, int | None]:
        """Get birth date based on immigrant status."""
        if self.immigrant_check.isChecked():
            birth_year, _ = self.birth_date_picker.get_date()
            return birth_year, None
        
        return self.birth_date_picker.get_date()
    
    def _get_arrival_date(self) -> tuple[int | None, int | None]:
        """Get arrival date if immigrant."""
        if self.immigrant_check.isChecked():
            return self.arrival_date_picker.get_date()
        
        return None, None
    
    def _determine_parent_ids(self) -> tuple[int | None, int | None]:
        """Determine father and mother IDs based on parent genders."""
        parent2_id: int | None = self.parent2_selector.get_person_id()
        
        if self.parent1.gender == self.GENDER_MALE:
            return self.parent1.id, parent2_id
        
        if self.parent1.gender == self.GENDER_FEMALE:
            return parent2_id, self.parent1.id
        
        return self.parent1.id, parent2_id
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_created_person(self) -> Person | None:
        """Returns the created child Person."""
        return self.created_person

>> âœ… dialogs\create_event_dialog.py (124 code lines)
"""Dialog for creating a new event."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QComboBox,
    QLabel, QDialogButtonBox, QWidget, QMessageBox, QTextEdit, QCheckBox
)

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person
    from models.event import Event

from widgets.date_picker import DatePicker


class CreateEventDialog(QDialog):
    """Dialog for creating a new life event."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE_FORMAT: str = "Create Event for {name}"
    WINDOW_MIN_WIDTH: int = 550
    
    # Labels
    LABEL_EVENT_TYPE: str = "Event Type: *"
    LABEL_EVENT_TITLE: str = "Event Title: *"
    LABEL_START_DATE: str = "Start Date:"
    LABEL_END_DATE: str = "End Date:"
    LABEL_NOTES: str = "Notes:"
    LABEL_WIDTH: int = 100
    
    # Checkboxes
    CHECKBOX_ONGOING: str = "Ongoing Event"
    
    # Placeholders
    PLACEHOLDER_TITLE: str = "E.g., 'Became Blacksmith', 'Moved to Town'"
    PLACEHOLDER_NOTES: str = "Optional notes about this event..."
    
    # Event Types
    EVENT_TYPE_BIRTH: str = "Birth"
    EVENT_TYPE_DEATH: str = "Death"
    EVENT_TYPE_MARRIAGE: str = "Marriage"
    EVENT_TYPE_DIVORCE: str = "Divorce"
    EVENT_TYPE_JOB: str = "Job"
    EVENT_TYPE_EDUCATION: str = "Education"
    EVENT_TYPE_MOVE: str = "Move"
    EVENT_TYPE_MILITARY: str = "Military"
    EVENT_TYPE_IMMIGRATION: str = "Immigration"
    EVENT_TYPE_OTHER: str = "Other"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    MSG_TITLE_INVALID_DATE: str = "Invalid Date"
    
    # Message Box Text
    MSG_TEXT_TYPE_REQUIRED: str = "Event type is required."
    MSG_TEXT_TITLE_REQUIRED: str = "Event title is required."
    MSG_TEXT_END_BEFORE_START: str = "End date cannot be before start date."
    
    # Layout
    SPACING_INDENT: int = 10
    NOTES_MAX_HEIGHT: int = 100
    
    # Default Values
    DEFAULT_YEAR: int = 1721
    DEFAULT_MONTH: int = 1
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        """Initialize create event dialog."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.created_event: Event | None = None
        
        self.setWindowTitle(self.WINDOW_TITLE_FORMAT.format(name=person.display_name))
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        self._create_event_type_row(layout)
        self._create_event_title_row(layout)
        self._create_start_date_row(layout)
        self._create_ongoing_checkbox(layout)
        self._create_end_date_row(layout)
        self._create_notes_section(layout)
        
        layout.addStretch()
        
        self._create_button_box(layout)
        
        self._update_ongoing_state()
    
    def _create_event_type_row(self, layout: QVBoxLayout) -> None:
        """Create event type selection row."""
        type_layout: QHBoxLayout = QHBoxLayout()
        
        type_label: QLabel = QLabel(self.LABEL_EVENT_TYPE)
        type_label.setMinimumWidth(self.LABEL_WIDTH)
        type_layout.addWidget(type_label)
        
        self.event_type_input: QComboBox = QComboBox()
        self.event_type_input.addItems([
            self.EVENT_TYPE_BIRTH,
            self.EVENT_TYPE_DEATH,
            self.EVENT_TYPE_MARRIAGE,
            self.EVENT_TYPE_DIVORCE,
            self.EVENT_TYPE_JOB,
            self.EVENT_TYPE_EDUCATION,
            self.EVENT_TYPE_MOVE,
            self.EVENT_TYPE_MILITARY,
            self.EVENT_TYPE_IMMIGRATION,
            self.EVENT_TYPE_OTHER
        ])
        self.event_type_input.setEditable(True)
        type_layout.addWidget(self.event_type_input)
        
        layout.addLayout(type_layout)
    
    def _create_event_title_row(self, layout: QVBoxLayout) -> None:
        """Create event title input row."""
        title_layout: QHBoxLayout = QHBoxLayout()
        
        title_label: QLabel = QLabel(self.LABEL_EVENT_TITLE)
        title_label.setMinimumWidth(self.LABEL_WIDTH)
        title_layout.addWidget(title_label)
        
        self.event_title_input: QLineEdit = QLineEdit()
        self.event_title_input.setPlaceholderText(self.PLACEHOLDER_TITLE)
        title_layout.addWidget(self.event_title_input)
        
        layout.addLayout(title_layout)
    
    def _create_start_date_row(self, layout: QVBoxLayout) -> None:
        """Create start date picker row."""
        start_date_layout: QHBoxLayout = QHBoxLayout()
        
        start_date_label: QLabel = QLabel(self.LABEL_START_DATE)
        start_date_label.setMinimumWidth(self.LABEL_WIDTH)
        start_date_layout.addWidget(start_date_label)
        
        self.start_date_picker: DatePicker = DatePicker()
        self.start_date_picker.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        start_date_layout.addWidget(self.start_date_picker)
        start_date_layout.addStretch()
        
        layout.addLayout(start_date_layout)
    
    def _create_ongoing_checkbox(self, layout: QVBoxLayout) -> None:
        """Create ongoing event checkbox."""
        ongoing_layout: QHBoxLayout = QHBoxLayout()
        ongoing_layout.addSpacing(self.LABEL_WIDTH + self.SPACING_INDENT)
        
        self.ongoing_check: QCheckBox = QCheckBox(self.CHECKBOX_ONGOING)
        self.ongoing_check.setChecked(False)
        self.ongoing_check.stateChanged.connect(self._on_ongoing_toggled)
        ongoing_layout.addWidget(self.ongoing_check)
        ongoing_layout.addStretch()
        
        layout.addLayout(ongoing_layout)
    
    def _create_end_date_row(self, layout: QVBoxLayout) -> None:
        """Create end date picker row."""
        end_date_layout: QHBoxLayout = QHBoxLayout()
        
        self.end_date_label: QLabel = QLabel(self.LABEL_END_DATE)
        self.end_date_label.setMinimumWidth(self.LABEL_WIDTH)
        end_date_layout.addWidget(self.end_date_label)
        
        self.end_date_picker: DatePicker = DatePicker()
        self.end_date_picker.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        end_date_layout.addWidget(self.end_date_picker)
        end_date_layout.addStretch()
        
        layout.addLayout(end_date_layout)
    
    def _create_notes_section(self, layout: QVBoxLayout) -> None:
        """Create notes text area."""
        notes_layout: QVBoxLayout = QVBoxLayout()
        
        notes_label: QLabel = QLabel(self.LABEL_NOTES)
        notes_layout.addWidget(notes_label)
        
        self.notes_input: QTextEdit = QTextEdit()
        self.notes_input.setPlaceholderText(self.PLACEHOLDER_NOTES)
        self.notes_input.setMaximumHeight(self.NOTES_MAX_HEIGHT)
        notes_layout.addWidget(self.notes_input)
        
        layout.addLayout(notes_layout)
    
    def _create_button_box(self, layout: QVBoxLayout) -> None:
        """Create dialog button box."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _on_ongoing_toggled(self) -> None:
        """Handle ongoing checkbox toggle."""
        self._update_ongoing_state()
    
    def _update_ongoing_state(self) -> None:
        """Show/hide end date based on ongoing status."""
        is_ongoing: bool = self.ongoing_check.isChecked()
        self.end_date_label.setVisible(not is_ongoing)
        self.end_date_picker.setVisible(not is_ongoing)
    
    def _handle_accept(self) -> None:
        """Validate and create event."""
        if not self._validate_inputs():
            return
        
        self._create_event()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate all input fields."""
        if not self._validate_event_type():
            return False
        
        if not self._validate_event_title():
            return False
        
        if not self._validate_date_range():
            return False
        
        return True
    
    def _validate_event_type(self) -> bool:
        """Validate event type is not empty."""
        event_type: str = self.event_type_input.currentText().strip()
        
        if not event_type:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_TYPE_REQUIRED
            )
            return False
        
        return True
    
    def _validate_event_title(self) -> bool:
        """Validate event title is not empty."""
        event_title: str = self.event_title_input.text().strip()
        
        if not event_title:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_TITLE_REQUIRED
            )
            return False
        
        return True
    
    def _validate_date_range(self) -> bool:
        """Validate end date is after start date."""
        if self.ongoing_check.isChecked():
            return True
        
        start_year, start_month = self.start_date_picker.get_date()
        end_year, end_month = self.end_date_picker.get_date()
        
        if not start_year or not end_year:
            return True
        
        if end_year < start_year:
            self._show_invalid_date_error()
            return False
        
        if end_year == start_year and start_month and end_month:
            if end_month < start_month:
                self._show_invalid_date_error()
                return False
        
        return True
    
    def _show_invalid_date_error(self) -> None:
        """Show error for invalid date range."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_INVALID_DATE,
            self.MSG_TEXT_END_BEFORE_START
        )
    
    # ------------------------------------------------------------------
    # Event Creation
    # ------------------------------------------------------------------
    
    def _create_event(self) -> None:
        """Create event from input fields."""
        from models.event import Event
        
        event_type: str = self.event_type_input.currentText().strip()
        event_title: str = self.event_title_input.text().strip()
        start_year, start_month = self.start_date_picker.get_date()
        end_year, end_month = self._get_end_date()
        notes: str = self.notes_input.toPlainText().strip()
        
        self.created_event = Event(
            person_id=self.person.id,
            event_type=event_type,
            event_title=event_title,
            start_year=start_year,
            start_month=start_month,
            end_year=end_year,
            end_month=end_month,
            notes=notes
        )
    
    def _get_end_date(self) -> tuple[int | None, int | None]:
        """Get end date or None if ongoing."""
        if self.ongoing_check.isChecked():
            return None, None
        
        return self.end_date_picker.get_date()
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_created_event(self) -> Event | None:
        """Returns the created event."""
        return self.created_event

>> âœ… dialogs\create_marriage_dialog.py (59 code lines)
"""Dialog for creating a new marriage."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QCheckBox,
    QDialogButtonBox, QWidget, QMessageBox
)

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateMarriageDialog(QDialog):
    """Dialog for creating a new marriage relationship."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "Create Marriage"
    WINDOW_MIN_WIDTH: int = 450
    
    # Labels
    LABEL_PERSON_1: str = "Person 1:"
    LABEL_PERSON_2: str = "Person 2:"
    LABEL_MARRIAGE_DATE: str = "Marriage Date:"
    
    # Checkboxes
    CHECKBOX_DATE_UNKNOWN: str = "Date Unknown"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    
    # Message Box Text
    MSG_TEXT_SELECT_SPOUSE: str = "Please select a spouse."
    MSG_TEXT_SELF_MARRIAGE: str = "A person cannot marry themselves."
    
    # Layout
    SPACING_ALIGNMENT: int = 85
    
    # Default Values
    DEFAULT_YEAR: int = 1721
    DEFAULT_MONTH: int = 1
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        """Initialize create marriage dialog."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.spouse_id: int | None = None
        self.marriage_year: int | None = None
        self.marriage_month: int | None = None
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        self._create_person_1_row(layout)
        self._create_person_2_row(layout)
        self._create_date_unknown_checkbox(layout)
        self._create_marriage_date_row(layout)
        
        layout.addStretch()
        
        self._create_button_box(layout)
        
        self._update_date_visibility()
    
    def _create_person_1_row(self, layout: QVBoxLayout) -> None:
        """Create person 1 display row."""
        person1_layout: QHBoxLayout = QHBoxLayout()
        person1_layout.addWidget(QLabel(self.LABEL_PERSON_1))
        
        person1_label: QLabel = QLabel(f"<b>{self.person.display_name}</b>")
        person1_layout.addWidget(person1_label)
        person1_layout.addStretch()
        
        layout.addLayout(person1_layout)
    
    def _create_person_2_row(self, layout: QVBoxLayout) -> None:
        """Create person 2 selector row."""
        person2_layout: QHBoxLayout = QHBoxLayout()
        person2_layout.addWidget(QLabel(self.LABEL_PERSON_2))
        
        self.spouse_selector: PersonSelector = PersonSelector(self.db_manager)
        person2_layout.addWidget(self.spouse_selector)
        
        layout.addLayout(person2_layout)
    
    def _create_date_unknown_checkbox(self, layout: QVBoxLayout) -> None:
        """Create date unknown checkbox."""
        date_unknown_layout: QHBoxLayout = QHBoxLayout()
        date_unknown_layout.addSpacing(self.SPACING_ALIGNMENT)
        
        self.date_unknown_check: QCheckBox = QCheckBox(self.CHECKBOX_DATE_UNKNOWN)
        self.date_unknown_check.setChecked(True)
        self.date_unknown_check.stateChanged.connect(self._on_date_unknown_toggled)
        date_unknown_layout.addWidget(self.date_unknown_check)
        date_unknown_layout.addStretch()
        
        layout.addLayout(date_unknown_layout)
    
    def _create_marriage_date_row(self, layout: QVBoxLayout) -> None:
        """Create marriage date picker row."""
        marriage_date_layout: QHBoxLayout = QHBoxLayout()
        
        self.marriage_date_label: QLabel = QLabel(self.LABEL_MARRIAGE_DATE)
        marriage_date_layout.addWidget(self.marriage_date_label)
        
        self.marriage_date: DatePicker = DatePicker()
        self.marriage_date.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        self.marriage_date.unknown_check.setVisible(False)
        marriage_date_layout.addWidget(self.marriage_date)
        marriage_date_layout.addStretch()
        
        layout.addLayout(marriage_date_layout)
    
    def _create_button_box(self, layout: QVBoxLayout) -> None:
        """Create dialog button box."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _on_date_unknown_toggled(self) -> None:
        """Handle date unknown checkbox toggle."""
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show/hide marriage date based on checkbox."""
        date_known: bool = not self.date_unknown_check.isChecked()
        self.marriage_date_label.setVisible(date_known)
        self.marriage_date.setVisible(date_known)
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        if not self._validate_inputs():
            return
        
        self._collect_marriage_data()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate all input fields."""
        spouse_id: int | None = self.spouse_selector.get_person_id()
        
        if not spouse_id:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_SELECT_SPOUSE
            )
            return False
        
        if spouse_id == self.person.id:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_SELF_MARRIAGE
            )
            return False
        
        return True
    
    # ------------------------------------------------------------------
    # Data Collection
    # ------------------------------------------------------------------
    
    def _collect_marriage_data(self) -> None:
        """Collect marriage data from input fields."""
        self.spouse_id = self.spouse_selector.get_person_id()
        
        if self.date_unknown_check.isChecked():
            self.marriage_year = None
            self.marriage_month = None
        else:
            year, month = self.marriage_date.get_date()
            self.marriage_year = year
            self.marriage_month = month
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_marriage_data(self) -> tuple[int | None, int | None, int | None]:
        """Returns (spouse_id, year, month)."""
        return (self.spouse_id, self.marriage_year, self.marriage_month)

>> âœ… dialogs\edit_event_dialog.py (160 code lines)
"""Dialog for editing an existing event."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QComboBox,
    QLabel, QDialogButtonBox, QWidget, QMessageBox, QTextEdit, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.event import Event

from widgets.date_picker import DatePicker


class EditEventDialog(QDialog):
    """Dialog for editing an existing life event."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE_FORMAT: str = "Edit Event: {title}"
    WINDOW_MIN_WIDTH: int = 550
    
    # Labels
    LABEL_EVENT_TYPE: str = "Event Type: *"
    LABEL_EVENT_TITLE: str = "Event Title: *"
    LABEL_START_DATE: str = "Start Date:"
    LABEL_END_DATE: str = "End Date:"
    LABEL_NOTES: str = "Notes:"
    LABEL_WIDTH: int = 100
    
    # Checkboxes
    CHECKBOX_ONGOING: str = "Ongoing Event"
    
    # Placeholders
    PLACEHOLDER_TITLE: str = "E.g., 'Became Blacksmith', 'Moved to Town'"
    PLACEHOLDER_NOTES: str = "Optional notes about this event..."
    
    # Event Types
    EVENT_TYPE_BIRTH: str = "Birth"
    EVENT_TYPE_DEATH: str = "Death"
    EVENT_TYPE_MARRIAGE: str = "Marriage"
    EVENT_TYPE_DIVORCE: str = "Divorce"
    EVENT_TYPE_JOB: str = "Job"
    EVENT_TYPE_EDUCATION: str = "Education"
    EVENT_TYPE_MOVE: str = "Move"
    EVENT_TYPE_MILITARY: str = "Military"
    EVENT_TYPE_IMMIGRATION: str = "Immigration"
    EVENT_TYPE_OTHER: str = "Other"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    MSG_TITLE_INVALID_DATE: str = "Invalid Date"
    
    # Message Box Text
    MSG_TEXT_TYPE_REQUIRED: str = "Event type is required."
    MSG_TEXT_TITLE_REQUIRED: str = "Event title is required."
    MSG_TEXT_END_BEFORE_START: str = "End date cannot be before start date."
    
    # Layout
    SPACING_INDENT: int = 10
    NOTES_MAX_HEIGHT: int = 100
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        life_event: Event,
        parent: QWidget | None = None
    ) -> None:
        """Initialize edit event dialog."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.life_event: Event = life_event
        self.original_event_data: dict = self._capture_event_state()
        
        self.setWindowTitle(self.WINDOW_TITLE_FORMAT.format(title=life_event.event_title))
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
        self._load_event()
    
    def _capture_event_state(self) -> dict:
        """Capture current event data for undo."""
        return {
            'id': self.life_event.id,
            'person_id': self.life_event.person_id,
            'event_type': self.life_event.event_type,
            'event_title': self.life_event.event_title,
            'start_year': self.life_event.start_year,
            'start_month': self.life_event.start_month,
            'end_year': self.life_event.end_year,
            'end_month': self.life_event.end_month,
            'notes': self.life_event.notes
        }
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        self._create_event_type_row(layout)
        self._create_event_title_row(layout)
        self._create_start_date_row(layout)
        self._create_ongoing_checkbox(layout)
        self._create_end_date_row(layout)
        self._create_notes_section(layout)
        
        layout.addStretch()
        
        self._create_button_box(layout)
    
    def _create_event_type_row(self, layout: QVBoxLayout) -> None:
        """Create event type selection row."""
        type_layout: QHBoxLayout = QHBoxLayout()
        
        type_label: QLabel = QLabel(self.LABEL_EVENT_TYPE)
        type_label.setMinimumWidth(self.LABEL_WIDTH)
        type_layout.addWidget(type_label)
        
        self.event_type_input: QComboBox = QComboBox()
        self.event_type_input.addItems([
            self.EVENT_TYPE_BIRTH,
            self.EVENT_TYPE_DEATH,
            self.EVENT_TYPE_MARRIAGE,
            self.EVENT_TYPE_DIVORCE,
            self.EVENT_TYPE_JOB,
            self.EVENT_TYPE_EDUCATION,
            self.EVENT_TYPE_MOVE,
            self.EVENT_TYPE_MILITARY,
            self.EVENT_TYPE_IMMIGRATION,
            self.EVENT_TYPE_OTHER
        ])
        self.event_type_input.setEditable(True)
        type_layout.addWidget(self.event_type_input)
        
        layout.addLayout(type_layout)
    
    def _create_event_title_row(self, layout: QVBoxLayout) -> None:
        """Create event title input row."""
        title_layout: QHBoxLayout = QHBoxLayout()
        
        title_label: QLabel = QLabel(self.LABEL_EVENT_TITLE)
        title_label.setMinimumWidth(self.LABEL_WIDTH)
        title_layout.addWidget(title_label)
        
        self.event_title_input: QLineEdit = QLineEdit()
        self.event_title_input.setPlaceholderText(self.PLACEHOLDER_TITLE)
        title_layout.addWidget(self.event_title_input)
        
        layout.addLayout(title_layout)
    
    def _create_start_date_row(self, layout: QVBoxLayout) -> None:
        """Create start date picker row."""
        start_date_layout: QHBoxLayout = QHBoxLayout()
        
        start_date_label: QLabel = QLabel(self.LABEL_START_DATE)
        start_date_label.setMinimumWidth(self.LABEL_WIDTH)
        start_date_layout.addWidget(start_date_label)
        
        self.start_date_picker: DatePicker = DatePicker()
        start_date_layout.addWidget(self.start_date_picker)
        start_date_layout.addStretch()
        
        layout.addLayout(start_date_layout)
    
    def _create_ongoing_checkbox(self, layout: QVBoxLayout) -> None:
        """Create ongoing event checkbox."""
        ongoing_layout: QHBoxLayout = QHBoxLayout()
        ongoing_layout.addSpacing(self.LABEL_WIDTH + self.SPACING_INDENT)
        
        self.ongoing_check: QCheckBox = QCheckBox(self.CHECKBOX_ONGOING)
        self.ongoing_check.stateChanged.connect(self._on_ongoing_toggled)
        ongoing_layout.addWidget(self.ongoing_check)
        ongoing_layout.addStretch()
        
        layout.addLayout(ongoing_layout)
    
    def _create_end_date_row(self, layout: QVBoxLayout) -> None:
        """Create end date picker row."""
        end_date_layout: QHBoxLayout = QHBoxLayout()
        
        self.end_date_label: QLabel = QLabel(self.LABEL_END_DATE)
        self.end_date_label.setMinimumWidth(self.LABEL_WIDTH)
        end_date_layout.addWidget(self.end_date_label)
        
        self.end_date_picker: DatePicker = DatePicker()
        end_date_layout.addWidget(self.end_date_picker)
        end_date_layout.addStretch()
        
        layout.addLayout(end_date_layout)
    
    def _create_notes_section(self, layout: QVBoxLayout) -> None:
        """Create notes text area."""
        notes_layout: QVBoxLayout = QVBoxLayout()
        
        notes_label: QLabel = QLabel(self.LABEL_NOTES)
        notes_layout.addWidget(notes_label)
        
        self.notes_input: QTextEdit = QTextEdit()
        self.notes_input.setPlaceholderText(self.PLACEHOLDER_NOTES)
        self.notes_input.setMaximumHeight(self.NOTES_MAX_HEIGHT)
        notes_layout.addWidget(self.notes_input)
        
        layout.addLayout(notes_layout)
    
    def _create_button_box(self, layout: QVBoxLayout) -> None:
        """Create dialog button box."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    # ------------------------------------------------------------------
    # Data Loading
    # ------------------------------------------------------------------
    
    def _load_event(self) -> None:
        """Load event data into form fields."""
        blockers: list[QSignalBlocker] = [
            QSignalBlocker(self.event_type_input),
            QSignalBlocker(self.event_title_input),
            QSignalBlocker(self.start_date_picker),
            QSignalBlocker(self.ongoing_check),
            QSignalBlocker(self.end_date_picker),
            QSignalBlocker(self.notes_input),
        ]
        
        self._load_event_type()
        self._load_event_title()
        self._load_start_date()
        self._load_end_date()
        self._load_notes()
        
        self._update_ongoing_state()
    
    def _load_event_type(self) -> None:
        """Load event type into combo box."""
        index: int = self.event_type_input.findText(self.life_event.event_type)
        
        if index >= 0:
            self.event_type_input.setCurrentIndex(index)
        else:
            self.event_type_input.setCurrentText(self.life_event.event_type)
    
    def _load_event_title(self) -> None:
        """Load event title into input field."""
        self.event_title_input.setText(self.life_event.event_title)
    
    def _load_start_date(self) -> None:
        """Load start date into picker."""
        if self.life_event.start_year:
            self.start_date_picker.set_date(
                self.life_event.start_year,
                self.life_event.start_month
            )
    
    def _load_end_date(self) -> None:
        """Load end date or mark as ongoing."""
        if self.life_event.is_ongoing:
            self.ongoing_check.setChecked(True)
        else:
            self.ongoing_check.setChecked(False)
            if self.life_event.end_year:
                self.end_date_picker.set_date(
                    self.life_event.end_year,
                    self.life_event.end_month
                )
    
    def _load_notes(self) -> None:
        """Load notes into text area."""
        self.notes_input.setPlainText(self.life_event.notes)
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _on_ongoing_toggled(self) -> None:
        """Handle ongoing checkbox toggle."""
        self._update_ongoing_state()
    
    def _update_ongoing_state(self) -> None:
        """Show/hide end date based on ongoing status."""
        is_ongoing: bool = self.ongoing_check.isChecked()
        self.end_date_label.setVisible(not is_ongoing)
        self.end_date_picker.setVisible(not is_ongoing)
    
    def _handle_accept(self) -> None:
        """Validate and save event."""
        if not self._validate_inputs():
            return
        
        self._update_event_from_inputs()
        self._execute_edit_command()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate all input fields."""
        if not self._validate_event_type():
            return False
        
        if not self._validate_event_title():
            return False
        
        if not self._validate_date_range():
            return False
        
        return True
    
    def _validate_event_type(self) -> bool:
        """Validate event type is not empty."""
        event_type: str = self.event_type_input.currentText().strip()
        
        if not event_type:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_TYPE_REQUIRED
            )
            return False
        
        return True
    
    def _validate_event_title(self) -> bool:
        """Validate event title is not empty."""
        event_title: str = self.event_title_input.text().strip()
        
        if not event_title:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_TITLE_REQUIRED
            )
            return False
        
        return True
    
    def _validate_date_range(self) -> bool:
        """Validate end date is after start date."""
        if self.ongoing_check.isChecked():
            return True
        
        start_year, start_month = self.start_date_picker.get_date()
        end_year, end_month = self.end_date_picker.get_date()
        
        if not start_year or not end_year:
            return True
        
        if self._is_end_before_start(start_year, start_month, end_year, end_month):
            self._show_invalid_date_error()
            return False
        
        return True
    
    def _is_end_before_start(
        self,
        start_year: int,
        start_month: int | None,
        end_year: int,
        end_month: int | None
    ) -> bool:
        """Check if end date is before start date."""
        if end_year < start_year:
            return True
        
        if end_year == start_year and start_month and end_month:
            if end_month < start_month:
                return True
        
        return False
    
    def _show_invalid_date_error(self) -> None:
        """Show error for invalid date range."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_INVALID_DATE,
            self.MSG_TEXT_END_BEFORE_START
        )
    
    # ------------------------------------------------------------------
    # Event Update
    # ------------------------------------------------------------------
    
    def _update_event_from_inputs(self) -> None:
        """Update event object from input fields."""
        self.life_event.event_type = self.event_type_input.currentText().strip()
        self.life_event.event_title = self.event_title_input.text().strip()
        
        start_year, start_month = self.start_date_picker.get_date()
        self.life_event.start_year = start_year
        self.life_event.start_month = start_month
        
        end_year, end_month = self._get_end_date()
        self.life_event.end_year = end_year
        self.life_event.end_month = end_month
        
        self.life_event.notes = self.notes_input.toPlainText().strip()
    
    def _get_end_date(self) -> tuple[int | None, int | None]:
        """Get end date or None if ongoing."""
        if self.ongoing_check.isChecked():
            return None, None
        
        return self.end_date_picker.get_date()
    
    def _execute_edit_command(self) -> None:
        """Create and execute edit event command through undo manager."""
        from commands.genealogy_commands.edit_event import EditEventCommand
        
        command: EditEventCommand = EditEventCommand(
            db_manager=self.db_manager,
            event=self.life_event,
            original_event_data=self.original_event_data
        )
        
        main_window = self._find_main_window()
        
        if not main_window:
            return
        
        main_window.undo_manager.execute(command)
        main_window.db.mark_dirty()
        main_window.refresh_ui()
        main_window.edit_actions.update_undo_redo_actions()
    
    def _find_main_window(self):
        """Find the main window for accessing undo manager."""
        parent = self.parent()
        
        while parent:
            from main import MainWindow
            if isinstance(parent, MainWindow):
                return parent
            parent = parent.parent()
        
        return None

>> âœ… dialogs\edit_person_dialog.py (118 code lines)
"""Dialog for editing a person with tabbed sections."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QHBoxLayout, QVBoxLayout, QListWidget,
    QStackedWidget, QDialogButtonBox, QWidget, QMessageBox
)

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person
    from models.marriage import Marriage
    from models.event import Event

from database.person_repository import PersonRepository
from database.marriage_repository import MarriageRepository
from database.event_repository import EventRepository
from dialogs.edit_person_panels.general_panel import GeneralPanel
from dialogs.edit_person_panels.relationships_panel import RelationshipsPanel
from dialogs.edit_person_panels.event_panel import EventsPanel
from commands.genealogy_commands.edit_person import EditPersonCommand


class EditPersonDialog(QDialog):
    """Tabbed dialog for comprehensive person editing."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Panel Indices
    PANEL_INDEX_GENERAL: int = 0
    PANEL_INDEX_RELATIONSHIPS: int = 1
    PANEL_INDEX_EVENTS: int = 2
    
    # Panel Names
    PANEL_NAME_GENERAL: str = "General"
    PANEL_NAME_RELATIONSHIPS: str = "Relationships"
    PANEL_NAME_EVENTS: str = "Events"
    
    # Layout
    SIDEBAR_WIDTH: int = 150
    MIN_DIALOG_WIDTH: int = 700
    MIN_DIALOG_HEIGHT: int = 500
    
    # Button Text
    BUTTON_TEXT_APPLY: str = "Apply"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    MSG_TITLE_CHANGES_SAVED: str = "Changes Saved"
    MSG_TITLE_UNSAVED_CHANGES: str = "Unsaved Changes"
    
    # Message Box Text
    MSG_TEXT_CHANGES_SAVED: str = "Your edits have been saved successfully."
    MSG_TEXT_UNSAVED_CHANGES: str = "You have unsaved changes. Discard them?"
    
    # Window Title
    WINDOW_TITLE_FORMAT: str = "Edit Person: {name}"
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        """Initialize edit person dialog with database manager and person."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person: Person = person
        self.has_unsaved_changes: bool = False
        
        self.setWindowTitle(self.WINDOW_TITLE_FORMAT.format(name=person.display_name))
        self.setMinimumSize(self.MIN_DIALOG_WIDTH, self.MIN_DIALOG_HEIGHT)
        
        self._capture_original_state()
        self._setup_ui()
        self._load_data()
    
    def _capture_original_state(self) -> None:
        """Capture original state of person and related data for undo."""
        self.original_person_data: dict = self._capture_person_state()
        self.original_marriages: list[Marriage] = self._capture_marriages_state()
        self.original_events: list[Event] = self._capture_events_state()
    
    def _capture_person_state(self) -> dict:
        """Capture current person data for undo."""
        return {
            'id': self.person.id,
            'first_name': self.person.first_name,
            'middle_name': self.person.middle_name,
            'last_name': self.person.last_name,
            'birth_year': self.person.birth_year,
            'birth_month': self.person.birth_month,
            'death_year': self.person.death_year,
            'death_month': self.person.death_month,
            'arrival_year': self.person.arrival_year,
            'arrival_month': self.person.arrival_month,
            'moved_out_year': self.person.moved_out_year,
            'moved_out_month': self.person.moved_out_month,
            'gender': self.person.gender,
            'education_level': self.person.education,
            'dynasty_id': self.person.dynasty_id,
            'father_id': self.person.father_id,
            'mother_id': self.person.mother_id,
            'notes': self.person.notes
        }
    
    def _capture_marriages_state(self) -> list[Marriage]:
        """Capture current marriages for undo."""
        if not self.person.id:
            return []
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db_manager)
        marriages: list[Marriage] = marriage_repo.get_by_person(self.person.id)
        
        return [self._copy_marriage(m) for m in marriages]
    
    def _copy_marriage(self, marriage: Marriage) -> Marriage:
        """Create a copy of marriage for original state."""
        from models.marriage import Marriage
        return Marriage(
            id=marriage.id,
            spouse1_id=marriage.spouse1_id,
            spouse2_id=marriage.spouse2_id,
            marriage_year=marriage.marriage_year,
            marriage_month=marriage.marriage_month,
            dissolution_year=marriage.dissolution_year,
            dissolution_month=marriage.dissolution_month,
            dissolution_day=marriage.dissolution_day,
            dissolution_reason=marriage.dissolution_reason
        )
    
    def _capture_events_state(self) -> list[Event]:
        """Capture current events for undo."""
        if not self.person.id:
            return []
        
        event_repo: EventRepository = EventRepository(self.db_manager)
        events: list[Event] = event_repo.get_by_person(self.person.id)
        
        return [self._copy_event(e) for e in events]
    
    def _copy_event(self, event: Event) -> Event:
        """Create a copy of event for original state."""
        from models.event import Event
        return Event(
            id=event.id,
            person_id=event.person_id,
            event_type=event.event_type,
            event_title=event.event_title,
            start_year=event.start_year,
            start_month=event.start_month,
            end_year=event.end_year,
            end_month=event.end_month,
            notes=event.notes
        )
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create the main dialog layout with sidebar and panels."""
        main_layout: QVBoxLayout = QVBoxLayout(self)
        
        content_layout: QHBoxLayout = self._create_content_layout()
        main_layout.addLayout(content_layout)
        
        button_box: QDialogButtonBox = self._create_button_box()
        main_layout.addWidget(button_box)
        
        self.panel_list.setCurrentRow(self.PANEL_INDEX_GENERAL)
    
    def _create_content_layout(self) -> QHBoxLayout:
        """Create layout with sidebar and panel stack."""
        content_layout: QHBoxLayout = QHBoxLayout()
        
        self.panel_list: QListWidget = self._create_panel_list()
        self.panel_stack: QStackedWidget = self._create_panel_stack()
        
        content_layout.addWidget(self.panel_list)
        content_layout.addWidget(self.panel_stack, stretch=1)
        
        return content_layout
    
    def _create_panel_list(self) -> QListWidget:
        """Create left sidebar panel list."""
        panel_list: QListWidget = QListWidget()
        panel_list.setMaximumWidth(self.SIDEBAR_WIDTH)
        panel_list.addItem(self.PANEL_NAME_GENERAL)
        panel_list.addItem(self.PANEL_NAME_RELATIONSHIPS)
        panel_list.addItem(self.PANEL_NAME_EVENTS)
        panel_list.currentRowChanged.connect(self._on_panel_changed)
        
        return panel_list
    
    def _create_panel_stack(self) -> QStackedWidget:
        """Create stacked widget with all panels."""
        panel_stack: QStackedWidget = QStackedWidget()
        
        self.general_panel: GeneralPanel = GeneralPanel(self)
        self.relationships_panel: RelationshipsPanel = RelationshipsPanel(self.db_manager, self)
        self.events_panel: EventsPanel = EventsPanel(self.db_manager, self)
        
        panel_stack.addWidget(self.general_panel)
        panel_stack.addWidget(self.relationships_panel)
        panel_stack.addWidget(self.events_panel)
        
        return panel_stack
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create dialog button box with Apply, OK, and Cancel."""
        button_box: QDialogButtonBox = QDialogButtonBox()
        
        self.apply_button = button_box.addButton(
            self.BUTTON_TEXT_APPLY,
            QDialogButtonBox.ButtonRole.ApplyRole
        )
        self.apply_button.clicked.connect(self._handle_apply)
        
        self.ok_button = button_box.addButton(QDialogButtonBox.StandardButton.Ok)
        self.ok_button.clicked.connect(self._handle_ok)
        
        self.cancel_button = button_box.addButton(QDialogButtonBox.StandardButton.Cancel)
        self.cancel_button.clicked.connect(self.reject)
        
        return button_box
    
    def _on_panel_changed(self, index: int) -> None:
        """Handle panel selection change."""
        self.panel_stack.setCurrentIndex(index)
    
    # ------------------------------------------------------------------
    # Data Loading
    # ------------------------------------------------------------------
    
    def _load_data(self) -> None:
        """Load person data into all panels."""
        self.general_panel.load_person(self.person)
        self.relationships_panel.load_person(self.person)
        self.events_panel.load_person(self.person)
    
    # ------------------------------------------------------------------
    # Save Handling
    # ------------------------------------------------------------------
    
    def _handle_apply(self) -> None:
        """Save changes but keep dialog open."""
        if not self._save_changes():
            return
        
        self.has_unsaved_changes = False
        self._recapture_state_after_save()
    
    def _handle_ok(self) -> None:
        """Save changes and close dialog with confirmation."""
        if not self._save_changes():
            return
        
        self.has_unsaved_changes = False
        self._show_save_confirmation()
        self.accept()
    
    def _show_save_confirmation(self) -> None:
        """Show confirmation message that changes were saved."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Information)
        msg.setWindowTitle(self.MSG_TITLE_CHANGES_SAVED)
        msg.setText(self.MSG_TEXT_CHANGES_SAVED)
        msg.exec()
    
    def _save_changes(self) -> bool:
        """Collect and validate data from all panels, then save via command."""
        if not self._validate_all_panels():
            return False
        
        self._update_person_from_panels()
        self._execute_edit_command()
        
        return True
    
    def _validate_all_panels(self) -> bool:
        """Validate all panels and show error if validation fails."""
        if not self._validate_general_panel():
            return False
        
        if not self._validate_relationships_panel():
            return False
        
        return True
    
    def _validate_general_panel(self) -> bool:
        """Validate general panel."""
        is_valid, error_msg = self.general_panel.validate()
        
        if not is_valid:
            self._show_validation_error(error_msg)
            return False
        
        return True
    
    def _validate_relationships_panel(self) -> bool:
        """Validate relationships panel."""
        is_valid, error_msg = self.relationships_panel.validate()
        
        if not is_valid:
            self._show_validation_error(error_msg)
            self.panel_list.setCurrentRow(self.PANEL_INDEX_RELATIONSHIPS)
            return False
        
        return True
    
    def _show_validation_error(self, error_msg: str) -> None:
        """Show validation error message."""
        QMessageBox.warning(self, self.MSG_TITLE_VALIDATION_ERROR, error_msg)
    
    def _update_person_from_panels(self) -> None:
        """Update person object from panel data."""
        person_data: dict = self.general_panel.get_person_data()
        relationship_data: dict = self.relationships_panel.get_relationship_data()
        
        self.person.first_name = person_data.get('first_name', self.person.first_name)
        self.person.middle_name = person_data.get('middle_name', self.person.middle_name)
        self.person.last_name = person_data.get('last_name', self.person.last_name)
        self.person.birth_year = person_data.get('birth_year', self.person.birth_year)
        self.person.birth_month = person_data.get('birth_month', self.person.birth_month)
        self.person.death_year = person_data.get('death_year', self.person.death_year)
        self.person.death_month = person_data.get('death_month', self.person.death_month)
        self.person.arrival_year = person_data.get('arrival_year', self.person.arrival_year)
        self.person.arrival_month = person_data.get('arrival_month', self.person.arrival_month)
        self.person.moved_out_year = person_data.get('moved_out_year', self.person.moved_out_year)
        self.person.moved_out_month = person_data.get('moved_out_month', self.person.moved_out_month)
        self.person.gender = person_data.get('gender', self.person.gender)
        self.person.education = person_data.get('education_level', self.person.education)
        self.person.dynasty_id = person_data.get('dynasty_id', self.person.dynasty_id)
        self.person.notes = person_data.get('notes', self.person.notes)
        
        self.person.father_id = relationship_data.get('father_id', self.person.father_id)
        self.person.mother_id = relationship_data.get('mother_id', self.person.mother_id)
    
    def _execute_edit_command(self) -> None:
        """Create and execute edit person command through undo manager."""
        command: EditPersonCommand = EditPersonCommand(
            db_manager=self.db_manager,
            person=self.person,
            original_person_data=self.original_person_data,
            new_marriages=self.relationships_panel.new_marriages,
            modified_marriages=self.relationships_panel.modified_marriages,
            deleted_marriage_ids=self.relationships_panel.deleted_marriage_ids,
            new_events=self.events_panel.new_events,
            modified_events=self.events_panel.modified_events,
            deleted_event_ids=self.events_panel.deleted_event_ids,
            original_marriages=self.original_marriages,
            original_events=self.original_events
        )
        
        self._execute_command_through_undo_manager(command)
    
    def _execute_command_through_undo_manager(self, command: EditPersonCommand) -> None:
        """Execute command and update UI state."""
        main_window = self._find_main_window()
        
        if not main_window:
            return
        
        main_window.undo_manager.execute(command)
        main_window.db.mark_dirty()
        main_window.refresh_ui()
        main_window.edit_actions.update_undo_redo_actions()
    
    def _find_main_window(self):
        """Find the main window for accessing undo manager."""
        parent = self.parent()
        
        while parent:
            from main import MainWindow
            if isinstance(parent, MainWindow):
                return parent
            parent = parent.parent()
        
        return None
    
    def _recapture_state_after_save(self) -> None:
        """Recapture original state after Apply (for next save)."""
        self.original_person_data = self._capture_person_state()
        self.original_marriages = self._capture_marriages_state()
        self.original_events = self._capture_events_state()
        
        self.relationships_panel.new_marriages.clear()
        self.relationships_panel.modified_marriages.clear()
        self.relationships_panel.deleted_marriage_ids.clear()
        
        self.events_panel.new_events.clear()
        self.events_panel.modified_events.clear()
        self.events_panel.deleted_event_ids.clear()
    
    # ------------------------------------------------------------------
    # Dialog Close Handling
    # ------------------------------------------------------------------
    
    def reject(self) -> None:
        """Handle Cancel button with unsaved changes warning."""
        if self.has_unsaved_changes:
            if not self._confirm_discard_changes():
                return
        
        super().reject()
    
    def _confirm_discard_changes(self) -> bool:
        """Show confirmation dialog for discarding unsaved changes."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_TITLE_UNSAVED_CHANGES)
        msg.setText(self.MSG_TEXT_UNSAVED_CHANGES)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Discard |
            QMessageBox.StandardButton.Cancel
        )
        
        return msg.exec() == QMessageBox.StandardButton.Discard
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def mark_dirty(self) -> None:
        """Mark the dialog as having unsaved changes."""
        self.has_unsaved_changes = True

>> ðŸ“‹ dialogs\edit_person_panels\__init__.py (2 code lines)
from .general_panel import GeneralPanel

__all__ = ['GeneralPanel', ]

>> âœ… dialogs\edit_person_panels\event_panel.py (116 code lines)
"""Events panel for Edit Person dialog."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QScrollArea, QGroupBox,
    QPushButton, QLabel, QFrame, QHBoxLayout, QMessageBox
)

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person
    from models.event import Event

from database.event_repository import EventRepository


class EventsPanel(QWidget):
    """Panel for viewing and managing person's life events."""
    
    LABEL_SECTION_TITLE: str = "Life Events Timeline"
    LABEL_NO_EVENTS: str = "No events recorded"
    LABEL_ONGOING_BADGE: str = "â— Ongoing"
    
    BUTTON_TEXT_ADD_EVENT: str = "+ Add Event"
    BUTTON_TEXT_EDIT: str = "Edit"
    BUTTON_TEXT_DELETE: str = "Delete"
    
    MSG_TITLE_DELETE_EVENT: str = "Delete Event"
    MSG_TEXT_DELETE_EVENT: str = "Are you sure you want to delete this event?\n\n{title}"
    
    STYLE_TYPE_BADGE: str = "font-weight: bold; color: #2196F3;"
    STYLE_TITLE: str = "font-size: 14px; font-weight: bold;"
    STYLE_ONGOING_BADGE: str = "color: green; font-weight: bold;"
    STYLE_DATE: str = "color: gray; font-style: italic;"
    STYLE_NOTES: str = "margin-top: 5px; padding: 5px; background-color: #f5f5f5;"
    STYLE_PLACEHOLDER: str = "color: gray; font-style: italic; padding: 10px;"
    
    EVENT_TYPE_BADGE_FORMAT: str = "[{type}]"
    
    SORT_YEAR_UNKNOWN: int = 9999
    SORT_MONTH_UNKNOWN: int = 12
    SORT_DAY_UNKNOWN: int = 31
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize events panel with database manager."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.event_repo: EventRepository = EventRepository(db_manager)
        self.current_person: Person | None = None
        
        self.event_widgets: list[tuple[Event, QFrame]] = []
        self.new_events: list[Event] = []
        self.deleted_event_ids: list[int] = []
        self.modified_events: dict[int, Event] = {}
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create the events timeline layout."""
        scroll: QScrollArea = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container: QWidget = QWidget()
        layout: QVBoxLayout = QVBoxLayout(container)
        
        events_group: QGroupBox = self._create_events_section()
        layout.addWidget(events_group)
        layout.addStretch()
        
        scroll.setWidget(container)
        
        main_layout: QVBoxLayout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll)
    
    def _create_events_section(self) -> QGroupBox:
        """Create events timeline section with add button."""
        events_group: QGroupBox = QGroupBox(self.LABEL_SECTION_TITLE)
        events_layout: QVBoxLayout = QVBoxLayout(events_group)
        
        self.events_container: QVBoxLayout = QVBoxLayout()
        events_layout.addLayout(self.events_container)
        
        add_btn: QPushButton = QPushButton(self.BUTTON_TEXT_ADD_EVENT)
        add_btn.clicked.connect(self._add_event)
        events_layout.addWidget(add_btn)
        
        return events_group
    
    def _create_event_widget(self, event: Event) -> QFrame:
        """Create a widget displaying an event in timeline format."""
        frame: QFrame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        frame.setFrameShadow(QFrame.Shadow.Raised)
        main_layout: QVBoxLayout = QVBoxLayout(frame)
        
        header_layout: QHBoxLayout = self._create_event_header(event)
        main_layout.addLayout(header_layout)
        
        date_label: QLabel = self._create_date_label(event)
        main_layout.addWidget(date_label)
        
        if event.notes:
            notes_label: QLabel = self._create_notes_label(event)
            main_layout.addWidget(notes_label)
        
        button_layout: QHBoxLayout = self._create_event_buttons(event)
        main_layout.addLayout(button_layout)
        
        return frame
    
    def _create_event_header(self, event: Event) -> QHBoxLayout:
        """Create event header with type badge, title, and ongoing indicator."""
        header_layout: QHBoxLayout = QHBoxLayout()
        
        type_label: QLabel = QLabel(self.EVENT_TYPE_BADGE_FORMAT.format(type=event.event_type))
        type_label.setStyleSheet(self.STYLE_TYPE_BADGE)
        header_layout.addWidget(type_label)
        
        title_label: QLabel = QLabel(event.event_title)
        title_label.setStyleSheet(self.STYLE_TITLE)
        header_layout.addWidget(title_label)
        
        header_layout.addStretch()
        
        if event.is_ongoing:
            ongoing_label: QLabel = QLabel(self.LABEL_ONGOING_BADGE)
            ongoing_label.setStyleSheet(self.STYLE_ONGOING_BADGE)
            header_layout.addWidget(ongoing_label)
        
        return header_layout
    
    def _create_date_label(self, event: Event) -> QLabel:
        """Create date range label for event."""
        date_label: QLabel = QLabel(event.date_range_string)
        date_label.setStyleSheet(self.STYLE_DATE)
        return date_label
    
    def _create_notes_label(self, event: Event) -> QLabel:
        """Create notes label for event."""
        notes_label: QLabel = QLabel(event.notes)
        notes_label.setWordWrap(True)
        notes_label.setStyleSheet(self.STYLE_NOTES)
        return notes_label
    
    def _create_event_buttons(self, event: Event) -> QHBoxLayout:
        """Create action buttons for event."""
        button_layout: QHBoxLayout = QHBoxLayout()
        button_layout.addStretch()
        
        edit_btn: QPushButton = QPushButton(self.BUTTON_TEXT_EDIT)
        edit_btn.clicked.connect(lambda: self._edit_event(event))
        button_layout.addWidget(edit_btn)
        
        delete_btn: QPushButton = QPushButton(self.BUTTON_TEXT_DELETE)
        delete_btn.clicked.connect(lambda: self._delete_event(event))
        button_layout.addWidget(delete_btn)
        
        return button_layout
    
    def _add_event(self) -> None:
        """Open dialog to add a new event."""
        if not self.current_person:
            return
        
        from dialogs.create_event_dialog import CreateEventDialog
        
        dialog: CreateEventDialog = CreateEventDialog(self.db_manager, self.current_person, self)
        
        if not dialog.exec():
            return
        
        created_event: Event | None = dialog.get_created_event()
        if not created_event:
            return
        
        self.new_events.append(created_event)
        self._load_events()
        self._mark_dirty()

    def _edit_event(self, event: Event) -> None:
        """Open dialog to edit an event."""
        from dialogs.edit_event_dialog import EditEventDialog
        
        dialog: EditEventDialog = EditEventDialog(self.db_manager, event, self)
        
        if not dialog.exec():
            return
        
        edited_event: Event | None = dialog.get_edited_event()
        if not edited_event:
            return
        
        self._update_event_in_place(event, edited_event)
        self._load_events()
        self._mark_dirty()
    
    def _update_event_in_place(self, event: Event, edited_event: Event) -> None:
        """Update event attributes from edited event."""
        event.event_type = edited_event.event_type
        event.event_title = edited_event.event_title
        event.start_year = edited_event.start_year
        event.start_month = edited_event.start_month
        event.start_day = edited_event.start_day
        event.end_year = edited_event.end_year
        event.end_month = edited_event.end_month
        event.end_day = edited_event.end_day
        event.notes = edited_event.notes
    
    def _delete_event(self, event: Event) -> None:
        """Delete an event after confirmation."""
        if not self._confirm_delete_event(event):
            return
        
        if event.id:
            self.deleted_event_ids.append(event.id)
        
        if event in self.new_events:
            self.new_events.remove(event)
        
        self.event_widgets = [(e, w) for e, w in self.event_widgets if e != event]
        self._load_events()
        self._mark_dirty()
    
    def _confirm_delete_event(self, event: Event) -> bool:
        """Show confirmation dialog for deleting event."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_TITLE_DELETE_EVENT)
        msg.setText(self.MSG_TEXT_DELETE_EVENT.format(title=event.event_title))
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        return msg.exec() == QMessageBox.StandardButton.Yes
    
    def load_person(self, person: Person) -> None:
        """Load person's events."""
        self.current_person = person
        
        self.new_events.clear()
        self.deleted_event_ids.clear()
        
        self._load_events()
    
    def _load_events(self) -> None:
        """Load and display events in timeline order."""
        self._clear_events_container()
        self.event_widgets.clear()
        
        if not self._has_valid_person():
            self._show_placeholder()
            return
        
        all_events: list[Event] = self._get_all_events()
        
        if all_events:
            self._display_events(all_events)
        else:
            self._show_placeholder()
    
    def _clear_events_container(self) -> None:
        """Clear all widgets from events container."""
        while self.events_container.count():
            item = self.events_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
    
    def _has_valid_person(self) -> bool:
        """Check if current person is valid and has an ID."""
        return self.current_person is not None and self.current_person.id is not None
    
    def _show_placeholder(self) -> None:
        """Show placeholder text when no events exist."""
        placeholder: QLabel = QLabel(self.LABEL_NO_EVENTS)
        placeholder.setStyleSheet(self.STYLE_PLACEHOLDER)
        self.events_container.addWidget(placeholder)
    
    def _get_all_events(self) -> list[Event]:
        """Get all events (database + new - deleted), sorted chronologically."""
        if not self.current_person or self.current_person.id is None:
            return []
        
        events: list[Event] = self.event_repo.get_by_person(self.current_person.id)
        events = [e for e in events if e.id not in self.deleted_event_ids]
        
        all_events: list[Event] = events + self.new_events
        all_events.sort(key=self._get_event_sort_key)
        
        return all_events
    
    def _get_event_sort_key(self, event: Event) -> tuple[int, int, int]:
        """Get sort key for event based on start date."""
        if event.start_year is None:
            return (self.SORT_YEAR_UNKNOWN, self.SORT_MONTH_UNKNOWN, self.SORT_DAY_UNKNOWN)
        
        return (
            event.start_year,
            event.start_month or 0,
            event.start_day or 0
        )
    
    def _display_events(self, events: list[Event]) -> None:
        """Display all events in the container."""
        for event in events:
            widget: QFrame = self._create_event_widget(event)
            self.events_container.addWidget(widget)
            self.event_widgets.append((event, widget))
    
    def save_events(self) -> None:
        """Save all event changes to database."""
        for event_id in self.deleted_event_ids:
            self.event_repo.delete(event_id)
        
        for event in self.new_events:
            self.event_repo.insert(event)
        
        self.new_events.clear()
        self.deleted_event_ids.clear()
    
    def validate(self) -> tuple[bool, str]:
        """Validate event data."""
        return (True, "")
    
    def _mark_dirty(self) -> None:
        """Mark parent dialog as having unsaved changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None

>> âœ… dialogs\edit_person_panels\general_panel.py (162 code lines)
"""General information panel for Edit Person dialog."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QLineEdit,
    QComboBox, QTextEdit, QLabel, QScrollArea, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

if TYPE_CHECKING:
    from models.person import Person

from widgets.date_picker import DatePicker


class GeneralPanel(QWidget):
    """Panel for editing general person information."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Labels
    LABEL_FIRST_NAME: str = "First Name: *"
    LABEL_MIDDLE_NAME: str = "Middle Name:"
    LABEL_LAST_NAME: str = "Last Name: *"
    LABEL_MAIDEN_NAME: str = "Maiden Name:"
    LABEL_NICKNAME: str = "Nickname:"
    LABEL_GENDER: str = "Gender:"
    LABEL_BIRTH_DATE: str = "Birth Date:"
    LABEL_DEATH_DATE: str = "Death Date:"
    LABEL_ARRIVAL_DATE: str = "Arrival Date:"
    LABEL_MOVED_OUT_DATE: str = "Moved Out Date:"
    LABEL_DYNASTY_ID: str = "Dynasty ID:"
    LABEL_EDUCATION: str = "Education:"
    LABEL_NOTES: str = "Notes:"
    LABEL_EMPTY: str = ""
    
    # Placeholders
    PLACEHOLDER_REQUIRED: str = "Required"
    PLACEHOLDER_OPTIONAL: str = "Optional"
    PLACEHOLDER_NOTES: str = "Optional notes about this person..."
    
    # Checkboxes
    CHECKBOX_DIED: str = "Died?"
    CHECKBOX_IMMIGRANT: str = "Immigrant?"
    CHECKBOX_MOVED_OUT: str = "Moved Out?"
    CHECKBOX_IS_FOUNDER: str = "Is Dynasty Founder"
    
    # Gender Options
    GENDER_UNKNOWN: str = "Unknown"
    GENDER_MALE: str = "Male"
    GENDER_FEMALE: str = "Female"
    GENDER_OTHER: str = "Other"
    
    # Education Levels
    EDUCATION_LEVEL_0: str = "0 - Uneducated"
    EDUCATION_LEVEL_1: str = "1 - Basic"
    EDUCATION_LEVEL_2: str = "2 - Elementary"
    EDUCATION_LEVEL_3: str = "3 - Advanced"
    EDUCATION_LEVEL_4: str = "4 - Expert"
    EDUCATION_LEVEL_5: str = "5 - Master"
    
    # Default Values
    DEFAULT_DYNASTY_ID: str = "1"
    NOTES_MAX_HEIGHT: int = 120
    
    # Validation Messages
    VALIDATION_ERROR_FIRST_NAME: str = "First name is required."
    VALIDATION_ERROR_LAST_NAME: str = "Last name is required."
    VALIDATION_ERROR_DYNASTY_ID_POSITIVE: str = "Dynasty ID must be a positive number."
    VALIDATION_ERROR_DYNASTY_ID_INVALID: str = "Dynasty ID must be a valid number."
    
    # Parsing Constants
    EDUCATION_TEXT_SEPARATOR: str = " "
    EDUCATION_LEVEL_INDEX: int = 0
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize general panel."""
        super().__init__(parent)
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create all form fields."""
        scroll: QScrollArea = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container: QWidget = QWidget()
        form: QFormLayout = QFormLayout(container)
        
        self._create_name_fields(form)
        self._create_gender_field(form)
        self._create_date_fields(form)
        self._create_game_fields(form)
        self._create_notes_field(form)
        
        scroll.setWidget(container)
        
        layout: QVBoxLayout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(scroll)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()
        self._update_birth_month_visibility()
    
    def _create_name_fields(self, form: QFormLayout) -> None:
        """Create name input fields."""
        self.first_name_input: QLineEdit = QLineEdit()
        self.first_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        self.first_name_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_FIRST_NAME, self.first_name_input)
        
        self.middle_name_input: QLineEdit = QLineEdit()
        self.middle_name_input.setPlaceholderText(self.PLACEHOLDER_OPTIONAL)
        self.middle_name_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_MIDDLE_NAME, self.middle_name_input)
        
        self.last_name_input: QLineEdit = QLineEdit()
        self.last_name_input.setPlaceholderText(self.PLACEHOLDER_REQUIRED)
        self.last_name_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_LAST_NAME, self.last_name_input)
        
        self.maiden_name_input: QLineEdit = QLineEdit()
        self.maiden_name_input.setPlaceholderText(self.PLACEHOLDER_OPTIONAL)
        self.maiden_name_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_MAIDEN_NAME, self.maiden_name_input)
        
        self.nickname_input: QLineEdit = QLineEdit()
        self.nickname_input.setPlaceholderText(self.PLACEHOLDER_OPTIONAL)
        self.nickname_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_NICKNAME, self.nickname_input)
    
    def _create_gender_field(self, form: QFormLayout) -> None:
        """Create gender selection field."""
        self.gender_input: QComboBox = QComboBox()
        self.gender_input.addItems([
            self.GENDER_UNKNOWN,
            self.GENDER_MALE,
            self.GENDER_FEMALE,
            self.GENDER_OTHER
        ])
        self.gender_input.currentIndexChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_GENDER, self.gender_input)
    
    def _create_date_fields(self, form: QFormLayout) -> None:
        """Create date input fields with checkboxes."""
        self.birth_date_picker: DatePicker = DatePicker()
        self.birth_date_picker.dateChanged.connect(self._mark_dirty)
        self.birth_date_picker.unknown_check.setVisible(False)
        form.addRow(self.LABEL_BIRTH_DATE, self.birth_date_picker)
        
        self._create_death_date_field(form)
        self._create_arrival_date_field(form)
        self._create_moved_out_date_field(form)
    
    def _create_death_date_field(self, form: QFormLayout) -> None:
        """Create death date field with checkbox."""
        self.death_date_label: QLabel = QLabel(self.LABEL_DEATH_DATE)
        self.death_date_picker: DatePicker = DatePicker()
        self.death_date_picker.dateChanged.connect(self._mark_dirty)
        form.addRow(self.death_date_label, self.death_date_picker)
        
        self.died_check: QCheckBox = QCheckBox(self.CHECKBOX_DIED)
        self.died_check.setChecked(False)
        self.died_check.stateChanged.connect(self._on_died_toggled)
        self.died_check.stateChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_EMPTY, self.died_check)
    
    def _create_arrival_date_field(self, form: QFormLayout) -> None:
        """Create arrival date field with checkbox."""
        self.arrival_date_label: QLabel = QLabel(self.LABEL_ARRIVAL_DATE)
        self.arrival_date_picker: DatePicker = DatePicker()
        self.arrival_date_picker.dateChanged.connect(self._mark_dirty)
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
        
        self.immigrant_check: QCheckBox = QCheckBox(self.CHECKBOX_IMMIGRANT)
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        self.immigrant_check.stateChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_EMPTY, self.immigrant_check)
    
    def _create_moved_out_date_field(self, form: QFormLayout) -> None:
        """Create moved out date field with checkbox."""
        self.moved_out_date_label: QLabel = QLabel(self.LABEL_MOVED_OUT_DATE)
        self.moved_out_date_picker: DatePicker = DatePicker()
        self.moved_out_date_picker.dateChanged.connect(self._mark_dirty)
        form.addRow(self.moved_out_date_label, self.moved_out_date_picker)
        
        self.moved_out_check: QCheckBox = QCheckBox(self.CHECKBOX_MOVED_OUT)
        self.moved_out_check.setChecked(False)
        self.moved_out_check.stateChanged.connect(self._on_moved_out_toggled)
        self.moved_out_check.stateChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_EMPTY, self.moved_out_check)
    
    def _create_game_fields(self, form: QFormLayout) -> None:
        """Create game-specific fields."""
        self.dynasty_id_input: QLineEdit = QLineEdit()
        self.dynasty_id_input.setText(self.DEFAULT_DYNASTY_ID)
        self.dynasty_id_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_DYNASTY_ID, self.dynasty_id_input)
        
        self.is_founder_check: QCheckBox = QCheckBox(self.CHECKBOX_IS_FOUNDER)
        self.is_founder_check.stateChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_EMPTY, self.is_founder_check)
        
        self.education_input: QComboBox = QComboBox()
        self.education_input.addItems([
            self.EDUCATION_LEVEL_0,
            self.EDUCATION_LEVEL_1,
            self.EDUCATION_LEVEL_2,
            self.EDUCATION_LEVEL_3,
            self.EDUCATION_LEVEL_4,
            self.EDUCATION_LEVEL_5
        ])
        self.education_input.currentIndexChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_EDUCATION, self.education_input)
    
    def _create_notes_field(self, form: QFormLayout) -> None:
        """Create notes text field."""
        self.notes_input: QTextEdit = QTextEdit()
        self.notes_input.setPlaceholderText(self.PLACEHOLDER_NOTES)
        self.notes_input.setMaximumHeight(self.NOTES_MAX_HEIGHT)
        self.notes_input.textChanged.connect(self._mark_dirty)
        form.addRow(self.LABEL_NOTES, self.notes_input)
    
    # ------------------------------------------------------------------
    # Visibility Control
    # ------------------------------------------------------------------
    
    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_visibility()
        self._update_birth_month_visibility()
    
    def _update_immigrant_visibility(self) -> None:
        """Show or hide arrival date based on checkbox."""
        is_immigrant: bool = self.immigrant_check.isChecked()
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)

    def _update_birth_month_visibility(self) -> None:
        """Enable or disable birth month based on immigrant status."""
        is_immigrant: bool = self.immigrant_check.isChecked()
        
        if is_immigrant:
            self.birth_date_picker.month_spin.setEnabled(False)
            self.birth_date_picker.month_spin.setValue(1)
            self.birth_date_picker.unknown_check.setChecked(True)
        else:
            self.birth_date_picker.month_spin.setEnabled(True)
            self.birth_date_picker.unknown_check.setChecked(False)
    
    def _on_died_toggled(self) -> None:
        """Handle died checkbox toggle."""
        self._update_died_visibility()
    
    def _update_died_visibility(self) -> None:
        """Show or hide death date based on checkbox."""
        has_died: bool = self.died_check.isChecked()
        self.death_date_label.setVisible(has_died)
        self.death_date_picker.setVisible(has_died)
    
    def _on_moved_out_toggled(self) -> None:
        """Handle moved out checkbox toggle."""
        self._update_moved_out_visibility()
    
    def _update_moved_out_visibility(self) -> None:
        """Show or hide moved out date based on checkbox."""
        is_moved_out: bool = self.moved_out_check.isChecked()
        self.moved_out_date_label.setVisible(is_moved_out)
        self.moved_out_date_picker.setVisible(is_moved_out)
    
    # ------------------------------------------------------------------
    # Parent Dialog Communication
    # ------------------------------------------------------------------
    
    def _mark_dirty(self) -> None:
        """Mark parent dialog as having unsaved changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    # ------------------------------------------------------------------
    # Data Loading
    # ------------------------------------------------------------------
    
    def load_person(self, person: Person) -> None:
        """Load person data into form fields."""
        blockers: list[QSignalBlocker] = self._create_signal_blockers()
        
        self._load_name_fields(person)
        self._load_gender_field(person)
        self._load_date_fields(person)
        self._load_game_fields(person)
        self._load_notes_field(person)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()
        self._update_birth_month_visibility()
    
    def _create_signal_blockers(self) -> list[QSignalBlocker]:
        """Create signal blockers for all input widgets."""
        return [
            QSignalBlocker(self.first_name_input),
            QSignalBlocker(self.middle_name_input),
            QSignalBlocker(self.last_name_input),
            QSignalBlocker(self.maiden_name_input),
            QSignalBlocker(self.nickname_input),
            QSignalBlocker(self.gender_input),
            QSignalBlocker(self.birth_date_picker),
            QSignalBlocker(self.died_check),
            QSignalBlocker(self.death_date_picker),
            QSignalBlocker(self.immigrant_check),
            QSignalBlocker(self.arrival_date_picker),
            QSignalBlocker(self.moved_out_check),
            QSignalBlocker(self.moved_out_date_picker),
            QSignalBlocker(self.dynasty_id_input),
            QSignalBlocker(self.is_founder_check),
            QSignalBlocker(self.education_input),
            QSignalBlocker(self.notes_input),
        ]
    
    def _load_name_fields(self, person: Person) -> None:
        """Load name field values from person."""
        self.first_name_input.setText(person.first_name or "")
        self.middle_name_input.setText(person.middle_name or "")
        self.last_name_input.setText(person.last_name or "")
        self.maiden_name_input.setText(person.maiden_name or "")
        self.nickname_input.setText(person.nickname or "")
    
    def _load_gender_field(self, person: Person) -> None:
        """Load gender field value from person."""
        if not person.gender:
            return
        
        index: int = self.gender_input.findText(person.gender)
        if index >= 0:
            self.gender_input.setCurrentIndex(index)
    
    def _load_date_fields(self, person: Person) -> None:
        """Load date field values from person."""
        if person.birth_year:
            self.birth_date_picker.set_date(person.birth_year, person.birth_month)
        
        if person.death_year:
            self.died_check.setChecked(True)
            self.death_date_picker.set_date(person.death_year, person.death_month)
        else:
            self.died_check.setChecked(False)
        
        if person.arrival_year:
            self.immigrant_check.setChecked(True)
            self.arrival_date_picker.set_date(person.arrival_year, person.arrival_month)
            self.arrival_date_picker.unknown_check.setVisible(False)
        else:
            self.immigrant_check.setChecked(False)
        
        if person.moved_out_year:
            self.moved_out_check.setChecked(True)
            self.moved_out_date_picker.set_date(person.moved_out_year, person.moved_out_month)
        else:
            self.moved_out_check.setChecked(False)
    
    def _load_game_fields(self, person: Person) -> None:
        """Load game-specific field values from person."""
        self.dynasty_id_input.setText(str(person.dynasty_id))
        self.is_founder_check.setChecked(person.is_founder)
        self.education_input.setCurrentIndex(person.education)
    
    def _load_notes_field(self, person: Person) -> None:
        """Load notes field value from person."""
        self.notes_input.setPlainText(person.notes or "")
    
    # ------------------------------------------------------------------
    # Data Extraction
    # ------------------------------------------------------------------
    
    def get_person_data(self) -> dict:
        """Extract form data as dictionary."""
        birth_year, birth_month = self.birth_date_picker.get_date()
        
        death_year, death_month = self._get_death_date()
        arrival_year, arrival_month = self._get_arrival_date()
        moved_out_year, moved_out_month = self._get_moved_out_date()
        
        education_level: int = self._parse_education_level()
        
        return {
            'first_name': self.first_name_input.text().strip(),
            'middle_name': self.middle_name_input.text().strip(),
            'last_name': self.last_name_input.text().strip(),
            'maiden_name': self.maiden_name_input.text().strip(),
            'nickname': self.nickname_input.text().strip(),
            'gender': self.gender_input.currentText(),
            'birth_year': birth_year,
            'birth_month': birth_month,
            'death_year': death_year,
            'death_month': death_month,
            'arrival_year': arrival_year,
            'arrival_month': arrival_month,
            'moved_out_year': moved_out_year,
            'moved_out_month': moved_out_month,
            'dynasty_id': int(self.dynasty_id_input.text() or self.DEFAULT_DYNASTY_ID),
            'is_founder': self.is_founder_check.isChecked(),
            'education': education_level,
            'notes': self.notes_input.toPlainText().strip()
        }
    
    def _get_death_date(self) -> tuple[int | None, int | None]:
        """Get death date from picker if died checkbox is checked."""
        if self.died_check.isChecked():
            return self.death_date_picker.get_date()
        return None, None
    
    def _get_arrival_date(self) -> tuple[int | None, int | None]:
        """Get arrival date from picker if immigrant checkbox is checked."""
        if self.immigrant_check.isChecked():
            return self.arrival_date_picker.get_date()
        return None, None
    
    def _get_moved_out_date(self) -> tuple[int | None, int | None]:
        """Get moved out date from picker if moved out checkbox is checked."""
        if self.moved_out_check.isChecked():
            return self.moved_out_date_picker.get_date()
        return None, None
    
    def _parse_education_level(self) -> int:
        """Parse education level from combo box text."""
        education_text: str = self.education_input.currentText()
        return int(education_text.split(self.EDUCATION_TEXT_SEPARATOR)[self.EDUCATION_LEVEL_INDEX])
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def validate(self) -> tuple[bool, str]:
        """Validate form data."""
        if not self.first_name_input.text().strip():
            return (False, self.VALIDATION_ERROR_FIRST_NAME)
        
        if not self.last_name_input.text().strip():
            return (False, self.VALIDATION_ERROR_LAST_NAME)
        
        dynasty_id_valid, dynasty_error = self._validate_dynasty_id()
        if not dynasty_id_valid:
            return (False, dynasty_error)
        
        return (True, "")
    
    def _validate_dynasty_id(self) -> tuple[bool, str]:
        """Validate dynasty ID is a positive integer."""
        try:
            dynasty_id: int = int(self.dynasty_id_input.text())
            if dynasty_id < 1:
                return (False, self.VALIDATION_ERROR_DYNASTY_ID_POSITIVE)
        except ValueError:
            return (False, self.VALIDATION_ERROR_DYNASTY_ID_INVALID)
        
        return (True, "")

>> âœ… dialogs\edit_person_panels\relationships_panel.py (453 code lines)
"""Relationships panel for Edit Person dialog."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, 
    QLabel, QScrollArea, QCheckBox,
    QGroupBox, QPushButton, QHBoxLayout, 
    QFrame, QMessageBox, QComboBox,
    QDialog
)
from PySide6.QtCore import QSignalBlocker

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from database.person_repository import PersonRepository
from database.marriage_repository import MarriageRepository
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker
from dialogs.create_marriage_dialog import CreateMarriageDialog
from dialogs.end_marriage_dialog import EndMarriageDialog
from models.marriage import Marriage


class RelationshipsPanel(QWidget):
    """Panel for editing person relationships."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Section Labels
    LABEL_PARENTS: str = "Parents"
    LABEL_FATHER: str = "Father:"
    LABEL_MOTHER: str = "Mother:"
    LABEL_SIBLINGS: str = "<b>Siblings:</b>"
    LABEL_MARRIAGES: str = "Marriages"
    LABEL_CHILDREN: str = "Children"
    LABEL_SPOUSE: str = "Spouse:"
    LABEL_MARRIED: str = "Married:"
    LABEL_ENDED: str = "Ended:"
    LABEL_REASON: str = "Reason:"
    LABEL_EMPTY: str = ""
    
    # Button Text
    BUTTON_TEXT_VIEW_PERSON: str = "View Person"
    BUTTON_TEXT_ADD_MARRIAGE: str = "+ Add New Marriage"
    BUTTON_TEXT_ADD_CHILD: str = "+ Add Child"
    BUTTON_TEXT_END_MARRIAGE: str = "End Marriage"
    BUTTON_TEXT_REACTIVATE: str = "Reactivate"
    BUTTON_TEXT_DELETE: str = "Delete"
    BUTTON_TEXT_REMOVE: str = "Remove"
    
    # Checkbox Text
    CHECKBOX_DATE_UNKNOWN: str = "Date Unknown"
    
    # Status Indicators
    STATUS_ACTIVE: str = "âœ“ Active"
    STATUS_ENDED: str = "â—‹ Ended"
    
    # Placeholder Text
    PLACEHOLDER_NO_SIBLINGS: str = "No siblings found"
    PLACEHOLDER_NO_MARRIAGES: str = "No marriages recorded"
    PLACEHOLDER_NO_CHILDREN: str = "No children recorded"
    
    # Message Box Titles
    MSG_TITLE_SAVE_CHANGES: str = "Save Changes?"
    MSG_TITLE_ACTIVE_MARRIAGE: str = "Active Marriage"
    MSG_TITLE_END_CURRENT_MARRIAGE: str = "End Current Marriage?"
    MSG_TITLE_INCOMPLETE_MARRIAGE: str = "Incomplete Marriage"
    MSG_TITLE_INVALID_DATE: str = "Invalid Date"
    MSG_TITLE_REACTIVATE_MARRIAGE: str = "Reactivate Marriage?"
    MSG_TITLE_DELETE_MARRIAGE: str = "Delete Marriage"
    MSG_TITLE_REMOVE_CHILD: str = "Remove Child"
    
    # Message Box Text
    MSG_TEXT_SAVE_BEFORE_JUMP: str = "Save changes before jumping to another person?"
    MSG_TEXT_ACTIVE_MARRIAGE_PROMPT: str = "This person has an active marriage. End it before creating a new one?"
    MSG_TEXT_END_BEFORE_NEW: str = "This person has an active marriage. End it before creating a new one?"
    MSG_TEXT_INCOMPLETE_MARRIAGE: str = "Please select a spouse for the current marriage before adding a new one."
    MSG_TEXT_INVALID_END_DATE: str = "Marriage cannot end before it started."
    MSG_TEXT_REACTIVATE_MARRIAGE: str = "Remove the end date and reactivate this marriage? This will remove any empty active marriages."
    MSG_TEXT_DELETE_MARRIAGE: str = "Are you sure you want to delete this marriage?"
    MSG_TEXT_REMOVE_CHILD_FORMAT: str = "Remove {child_name} as a child of {parent_name}?"
    MSG_TEXT_REMOVE_CHILD_INFO: str = "This will clear the parent relationship but not delete the person."
    
    # Birth Info Format
    BIRTH_INFO_FORMAT: str = "b. {year}"
    BIRTH_INFO_UNKNOWN: str = "birth unknown"
    
    # Person Display Format
    PERSON_DISPLAY_FORMAT: str = "{name} ({birth})"
    
    # Dissolution Reasons
    REASON_DEATH: str = "Death"
    REASON_DIVORCE: str = "Divorce"
    REASON_ANNULMENT: str = "Annulment"
    REASON_OTHER: str = "Other"
    REASON_UNKNOWN: str = "Unknown"
    
    # Styles
    STYLE_PLACEHOLDER: str = "color: gray; font-style: italic; padding: 10px;"
    STYLE_ACTIVE_STATUS: str = "font-weight: bold; color: green"
    STYLE_ENDED_STATUS: str = "font-weight: bold; color: gray"
    
    # Sorting
    SORT_YEAR_UNKNOWN: int = 9999
    SORT_MONTH_UNKNOWN: int = 12
    
    # Layout
    INDENT_SPACING: int = 60
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize relationships panel with database manager."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person_repo: PersonRepository = PersonRepository(db_manager)
        self.marriage_repo: MarriageRepository = MarriageRepository(db_manager)
        self.current_person: Person | None = None
        
        self.marriage_widgets: list[tuple[Marriage, QFrame]] = []
        self.new_marriages: list[Marriage] = []
        self.deleted_marriage_ids: list[int] = []
        self.modified_marriages: dict[int, Marriage] = {}
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create all relationship sections."""
        scroll: QScrollArea = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container: QWidget = QWidget()
        layout: QVBoxLayout = QVBoxLayout(container)
        
        layout.addWidget(self._create_parents_section())
        layout.addWidget(self._create_marriages_section())
        layout.addWidget(self._create_children_section())
        layout.addStretch()
        
        scroll.setWidget(container)
        
        main_layout: QVBoxLayout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll)
    
    def _create_parents_section(self) -> QGroupBox:
        """Create parents section with father/mother selectors."""
        group: QGroupBox = QGroupBox(self.LABEL_PARENTS)
        layout: QVBoxLayout = QVBoxLayout(group)
        form: QFormLayout = QFormLayout()
        
        self._create_father_row(form)
        self._create_mother_row(form)
        
        layout.addLayout(form)
        
        siblings_label: QLabel = QLabel(self.LABEL_SIBLINGS)
        layout.addWidget(siblings_label)
        
        self.siblings_container: QVBoxLayout = QVBoxLayout()
        layout.addLayout(self.siblings_container)
        
        return group
    
    def _create_father_row(self, form: QFormLayout) -> None:
        """Create father selector row."""
        self.father_selector: PersonSelector = PersonSelector(self.db_manager)
        self.father_selector.set_filter(gender="Male")
        self.father_selector.personSelected.connect(self._mark_dirty)
        self.father_selector.selectionCleared.connect(self._mark_dirty)
        self.father_selector.personSelected.connect(lambda: self._load_siblings())
        
        father_row: QHBoxLayout = QHBoxLayout()
        father_row.addWidget(self.father_selector)
        
        self.father_jump_btn: QPushButton = QPushButton(self.BUTTON_TEXT_VIEW_PERSON)
        self.father_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.father_selector.get_person_id())
        )
        father_row.addWidget(self.father_jump_btn)
        
        form.addRow(self.LABEL_FATHER, father_row)
    
    def _create_mother_row(self, form: QFormLayout) -> None:
        """Create mother selector row."""
        self.mother_selector: PersonSelector = PersonSelector(self.db_manager)
        self.mother_selector.set_filter(gender="Female")
        self.mother_selector.personSelected.connect(self._mark_dirty)
        self.mother_selector.selectionCleared.connect(self._mark_dirty)
        self.mother_selector.personSelected.connect(lambda: self._load_siblings())
        
        mother_row: QHBoxLayout = QHBoxLayout()
        mother_row.addWidget(self.mother_selector)
        
        self.mother_jump_btn: QPushButton = QPushButton(self.BUTTON_TEXT_VIEW_PERSON)
        self.mother_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.mother_selector.get_person_id())
        )
        mother_row.addWidget(self.mother_jump_btn)
        
        form.addRow(self.LABEL_MOTHER, mother_row)
    
    def _create_marriages_section(self) -> QGroupBox:
        """Create marriages section with inline editing."""
        group: QGroupBox = QGroupBox(self.LABEL_MARRIAGES)
        layout: QVBoxLayout = QVBoxLayout(group)
        
        self.marriages_container: QVBoxLayout = QVBoxLayout()
        layout.addLayout(self.marriages_container)
        
        add_btn: QPushButton = QPushButton(self.BUTTON_TEXT_ADD_MARRIAGE)
        add_btn.clicked.connect(self._add_marriage)
        layout.addWidget(add_btn)
        
        return group
    
    def _create_children_section(self) -> QGroupBox:
        """Create children section."""
        group: QGroupBox = QGroupBox(self.LABEL_CHILDREN)
        layout: QVBoxLayout = QVBoxLayout(group)
        
        self.children_container: QVBoxLayout = QVBoxLayout()
        layout.addLayout(self.children_container)
        
        add_btn: QPushButton = QPushButton(self.BUTTON_TEXT_ADD_CHILD)
        add_btn.clicked.connect(self._add_child)
        layout.addWidget(add_btn)
        
        return group
    
    # ------------------------------------------------------------------
    # Marriage Widget Creation
    # ------------------------------------------------------------------
    
    def _create_marriage_widget(self, marriage: Marriage) -> QFrame:
        """Create inline editable widget for a marriage."""
        frame: QFrame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        frame.setFrameShadow(QFrame.Shadow.Raised)
        main_layout: QVBoxLayout = QVBoxLayout(frame)
        
        header_layout: QHBoxLayout = self._create_marriage_header(marriage)
        main_layout.addLayout(header_layout)
        
        spouse_layout: QHBoxLayout = self._create_spouse_row(marriage, frame)
        main_layout.addLayout(spouse_layout)
        
        date_unknown_layout: QHBoxLayout = self._create_date_unknown_row(marriage, frame)
        main_layout.addLayout(date_unknown_layout)
        
        marriage_date_layout: QHBoxLayout = self._create_marriage_date_row(marriage, frame)
        main_layout.addLayout(marriage_date_layout)
        
        if not marriage.is_active:
            self._add_dissolution_rows(marriage, frame, main_layout)
        
        button_layout: QHBoxLayout = self._create_marriage_buttons(marriage)
        main_layout.addLayout(button_layout)
        
        return frame
    
    def _create_marriage_header(self, marriage: Marriage) -> QHBoxLayout:
        """Create marriage status header."""
        header_layout: QHBoxLayout = QHBoxLayout()
        
        status_text: str = self.STATUS_ACTIVE if marriage.is_active else self.STATUS_ENDED
        status_style: str = self.STYLE_ACTIVE_STATUS if marriage.is_active else self.STYLE_ENDED_STATUS
        
        status_indicator: QLabel = QLabel(status_text)
        status_indicator.setStyleSheet(status_style)
        header_layout.addWidget(status_indicator)
        header_layout.addStretch()
        
        return header_layout
    
    def _create_spouse_row(self, marriage: Marriage, frame: QFrame) -> QHBoxLayout:
        """Create spouse selector row."""
        spouse_layout: QHBoxLayout = QHBoxLayout()
        spouse_layout.addWidget(QLabel(self.LABEL_SPOUSE))
        
        spouse_selector: PersonSelector = PersonSelector(self.db_manager)
        
        with QSignalBlocker(spouse_selector):
            spouse_id: int | None = self._get_spouse_id_for_marriage(marriage)
            if spouse_id:
                spouse_selector.set_person(spouse_id)
        
        spouse_selector.personSelected.connect(self._mark_dirty)
        spouse_layout.addWidget(spouse_selector)
        
        spouse_jump_btn: QPushButton = QPushButton(self.BUTTON_TEXT_VIEW_PERSON)
        spouse_jump_btn.setEnabled(spouse_id is not None)
        spouse_jump_btn.clicked.connect(lambda: self._jump_to_person(spouse_selector.get_person_id()))
        spouse_selector.personSelected.connect(lambda: spouse_jump_btn.setEnabled(True))
        spouse_selector.selectionCleared.connect(lambda: spouse_jump_btn.setEnabled(False))
        spouse_layout.addWidget(spouse_jump_btn)
        
        frame.spouse_selector = spouse_selector  # type: ignore[attr-defined]
        
        return spouse_layout
    
    def _get_spouse_id_for_marriage(self, marriage: Marriage) -> int | None:
        """Get spouse ID for current person in marriage."""
        if not self.current_person or not self.current_person.id:
            return None
        
        return self.marriage_repo.get_spouse_id(marriage, self.current_person.id)
    
    def _create_date_unknown_row(self, marriage: Marriage, frame: QFrame) -> QHBoxLayout:
        """Create date unknown checkbox row."""
        date_unknown_layout: QHBoxLayout = QHBoxLayout()
        date_unknown_layout.addSpacing(self.INDENT_SPACING)
        
        date_unknown_check: QCheckBox = QCheckBox(self.CHECKBOX_DATE_UNKNOWN)
        date_unknown_check.setChecked(marriage.marriage_year is None)
        date_unknown_layout.addWidget(date_unknown_check)
        date_unknown_layout.addStretch()
        
        frame.date_unknown_check = date_unknown_check  # type: ignore[attr-defined]
        
        return date_unknown_layout
    
    def _create_marriage_date_row(self, marriage: Marriage, frame: QFrame) -> QHBoxLayout:
        """Create marriage date picker row."""
        marriage_date_layout: QHBoxLayout = QHBoxLayout()
        
        marriage_date_label: QLabel = QLabel(self.LABEL_MARRIED)
        marriage_date_layout.addWidget(marriage_date_label)
        
        marriage_date: DatePicker = DatePicker()
        with QSignalBlocker(marriage_date):
            if marriage.marriage_year:
                marriage_date.set_date(marriage.marriage_year, marriage.marriage_month or 1)
            else:
                marriage_date.set_date(1721, 1)
        
        marriage_date.unknown_check.setVisible(False)
        marriage_date.dateChanged.connect(self._mark_dirty)
        marriage_date_layout.addWidget(marriage_date)
        marriage_date_layout.addStretch()
        
        date_known: bool = marriage.marriage_year is not None
        marriage_date_label.setVisible(date_known)
        marriage_date.setVisible(date_known)
        
        date_unknown_check: QCheckBox = frame.date_unknown_check  # type: ignore[attr-defined]
        date_unknown_check.stateChanged.connect(
            lambda: self._toggle_marriage_date_visibility(
                date_unknown_check,
                marriage_date_label,
                marriage_date
            )
        )
        
        frame.marriage_date = marriage_date  # type: ignore[attr-defined]
        
        return marriage_date_layout
    
    def _toggle_marriage_date_visibility(
        self,
        checkbox: QCheckBox,
        label: QLabel,
        picker: DatePicker
    ) -> None:
        """Toggle marriage date visibility based on checkbox."""
        date_is_known: bool = not checkbox.isChecked()
        label.setVisible(date_is_known)
        picker.setVisible(date_is_known)
        self._mark_dirty()
    
    def _add_dissolution_rows(self, marriage: Marriage, frame: QFrame, layout: QVBoxLayout) -> None:
        """Add dissolution date and reason rows for ended marriages."""
        end_date_layout: QHBoxLayout = self._create_end_date_row(marriage, frame)
        layout.addLayout(end_date_layout)
        
        reason_layout: QHBoxLayout = self._create_reason_row(marriage, frame)
        layout.addLayout(reason_layout)
    
    def _create_end_date_row(self, marriage: Marriage, frame: QFrame) -> QHBoxLayout:
        """Create end date picker row."""
        end_date_layout: QHBoxLayout = QHBoxLayout()
        end_date_layout.addWidget(QLabel(self.LABEL_ENDED))
        
        end_date: DatePicker = DatePicker()
        with QSignalBlocker(end_date):
            if marriage.dissolution_year:
                end_date.set_date(marriage.dissolution_year, marriage.dissolution_month)
        
        end_date.dateChanged.connect(self._mark_dirty)
        end_date_layout.addWidget(end_date)
        end_date_layout.addStretch()
        
        frame.end_date = end_date  # type: ignore[attr-defined]
        
        return end_date_layout
    
    def _create_reason_row(self, marriage: Marriage, frame: QFrame) -> QHBoxLayout:
        """Create dissolution reason combo box row."""
        reason_layout: QHBoxLayout = QHBoxLayout()
        reason_layout.addWidget(QLabel(self.LABEL_REASON))
        
        reason_combo: QComboBox = QComboBox()
        with QSignalBlocker(reason_combo):
            reason_combo.addItems([
                self.REASON_DEATH,
                self.REASON_DIVORCE,
                self.REASON_ANNULMENT,
                self.REASON_OTHER,
                self.REASON_UNKNOWN
            ])
            if marriage.dissolution_reason:
                index: int = reason_combo.findText(marriage.dissolution_reason)
                if index >= 0:
                    reason_combo.setCurrentIndex(index)
        
        reason_combo.currentIndexChanged.connect(self._mark_dirty)
        reason_layout.addWidget(reason_combo)
        reason_layout.addStretch()
        
        frame.reason_combo = reason_combo  # type: ignore[attr-defined]
        
        return reason_layout
    
    def _create_marriage_buttons(self, marriage: Marriage) -> QHBoxLayout:
        """Create action buttons for marriage."""
        button_layout: QHBoxLayout = QHBoxLayout()
        button_layout.addStretch()
        
        if marriage.is_active:
            end_btn: QPushButton = QPushButton(self.BUTTON_TEXT_END_MARRIAGE)
            end_btn.clicked.connect(lambda: self._end_marriage(marriage))
            button_layout.addWidget(end_btn)
        else:
            reactivate_btn: QPushButton = QPushButton(self.BUTTON_TEXT_REACTIVATE)
            reactivate_btn.clicked.connect(lambda: self._reactivate_marriage(marriage))
            button_layout.addWidget(reactivate_btn)
        
        delete_btn: QPushButton = QPushButton(self.BUTTON_TEXT_DELETE)
        delete_btn.clicked.connect(lambda: self._delete_marriage(marriage))
        button_layout.addWidget(delete_btn)
        
        return button_layout
    
    # ------------------------------------------------------------------
    # Person Widget Creation
    # ------------------------------------------------------------------
    
    def _create_person_widget(self, person: Person, show_remove: bool = False) -> QFrame:
        """Create widget displaying a person with jump button."""
        frame: QFrame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        layout: QHBoxLayout = QHBoxLayout(frame)
        
        birth_info: str = self._format_birth_info(person)
        info_text: str = self.PERSON_DISPLAY_FORMAT.format(
            name=person.display_name,
            birth=birth_info
        )
        info_label: QLabel = QLabel(info_text)
        layout.addWidget(info_label)
        layout.addStretch()
        
        jump_btn: QPushButton = QPushButton(self.BUTTON_TEXT_VIEW_PERSON)
        jump_btn.clicked.connect(lambda: self._jump_to_person(person.id))
        layout.addWidget(jump_btn)
        
        if show_remove:
            remove_btn: QPushButton = QPushButton(self.BUTTON_TEXT_REMOVE)
            remove_btn.clicked.connect(lambda: self._remove_child(person))
            layout.addWidget(remove_btn)
        
        return frame
    
    def _format_birth_info(self, person: Person) -> str:
        """Format birth information for person display."""
        if person.birth_year:
            return self.BIRTH_INFO_FORMAT.format(year=person.birth_year)
        return self.BIRTH_INFO_UNKNOWN
    
    # ------------------------------------------------------------------
    # Parent Dialog Communication
    # ------------------------------------------------------------------
    
    def _mark_dirty(self) -> None:
        """Mark parent dialog as having unsaved changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    # ------------------------------------------------------------------
    # Navigation
    # ------------------------------------------------------------------
    
    def _jump_to_person(self, person_id: int | None) -> None:
        """Jump to editing a different person."""
        if person_id is None:
            return
        
        dialog = self._find_parent_dialog()
        if not dialog:
            return
        
        person: Person | None = self.person_repo.get_by_id(person_id)
        if not person:
            return
        
        if dialog.has_unsaved_changes:
            if not self._confirm_save_before_jump(dialog):
                return
        
        self._switch_to_person(dialog, person)
    
    def _confirm_save_before_jump(self, dialog) -> bool:
        """Confirm whether to save changes before jumping to another person."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Question)
        msg.setWindowTitle(self.MSG_TITLE_SAVE_CHANGES)
        msg.setText(self.MSG_TEXT_SAVE_BEFORE_JUMP)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Save |
            QMessageBox.StandardButton.Discard |
            QMessageBox.StandardButton.Cancel
        )
        
        result = msg.exec()
        
        if result == QMessageBox.StandardButton.Cancel:
            return False
        
        if result == QMessageBox.StandardButton.Save:
            return dialog._save_changes()
        
        return True
    
    def _switch_to_person(self, dialog, person: Person) -> None:
        """Switch dialog to display different person."""
        dialog.person = person
        dialog.setWindowTitle(f"Edit Person: {person.display_name}")
        dialog._load_data()
        dialog.has_unsaved_changes = False
        dialog.panel_list.setCurrentRow(1)
    
    # ------------------------------------------------------------------
    # Marriage Management
    # ------------------------------------------------------------------

    def _add_marriage(self) -> None:
        """Add a new marriage using dialog."""
        if not self.current_person or not self.current_person.id:
            return
        
        if not self._validate_existing_marriages():
            return
        
        active_marriages: list[Marriage] = self._get_active_marriages()
        
        if not active_marriages:
            self._open_create_marriage_dialog()
            return
        
        result: bool | None = self._handle_active_marriage_before_new(active_marriages[0])
        
        if result is None:
            return
        
        self._open_create_marriage_dialog()

    def _get_active_marriages(self) -> list[Marriage]:
        """Get list of currently active marriages."""
        return [m for m, _ in self.marriage_widgets if m.is_active]

    def _validate_existing_marriages(self) -> bool:
        """Validate that all active marriages have spouses selected."""
        for marriage, widget in self.marriage_widgets:
            if not marriage.is_active:
                continue
            
            if not self._has_spouse_selected(widget):
                self._show_incomplete_marriage_error()
                return False
        
        return True

    def _has_spouse_selected(self, widget: QFrame) -> bool:
        """Check if marriage widget has a spouse selected."""
        spouse_selector: PersonSelector = widget.spouse_selector  # type: ignore[attr-defined]
        return spouse_selector.get_person_id() is not None

    def _show_incomplete_marriage_error(self) -> None:
        """Show error message for incomplete marriage."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_INCOMPLETE_MARRIAGE,
            self.MSG_TEXT_INCOMPLETE_MARRIAGE
        )

    def _handle_active_marriage_before_new(self, active_marriage: Marriage) -> bool | None:
        """
        Handle existing active marriage before creating new one.
        
        Returns:
            True: User ended the marriage, proceed with new marriage
            False: User wants to create new marriage anyway (keep current active)
            None: User cancelled, don't create new marriage
        """
        reply: QMessageBox.StandardButton = self._show_active_marriage_prompt()
        
        if reply == QMessageBox.StandardButton.Cancel:
            return None
        
        if reply == QMessageBox.StandardButton.No:
            return False
        
        return self._end_marriage_with_dialog(active_marriage)

    def _show_active_marriage_prompt(self) -> QMessageBox.StandardButton:
        """Show prompt asking user how to handle active marriage."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Question)
        msg.setWindowTitle(self.MSG_TITLE_END_CURRENT_MARRIAGE)
        msg.setText(self.MSG_TEXT_END_BEFORE_NEW)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes |
            QMessageBox.StandardButton.No |
            QMessageBox.StandardButton.Cancel
        )
        
        result: int = msg.exec()
        return QMessageBox.StandardButton(result)

    def _end_marriage_with_dialog(self, active_marriage: Marriage) -> bool | None:
        """Open end marriage dialog and process result."""
        end_dialog: EndMarriageDialog = EndMarriageDialog(active_marriage, self)
        
        if end_dialog.exec() != QDialog.DialogCode.Accepted:
            return None
        
        self._apply_marriage_dissolution(active_marriage, end_dialog)
        return True

    def _apply_marriage_dissolution(self, marriage: Marriage, dialog: EndMarriageDialog) -> None:
        """Apply dissolution data from dialog to marriage."""
        year, month, reason = dialog.get_dissolution_data()
        
        marriage.dissolution_year = year
        marriage.dissolution_month = month
        marriage.dissolution_reason = reason
        
        if marriage.id:
            self.modified_marriages[marriage.id] = marriage
        
        self._load_marriages()
        self._mark_dirty()

    def _open_create_marriage_dialog(self) -> None:
        """Open dialog to create new marriage."""
        from dialogs.create_marriage_dialog import CreateMarriageDialog
        
        if not self.current_person:
            return
        
        dialog: CreateMarriageDialog = CreateMarriageDialog(
            self.db_manager,
            self.current_person,
            self
        )
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        self._create_marriage_from_dialog(dialog)

    def _create_marriage_from_dialog(self, dialog: CreateMarriageDialog) -> None:
        """Create marriage object from dialog data."""
        spouse_id, year, month = dialog.get_marriage_data()
        
        new_marriage: Marriage = Marriage(
            spouse1_id=self.current_person.id,  # type: ignore[union-attr]
            spouse2_id=spouse_id,
            marriage_year=year,
            marriage_month=month
        )
        
        self.new_marriages.append(new_marriage)
        self._load_marriages()
        self._mark_dirty()

    def _end_marriage(self, marriage: Marriage) -> None:
        """End a marriage with dialog."""
        dialog: EndMarriageDialog = EndMarriageDialog(marriage, self)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        year, month, reason = dialog.get_dissolution_data()
        
        if not self._validate_end_date(marriage, year, month):
            return
        
        self._update_marriage_dissolution(marriage, year, month, reason)

    def _update_marriage_dissolution(
        self,
        marriage: Marriage,
        year: int | None,
        month: int | None,
        reason: str
    ) -> None:
        """Update marriage with dissolution data."""
        marriage.dissolution_year = year
        marriage.dissolution_month = month
        marriage.dissolution_reason = reason
        
        if marriage.id:
            self.modified_marriages[marriage.id] = marriage
        
        self._load_marriages()
        self._mark_dirty()

    def _validate_end_date(
        self,
        marriage: Marriage,
        end_year: int | None,
        end_month: int | None
    ) -> bool:
        """Validate that end date is after marriage date."""
        if not marriage.marriage_year or not end_year:
            return True
        
        if self._is_end_before_start(marriage, end_year, end_month):
            self._show_invalid_end_date_error()
            return False
        
        return True

    def _is_end_before_start(
        self,
        marriage: Marriage,
        end_year: int,
        end_month: int | None
    ) -> bool:
        """Check if end date is before marriage start date."""
        if end_year < marriage.marriage_year:  # type: ignore[operator]
            return True
        
        if end_year == marriage.marriage_year:
            if marriage.marriage_month and end_month:
                if end_month < marriage.marriage_month:
                    return True
        
        return False

    def _show_invalid_end_date_error(self) -> None:
        """Show error for invalid end date."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_INVALID_DATE,
            self.MSG_TEXT_INVALID_END_DATE
        )

    def _reactivate_marriage(self, marriage: Marriage) -> None:
        """Reactivate an ended marriage."""
        if not self._confirm_reactivate_marriage():
            return
        
        self._delete_empty_active_marriages()
        self._clear_marriage_dissolution(marriage)
        self._load_marriages()
        self._mark_dirty()

    def _clear_marriage_dissolution(self, marriage: Marriage) -> None:
        """Clear dissolution data from marriage."""
        marriage.dissolution_year = None
        marriage.dissolution_month = None
        marriage.dissolution_day = None
        marriage.dissolution_reason = ""
        
        if marriage.id:
            self.modified_marriages[marriage.id] = marriage

    def _confirm_reactivate_marriage(self) -> bool:
        """Confirm reactivation of ended marriage."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Question)
        msg.setWindowTitle(self.MSG_TITLE_REACTIVATE_MARRIAGE)
        msg.setText(self.MSG_TEXT_REACTIVATE_MARRIAGE)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        return msg.exec() == QMessageBox.StandardButton.Yes

    def _delete_empty_active_marriages(self) -> None:
        """Delete any active marriages that have no spouse selected."""
        for m, widget in list(self.marriage_widgets):
            if not m.is_active:
                continue
            
            if self._has_spouse_selected(widget):
                continue
            
            self._mark_marriage_for_deletion(m)

    def _mark_marriage_for_deletion(self, marriage: Marriage) -> None:
        """Mark marriage for deletion."""
        if marriage.id:
            self.deleted_marriage_ids.append(marriage.id)
        
        if marriage in self.new_marriages:
            self.new_marriages.remove(marriage)

    def _delete_marriage(self, marriage: Marriage) -> None:
        """Delete a marriage after confirmation."""
        if not self._confirm_delete_marriage():
            return
        
        self._mark_marriage_for_deletion(marriage)
        self._remove_marriage_widget(marriage)
        self._load_marriages()
        self._mark_dirty()

    def _remove_marriage_widget(self, marriage: Marriage) -> None:
        """Remove marriage from widget list."""
        self.marriage_widgets = [
            (m, w) for m, w in self.marriage_widgets if m != marriage
        ]

    def _confirm_delete_marriage(self) -> bool:
        """Confirm deletion of marriage."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_TITLE_DELETE_MARRIAGE)
        msg.setText(self.MSG_TEXT_DELETE_MARRIAGE)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        return msg.exec() == QMessageBox.StandardButton.Yes

    # ------------------------------------------------------------------
    # Child Management
    # ------------------------------------------------------------------
    
    def _add_child(self) -> None:
        """Open dialog to create a new child."""
        if not self.current_person or not self.current_person.id:
            return
        
        parent2_id: int | None = self._find_oldest_active_marriage_spouse()
        
        self._open_create_child_dialog(parent2_id)
    
    def _find_oldest_active_marriage_spouse(self) -> int | None:
        """Find spouse from oldest active marriage."""
        active_marriages: list[Marriage] = self.marriage_repo.get_active_marriages(
            self.current_person.id  # type: ignore[arg-type]
        )
        
        if not active_marriages:
            return None
        
        active_marriages.sort(key=self._get_marriage_sort_key)
        oldest_marriage: Marriage = active_marriages[0]
        
        return self.marriage_repo.get_spouse_id(
            oldest_marriage,
            self.current_person.id  # type: ignore[arg-type]
        )
    
    def _get_marriage_sort_key(self, marriage: Marriage) -> tuple[int, int]:
        """Get sort key for marriage based on date."""
        if marriage.marriage_year is None:
            return (self.SORT_YEAR_UNKNOWN, self.SORT_MONTH_UNKNOWN)
        
        return (marriage.marriage_year, marriage.marriage_month or 0)
    
    def _open_create_child_dialog(self, parent2_id: int | None) -> None:
        """Open dialog to create child."""
        from dialogs.create_child_dialog import CreateChildDialog
        
        if not self.current_person:
            return
        
        dialog: CreateChildDialog = CreateChildDialog(
            self.db_manager,
            self.current_person,
            parent2_id,
            self
        )
        
        if not dialog.exec():
            return
        
        created_person: Person | None = dialog.get_created_person()
        if created_person:
            self._load_children()
            self._mark_dirty()
    
    def _remove_child(self, child: Person) -> None:
        """Remove parent-child relationship."""
        if not self.current_person:
            return
        
        if not self._confirm_remove_child(child):
            return
        
        self._clear_parent_relationship(child)
        self.person_repo.update(child)
        
        self._load_children()
        self._mark_dirty()
    
    def _confirm_remove_child(self, child: Person) -> bool:
        """Confirm removal of child relationship."""
        if not self.current_person:
            return False
        
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_TITLE_REMOVE_CHILD)
        msg.setText(self.MSG_TEXT_REMOVE_CHILD_FORMAT.format(
            child_name=child.display_name,
            parent_name=self.current_person.display_name
        ))
        msg.setInformativeText(self.MSG_TEXT_REMOVE_CHILD_INFO)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        return msg.exec() == QMessageBox.StandardButton.Yes
    
    def _clear_parent_relationship(self, child: Person) -> None:
        """Clear parent IDs from child."""
        if not self.current_person:
            return
        
        if child.father_id == self.current_person.id:
            child.father_id = None
        
        if child.mother_id == self.current_person.id:
            child.mother_id = None
    
    # ------------------------------------------------------------------
    # Data Loading
    # ------------------------------------------------------------------
    
    def load_person(self, person: Person) -> None:
        """Load person relationship data."""
        self.current_person = person
        
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
        
        blockers: list[QSignalBlocker] = [
            QSignalBlocker(self.father_selector),
            QSignalBlocker(self.mother_selector),
        ]
        
        self._load_parent_selectors(person)
        self._load_siblings()
        self._load_marriages()
        self._load_children()
    
    def _load_parent_selectors(self, person: Person) -> None:
        """Load father and mother selectors."""
        if person.father_id:
            self.father_selector.set_person(person.father_id)
            self.father_jump_btn.setEnabled(True)
        else:
            self.father_selector.clear()
            self.father_jump_btn.setEnabled(False)
        
        if person.mother_id:
            self.mother_selector.set_person(person.mother_id)
            self.mother_jump_btn.setEnabled(True)
        else:
            self.mother_selector.clear()
            self.mother_jump_btn.setEnabled(False)
    
    def _load_siblings(self) -> None:
        """Load and display siblings."""
        self._clear_container(self.siblings_container)
        
        if not self.current_person:
            return
        
        siblings: list[Person] = self._get_siblings()
        
        if siblings:
            self._display_siblings(siblings)
        else:
            self._show_placeholder(self.siblings_container, self.PLACEHOLDER_NO_SIBLINGS)
    
    def _get_siblings(self) -> list[Person]:
        """Get list of siblings from both parents."""
        if not self.current_person or not self.current_person.id:
            return []
        
        siblings: list[Person] = []
        
        self._add_siblings_from_parent(self.father_selector.get_person_id(), siblings)
        self._add_siblings_from_parent(self.mother_selector.get_person_id(), siblings)
        
        return siblings

    def _add_siblings_from_parent(self, parent_id: int | None, siblings: list[Person]) -> None:
        """Add siblings from a specific parent to the siblings list."""
        if not parent_id or not self.current_person:
            return
        
        children: list[Person] = self.person_repo.get_children(parent_id)
        
        for child in children:
            if self._is_valid_sibling(child, siblings):
                siblings.append(child)

    def _is_valid_sibling(self, child: Person, existing_siblings: list[Person]) -> bool:
        """Check if child is a valid sibling (not self, not already in list)."""
        if not self.current_person:
            return False
        
        if child.id == self.current_person.id:
            return False
        
        if child in existing_siblings:
            return False
        
        return True
    
    def _display_siblings(self, siblings: list[Person]) -> None:
        """Display siblings in container."""
        for sibling in siblings:
            sibling_widget: QFrame = self._create_person_widget(sibling)
            self.siblings_container.addWidget(sibling_widget)
    
    def _load_marriages(self) -> None:
        """Load and display marriages."""
        self._clear_container(self.marriages_container)
        self.marriage_widgets.clear()
        
        if not self.current_person or not self.current_person.id:
            self._show_placeholder(self.marriages_container, self.PLACEHOLDER_NO_MARRIAGES)
            return
        
        all_marriages: list[Marriage] = self._get_all_marriages()
        
        if all_marriages:
            self._display_marriages(all_marriages)
        else:
            self._show_placeholder(self.marriages_container, self.PLACEHOLDER_NO_MARRIAGES)
    
    def _get_all_marriages(self) -> list[Marriage]:
        """Get all marriages (database + new - deleted), sorted by date."""
        if not self.current_person or self.current_person.id is None:
            return []
        
        marriages: list[Marriage] = self.marriage_repo.get_by_person(self.current_person.id)
        marriages = [m for m in marriages if m.id not in self.deleted_marriage_ids]
        
        marriages = self._apply_marriage_modifications(marriages)
        
        all_marriages: list[Marriage] = marriages + self.new_marriages
        all_marriages.sort(key=self._get_marriage_sort_key)
        
        return all_marriages
    
    def _apply_marriage_modifications(self, marriages: list[Marriage]) -> list[Marriage]:
        """Apply any modified marriage data."""
        return [
            self.modified_marriages[m.id] if m.id and m.id in self.modified_marriages else m
            for m in marriages
        ]
    
    def _display_marriages(self, marriages: list[Marriage]) -> None:
        """Display marriages in container."""
        for marriage in marriages:
            widget: QFrame = self._create_marriage_widget(marriage)
            self.marriages_container.addWidget(widget)
            self.marriage_widgets.append((marriage, widget))
    
    def _load_children(self) -> None:
        """Load and display children."""
        self._clear_container(self.children_container)
        
        if not self.current_person or not self.current_person.id:
            return
        
        children: list[Person] = self.person_repo.get_children(self.current_person.id)
        
        if children:
            self._display_children(children)
        else:
            self._show_placeholder(self.children_container, self.PLACEHOLDER_NO_CHILDREN)
    
    def _display_children(self, children: list[Person]) -> None:
        """Display children in container."""
        for child in children:
            child_widget: QFrame = self._create_person_widget(child, show_remove=True)
            self.children_container.addWidget(child_widget)
    
    def _clear_container(self, container: QVBoxLayout) -> None:
        """Clear all widgets from a container."""
        while container.count():
            item = container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
    
    def _show_placeholder(self, container: QVBoxLayout, text: str) -> None:
        """Show placeholder text in container."""
        placeholder: QLabel = QLabel(text)
        placeholder.setStyleSheet(self.STYLE_PLACEHOLDER)
        container.addWidget(placeholder)
    
    # ------------------------------------------------------------------
    # Data Extraction
    # ------------------------------------------------------------------
    
    def get_relationship_data(self) -> dict:
        """Extract relationship data."""
        return {
            'father_id': self.father_selector.get_person_id(),
            'mother_id': self.mother_selector.get_person_id(),
        }
    
    # ------------------------------------------------------------------
    # Data Persistence
    # ------------------------------------------------------------------
    
    def save_marriages(self) -> None:
        """Save all marriage changes to database."""
        for marriage_id in self.deleted_marriage_ids:
            self.marriage_repo.delete(marriage_id)
        
        for marriage in self.new_marriages:
            self._update_marriage_from_widget(marriage)
            self.marriage_repo.insert(marriage)
        
        for marriage, widget in self.marriage_widgets:
            if marriage in self.new_marriages:
                continue
            
            if marriage.id:
                self._update_marriage_from_widget(marriage, widget)
                self.marriage_repo.update(marriage)
        
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
    
    def _update_marriage_from_widget(self, marriage: Marriage, widget: QFrame | None = None) -> None:
        """Update marriage object from widget values."""
        if widget is None:
            widget = self._find_widget_for_marriage(marriage)
        
        if widget is None:
            return
        
        self._update_marriage_spouse(marriage, widget)
        self._update_marriage_date(marriage, widget)
    
    def _find_widget_for_marriage(self, marriage: Marriage) -> QFrame | None:
        """Find widget associated with marriage."""
        for m, w in self.marriage_widgets:
            if m == marriage:
                return w
        return None
    
    def _update_marriage_spouse(self, marriage: Marriage, widget: QFrame) -> None:
        """Update marriage spouse IDs from widget."""
        spouse_selector: PersonSelector = widget.spouse_selector  # type: ignore[attr-defined]
        spouse_id: int | None = spouse_selector.get_person_id()
        
        if not self.current_person or not self.current_person.id:
            return
        
        if marriage.spouse1_id == self.current_person.id:
            marriage.spouse2_id = spouse_id
        else:
            marriage.spouse1_id = spouse_id
    
    def _update_marriage_date(self, marriage: Marriage, widget: QFrame) -> None:
        """Update marriage date from widget."""
        date_unknown_check: QCheckBox = widget.date_unknown_check  # type: ignore[attr-defined]
        
        if date_unknown_check.isChecked():
            marriage.marriage_year = None
            marriage.marriage_month = None
        else:
            marriage_date_picker: DatePicker = widget.marriage_date  # type: ignore[attr-defined]
            year, month = marriage_date_picker.get_date()
            marriage.marriage_year = year
            marriage.marriage_month = month
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def validate(self) -> tuple[bool, str]:
        """Validate relationship data."""
        if not self.current_person:
            return (True, "")
        
        if self.father_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own father.")
        
        if self.mother_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own mother.")
        
        for marriage, widget in self.marriage_widgets:
            is_valid, error_msg = self._validate_marriage_dates(marriage, widget)
            if not is_valid:
                return (False, error_msg)
        
        return (True, "")
    
    def _validate_marriage_dates(self, marriage: Marriage, widget: QFrame) -> tuple[bool, str]:
        """Validate marriage date ranges."""
        marriage_date_picker: DatePicker = widget.marriage_date  # type: ignore[attr-defined]
        marriage_year, marriage_month = marriage_date_picker.get_date()
        
        if marriage.is_active:
            return (True, "")
        
        if not marriage.dissolution_year or not marriage_year:
            return (True, "")
        
        if marriage.dissolution_year < marriage_year:
            return (False, "Marriage end date cannot be before start date.")
        
        if marriage.dissolution_year == marriage_year:
            if marriage.dissolution_month and marriage_month:
                if marriage.dissolution_month < marriage_month:
                    return (False, "Marriage end date cannot be before start date.")
        
        return (True, "")

>> âœ… dialogs\end_marriage_dialog.py (65 code lines)
"""Dialog for ending a marriage."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QComboBox,
    QDialogButtonBox, QWidget, QMessageBox
)

if TYPE_CHECKING:
    from models.marriage import Marriage

from widgets.date_picker import DatePicker


class EndMarriageDialog(QDialog):
    """Dialog for ending a marriage with date and reason."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # Window
    WINDOW_TITLE: str = "End Marriage"
    WINDOW_MIN_WIDTH: int = 400
    
    # Labels
    LABEL_END_DATE: str = "End Date:"
    LABEL_REASON: str = "Reason:"
    
    # Dissolution Reasons
    REASON_DEATH: str = "Death"
    REASON_DIVORCE: str = "Divorce"
    REASON_ANNULMENT: str = "Annulment"
    REASON_OTHER: str = "Other"
    REASON_UNKNOWN: str = "Unknown"
    
    # Message Box Titles
    MSG_TITLE_VALIDATION_ERROR: str = "Validation Error"
    MSG_TITLE_INVALID_DATE: str = "Invalid Date"
    
    # Message Box Text
    MSG_TEXT_YEAR_REQUIRED: str = "End date year is required."
    MSG_TEXT_END_BEFORE_START: str = "Marriage cannot end before it started."
    
    # Default Values
    DEFAULT_YEAR: int = 1721
    DEFAULT_MONTH: int | None = None
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, marriage: Marriage, parent: QWidget | None = None) -> None:
        """Initialize end marriage dialog."""
        super().__init__(parent)
        
        self.marriage: Marriage = marriage
        self.dissolution_year: int | None = None
        self.dissolution_month: int | None = None
        self.dissolution_reason: str = ""
        
        self.setWindowTitle(self.WINDOW_TITLE)
        self.setMinimumWidth(self.WINDOW_MIN_WIDTH)
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        form: QFormLayout = self._create_form_layout()
        layout.addLayout(form)
        
        button_box: QDialogButtonBox = self._create_button_box()
        layout.addWidget(button_box)
    
    def _create_form_layout(self) -> QFormLayout:
        """Create form with end date and reason fields."""
        form: QFormLayout = QFormLayout()
        
        self._create_end_date_field(form)
        self._create_reason_field(form)
        
        return form
    
    def _create_end_date_field(self, form: QFormLayout) -> None:
        """Create end date picker field."""
        self.end_date: DatePicker = DatePicker()
        
        if self.marriage.marriage_year:
            self._set_date_constraints_from_marriage()
        else:
            self.end_date.set_date(self.DEFAULT_YEAR, self.DEFAULT_MONTH)
        
        self.end_date.unknown_check.setChecked(False)
        
        form.addRow(self.LABEL_END_DATE, self.end_date)

    def _set_date_constraints_from_marriage(self) -> None:
        """Set date picker constraints based on marriage start date."""
        self.end_date.set_min_date(
            self.marriage.marriage_year,  # type: ignore[arg-type]
            self.marriage.marriage_month
        )
        self.end_date.set_date(
            self.marriage.marriage_year,  # type: ignore[arg-type]
            self.marriage.marriage_month
        )
        
    def _create_reason_field(self, form: QFormLayout) -> None:
        """Create dissolution reason dropdown."""
        self.reason_combo: QComboBox = QComboBox()
        self.reason_combo.addItems([
            self.REASON_DEATH,
            self.REASON_DIVORCE,
            self.REASON_ANNULMENT,
            self.REASON_OTHER,
            self.REASON_UNKNOWN
        ])
        form.addRow(self.LABEL_REASON, self.reason_combo)
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create dialog button box."""
        button_box: QDialogButtonBox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        return button_box
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        if not self._validate_inputs():
            return
        
        self._collect_dissolution_data()
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate all input fields."""
        year, month = self.end_date.get_date()
        
        if not self._validate_year_exists(year):
            return False
        
        if not self._validate_end_after_start(year, month):
            return False
        
        return True
    
    def _validate_year_exists(self, year: int | None) -> bool:
        """Validate that year is provided."""
        if not year:
            QMessageBox.warning(
                self,
                self.MSG_TITLE_VALIDATION_ERROR,
                self.MSG_TEXT_YEAR_REQUIRED
            )
            return False
        
        return True
    
    def _validate_end_after_start(self, year: int, month: int | None) -> bool:
        """Validate end date is after marriage start date."""
        if not self.marriage.marriage_year:
            return True
        
        if year < self.marriage.marriage_year:
            self._show_invalid_date_error()
            return False
        
        if self._is_same_year_but_earlier_month(year, month):
            self._show_invalid_date_error()
            return False
        
        return True
    
    def _is_same_year_but_earlier_month(self, year: int, month: int | None) -> bool:
        """Check if end date is same year but earlier month than start."""
        if year != self.marriage.marriage_year:
            return False
        
        if not self.marriage.marriage_month or not month:
            return False
        
        return month < self.marriage.marriage_month
    
    def _show_invalid_date_error(self) -> None:
        """Show error for invalid date range."""
        QMessageBox.warning(
            self,
            self.MSG_TITLE_INVALID_DATE,
            self.MSG_TEXT_END_BEFORE_START
        )
    
    # ------------------------------------------------------------------
    # Data Collection
    # ------------------------------------------------------------------
    
    def _collect_dissolution_data(self) -> None:
        """Collect dissolution data from input fields."""
        year, month = self.end_date.get_date()
        
        self.dissolution_year = year
        self.dissolution_month = month
        self.dissolution_reason = self.reason_combo.currentText()
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_dissolution_data(self) -> tuple[int | None, int | None, str]:
        """Returns (year, month, reason)."""
        return (self.dissolution_year, self.dissolution_month, self.dissolution_reason)

>> ðŸ“‹ dialogs\import_csv_dialog.py (1 code lines)
"""Dialog for importing genealogy data from CSV files."""

from PySide6.QtWidgets import QDialog


class ImportCSVDialog(QDialog):
    """Dialog for CSV import configuration and mapping."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the CSV import dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add file picker for CSV selection
        # TODO: Add column mapping controls
        # TODO: Add preview table
        # TODO: Add import mode selection (replace/merge)
        # TODO: Add progress bar
        # TODO: Connect to CSVImporter utility
        pass


>> ðŸ“‹ dialogs\settings_dialog.py (1 code lines)
"""Dialog for application preferences and settings."""

from PySide6.QtWidgets import QDialog


class PreferencesDialog(QDialog):
    """Dialog for configuring application settings."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the preferences dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI with tabs
        # TODO: Add appearance settings (skin selection)
        # TODO: Add default view selection
        # TODO: Add date format preferences
        # TODO: Add auto-save settings
        # TODO: Load current settings from database
        # TODO: Save settings on OK button
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VIEWS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ views\__init__.py (2 code lines)
from .data_table_view import DataTableView

__all__ = ['DataTableView']

>> âœ… views\data_table_view.py (140 code lines)
"""Data table view for displaying all people."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QHeaderView, QMenu, QMessageBox, QLineEdit, QLabel
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QAction

from utils.text_normalizer import TextNormalizer
from utils.date_formatter import DateFormatter, DateParts, MonthStyle

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from database.person_repository import PersonRepository


class DataTableView(QWidget):
    """Widget displaying all people in a sortable, filterable table."""

    # Signals
    person_edited: Signal = Signal()

    # Table Column Configuration
    COLUMN_NUMBER: int = 0
    COLUMN_NAME: int = 1
    COLUMN_GENDER: int = 2
    COLUMN_BIRTH_DATE: int = 3
    COLUMN_DEATH_DATE: int = 4
    COLUMN_COUNT: int = 5
    
    COLUMN_HEADERS: list[str] = [
        "#",
        "Name",
        "Gender",
        "Birth Date",
        "Death Date"
    ]

    # UI Configuration
    SEARCH_PLACEHOLDER: str = "Filter by name..."
    SEARCH_MAX_WIDTH: int = 300
    
    DISPLAY_NUMBER_FORMAT: str = "{:06d}"
    DISPLAY_NUMBER_START: int = 1
    
    BUTTON_TEXT_ADD: str = "+ Add Person"
    BUTTON_TEXT_REFRESH: str = "Refresh"
    LABEL_TEXT_SEARCH: str = "Search:"

    # Dialog Messages
    MSG_NO_SELECTION_TITLE: str = "No Selection"
    MSG_NO_SELECTION_EDIT: str = "Please select a person to edit."
    MSG_NO_SELECTION_DELETE: str = "Please select a person to delete."
    
    MSG_DELETE_TITLE: str = "Delete Person"
    MSG_DELETE_TEXT: str = "Delete {name}?"
    MSG_DELETE_INFO: str = "This will also delete all their marriages, events, and relationships."

    # Context Menu
    ACTION_TEXT_EDIT: str = "Edit Person"
    ACTION_TEXT_DELETE: str = "Delete Person"

    # Display Defaults
    DEFAULT_GENDER_DISPLAY: str = "Unknown"
    EMPTY_DATE_DISPLAY: str = ""

    # Date Formatting
    DATE_MONTH_STYLE: MonthStyle = MonthStyle.ABBREVIATED
    DATE_SEPARATOR: str = " "
    SORT_VALUE_UNKNOWN_MONTH: int = 0
    SORT_VALUE_UNKNOWN_DAY: int = 0

    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize data table view with database manager."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person_repo: PersonRepository = PersonRepository(db_manager)
        self.people: list[Person] = []
        self.person_display_numbers: dict[int, int] = {}
        
        self._setup_ui()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create the table and controls."""
        layout: QVBoxLayout = QVBoxLayout(self)
        
        toolbar: QHBoxLayout = self._create_toolbar()
        layout.addLayout(toolbar)
        
        self.table: QTableWidget = self._create_table()
        layout.addWidget(self.table)
    
    def _create_toolbar(self) -> QHBoxLayout:
        """Create toolbar with search and action buttons."""
        toolbar: QHBoxLayout = QHBoxLayout()
        
        toolbar.addWidget(QLabel(self.LABEL_TEXT_SEARCH))
        
        self.search_input: QLineEdit = QLineEdit()
        self.search_input.setPlaceholderText(self.SEARCH_PLACEHOLDER)
        self.search_input.textChanged.connect(self._filter_table)
        self.search_input.setMaximumWidth(self.SEARCH_MAX_WIDTH)
        toolbar.addWidget(self.search_input)
        
        toolbar.addStretch()
        
        add_btn: QPushButton = QPushButton(self.BUTTON_TEXT_ADD)
        add_btn.clicked.connect(self._add_person)
        toolbar.addWidget(add_btn)
        
        refresh_btn: QPushButton = QPushButton(self.BUTTON_TEXT_REFRESH)
        refresh_btn.clicked.connect(self.refresh_data)
        toolbar.addWidget(refresh_btn)
        
        return toolbar
    
    def _create_table(self) -> QTableWidget:
        """Create and configure the main data table."""
        table: QTableWidget = QTableWidget()
        table.setColumnCount(self.COLUMN_COUNT)
        table.setHorizontalHeaderLabels(self.COLUMN_HEADERS)
        
        table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        table.setSortingEnabled(True)
        table.setAlternatingRowColors(True)
        
        self._configure_table_columns(table)
        
        table.doubleClicked.connect(self._on_row_double_clicked)
        table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        table.customContextMenuRequested.connect(self._show_context_menu)
        
        return table
    
    def _configure_table_columns(self, table: QTableWidget) -> None:
        """Configure column resize modes for table."""
        header: QHeaderView = table.horizontalHeader()
        header.setSectionResizeMode(self.COLUMN_NUMBER, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(self.COLUMN_NAME, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(self.COLUMN_GENDER, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(self.COLUMN_BIRTH_DATE, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(self.COLUMN_DEATH_DATE, QHeaderView.ResizeMode.ResizeToContents)
    
    # ------------------------------------------------------------------
    # Data Management
    # ------------------------------------------------------------------
    
    def refresh_data(self) -> None:
        """Load all people from database and assign persistent display numbers."""
        self.people = self.person_repo.get_all()
        self.people.sort(key=lambda p: p.id or 0)
        
        self._assign_display_numbers()
        self._populate_table(self.people)
    
    def _assign_display_numbers(self) -> None:
        """Assign persistent display numbers to people based on ID order."""
        self.person_display_numbers.clear()
        for index, person in enumerate(self.people, start=self.DISPLAY_NUMBER_START):
            if person.id:
                self.person_display_numbers[person.id] = index
    
    def _populate_table(self, people: list[Person]) -> None:
        """Fill table with person data."""
        self.table.setSortingEnabled(False)
        self.table.setRowCount(0)
        
        for person in people:
            self._add_person_row(person)
        
        self.table.setSortingEnabled(True)
    
    def _add_person_row(self, person: Person) -> None:
        """Add a single person as a row in the table."""
        row: int = self.table.rowCount()
        self.table.insertRow(row)
        
        self._set_number_cell(row, person)
        self._set_name_cell(row, person)
        self._set_gender_cell(row, person)
        self._set_birth_date_cell(row, person)
        self._set_death_date_cell(row, person)
    
    def _set_number_cell(self, row: int, person: Person) -> None:
        """Set the display number cell for a person."""
        display_num: int = self.person_display_numbers.get(person.id or 0, 0)
        display_text: str = self.DISPLAY_NUMBER_FORMAT.format(display_num)
        
        item: QTableWidgetItem = QTableWidgetItem(display_text)
        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        item.setData(Qt.ItemDataRole.UserRole, person.id)
        item.setData(Qt.ItemDataRole.UserRole + 1, display_num)
        
        self.table.setItem(row, self.COLUMN_NUMBER, item)
    
    def _set_name_cell(self, row: int, person: Person) -> None:
        """Set the name cell for a person."""
        item: QTableWidgetItem = QTableWidgetItem(person.display_name)
        self.table.setItem(row, self.COLUMN_NAME, item)
    
    def _set_gender_cell(self, row: int, person: Person) -> None:
        """Set the gender cell for a person."""
        gender_text: str = person.gender or self.DEFAULT_GENDER_DISPLAY
        
        item: QTableWidgetItem = QTableWidgetItem(gender_text)
        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        
        self.table.setItem(row, self.COLUMN_GENDER, item)
    
    def _set_birth_date_cell(self, row: int, person: Person) -> None:
        """Set the birth date cell for a person."""
        if person.birth_year is None:
            item: QTableWidgetItem = QTableWidgetItem(self.EMPTY_DATE_DISPLAY)
            item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, self.COLUMN_BIRTH_DATE, item)
            return
        
        date_parts: DateParts = DateParts(
            year=person.birth_year,
            month=person.birth_month,
            day=person.birth_day
        )
        
        display_text: str = DateFormatter.format_display(
            date=date_parts,
            month_style=self.DATE_MONTH_STYLE,
            separator=self.DATE_SEPARATOR
        )
        
        sort_value: int = self._calculate_date_sort_value(
            person.birth_year,
            person.birth_month,
            person.birth_day
        )
        
        item: QTableWidgetItem = QTableWidgetItem(display_text)
        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        item.setData(Qt.ItemDataRole.UserRole, sort_value)
        
        self.table.setItem(row, self.COLUMN_BIRTH_DATE, item)
    
    def _set_death_date_cell(self, row: int, person: Person) -> None:
        """Set the death date cell for a person."""
        if person.death_year is None:
            item: QTableWidgetItem = QTableWidgetItem(self.EMPTY_DATE_DISPLAY)
            item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, self.COLUMN_DEATH_DATE, item)
            return
        
        date_parts: DateParts = DateParts(
            year=person.death_year,
            month=person.death_month,
            day=person.death_day
        )
        
        display_text: str = DateFormatter.format_display(
            date=date_parts,
            month_style=self.DATE_MONTH_STYLE,
            separator=self.DATE_SEPARATOR
        )
        
        sort_value: int = self._calculate_date_sort_value(
            person.death_year,
            person.death_month,
            person.death_day
        )
        
        item: QTableWidgetItem = QTableWidgetItem(display_text)
        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        item.setData(Qt.ItemDataRole.UserRole, sort_value)
        
        self.table.setItem(row, self.COLUMN_DEATH_DATE, item)
    
    def _calculate_date_sort_value(
        self,
        year: int,
        month: int | None,
        day: int | None
    ) -> int:
        """Calculate numeric sort value for date (YYYYMMDD format)."""
        year_part: int = year * 10000
        month_part: int = (month or self.SORT_VALUE_UNKNOWN_MONTH) * 100
        day_part: int = day or self.SORT_VALUE_UNKNOWN_DAY
        
        return year_part + month_part + day_part
    
    # ------------------------------------------------------------------
    # Search & Filtering
    # ------------------------------------------------------------------
    
    def _filter_table(self) -> None:
        """Filter table based on search text (accent-insensitive)."""
        search_text: str = self.search_input.text().lower()
        
        if not search_text:
            self._populate_table(self.people)
            return
        
        normalized_search: str = TextNormalizer.normalize_for_search(search_text)
        
        filtered: list[Person] = [
            person for person in self.people
            if normalized_search in TextNormalizer.normalize_for_search(person.display_name)
        ]
        
        self._populate_table(filtered)
    
    # ------------------------------------------------------------------
    # Selection & Context Menu
    # ------------------------------------------------------------------
    
    def _get_selected_person(self) -> Person | None:
        """Get the person from the selected row."""
        selected_rows: list = self.table.selectedIndexes()
        if not selected_rows:
            return None
        
        row: int = selected_rows[0].row()
        display_num_item: QTableWidgetItem | None = self.table.item(row, self.COLUMN_NUMBER)
        if not display_num_item:
            return None
        
        person_id: int = display_num_item.data(Qt.ItemDataRole.UserRole)
        return self.person_repo.get_by_id(person_id)
    
    def _on_row_double_clicked(self) -> None:
        """Handle double-click on a row."""
        self._edit_selected_person()
    
    def _show_context_menu(self, position) -> None:
        """Show right-click context menu."""
        if not self._get_selected_person():
            return
        
        menu: QMenu = QMenu(self)
        
        edit_action: QAction = QAction(self.ACTION_TEXT_EDIT, self)
        edit_action.triggered.connect(self._edit_selected_person)
        menu.addAction(edit_action)
        
        menu.addSeparator()
        
        delete_action: QAction = QAction(self.ACTION_TEXT_DELETE, self)
        delete_action.triggered.connect(self._delete_selected_person)
        menu.addAction(delete_action)
        
        menu.exec(self.table.viewport().mapToGlobal(position))
    
    # ------------------------------------------------------------------
    # Person Actions
    # ------------------------------------------------------------------
    
    def _add_person(self) -> None:
        """Open Add Person dialog."""
        from dialogs.add_person_dialog import AddPersonDialog
        
        dialog: AddPersonDialog = AddPersonDialog(self.db_manager)
        if dialog.exec():
            self.refresh_data()
            self.person_edited.emit()
    
    def _edit_selected_person(self) -> None:
        """Open Edit Person dialog for selected row."""
        person: Person | None = self._get_selected_person()
        if not person:
            QMessageBox.warning(self, self.MSG_NO_SELECTION_TITLE, self.MSG_NO_SELECTION_EDIT)
            return
        
        from dialogs.edit_person_dialog import EditPersonDialog
        
        dialog: EditPersonDialog = EditPersonDialog(self.db_manager, person)
        if dialog.exec():
            self.refresh_data()
            self.person_edited.emit()
    
    def _delete_selected_person(self) -> None:
        """Delete the selected person after confirmation."""
        person: Person | None = self._get_selected_person()
        if not person:
            QMessageBox.warning(self, self.MSG_NO_SELECTION_TITLE, self.MSG_NO_SELECTION_DELETE)
            return
        
        if self._confirm_delete(person):
            self._execute_delete(person)
    
    def _confirm_delete(self, person: Person) -> bool:
        """Show confirmation dialog for person deletion."""
        msg: QMessageBox = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(self.MSG_DELETE_TITLE)
        msg.setText(self.MSG_DELETE_TEXT.format(name=person.display_name))
        msg.setInformativeText(self.MSG_DELETE_INFO)
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        return msg.exec() == QMessageBox.StandardButton.Yes
    
    def _execute_delete(self, person: Person) -> None:
        """Execute the deletion of a person."""
        if person.id:
            self.person_repo.delete(person.id)
            self.refresh_data()
            self.person_edited.emit()

>> ðŸ“‹ views\dynasty_view.py (0 code lines)


>> ðŸ“‹ views\stats_view\charts.py (2 code lines)
"""Chart widgets for statistical visualizations."""

from PySide6.QtWidgets import QWidget


class Charts(QWidget):
    """Container for various statistical charts and graphs."""

    def __init__(self, database_connection) -> None:
        """Initialize the charts widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add population over time chart
        # TODO: Add birth/death rate chart
        # TODO: Add age distribution histogram
        # TODO: Add family size comparison chart
        # TODO: Use matplotlib or QtCharts for rendering
        # TODO: Add export chart buttons
        pass

    def refresh_charts(self) -> None:
        """Reload data and redraw all charts."""
        # TODO: Reload statistics from database
        # TODO: Regenerate all chart data
        # TODO: Redraw all visualizations
        pass


>> ðŸ“‹ views\stats_view\comparison_widget.py (2 code lines)
"""Widget for comparing statistics between families or people."""

from PySide6.QtWidgets import QWidget


class ComparisonWidget(QWidget):
    """Side-by-side comparison of selected entities."""

    def __init__(self, database_connection) -> None:
        """Initialize the comparison widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add selectors for entities to compare
        # TODO: Display side-by-side statistics
        # TODO: Show comparison charts
        # TODO: Highlight differences
        # TODO: Support comparing families, people, or generations
        pass

    def set_comparison(self, entity1_id: int, entity2_id: int, entity_type: str) -> None:
        """Set which entities to compare."""
        # TODO: Load data for both entities
        # TODO: Calculate comparison metrics
        # TODO: Update display
        pass


>> ðŸ“‹ views\stats_view\family_dashboard.py (2 code lines)
"""Dashboard widget showing dynasty statistics."""

from PySide6.QtWidgets import QWidget


class FamilyDashboard(QWidget):
    """Dashboard displaying key statistics about the dynasty."""

    def __init__(self, database_connection) -> None:
        """Initialize the family dashboard widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Calculate total people count
        # TODO: Calculate total marriages count
        # TODO: Calculate average lifespan
        # TODO: Calculate generation count
        # TODO: Display statistics in grid layout
        # TODO: Add Charts widget for visualizations
        # TODO: Add refresh button
        pass

    def refresh_stats(self) -> None:
        """Recalculate and update all statistics."""
        # TODO: Reload data from database
        # TODO: Recalculate all metrics
        # TODO: Update display widgets
        pass


>> ðŸ“‹ views\table_view\event_table.py (2 code lines)
"""Table view for listing all events in the database."""

from PySide6.QtWidgets import QTableWidget


class EventTable(QTableWidget):
    """Sortable, filterable table of all events."""

    def __init__(self, database_connection) -> None:
        """Initialize the event table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Person, Event Type, Date, Description)
        # TODO: Load all events from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show event details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all events
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\family_table.py (2 code lines)
"""Table view for listing all families in the database."""

from PySide6.QtWidgets import QTableWidget


class FamilyTable(QTableWidget):
    """Sortable, filterable table of all families."""

    def __init__(self, database_connection) -> None:
        """Initialize the family table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Family Name, Member Count, Start Year, etc.)
        # TODO: Load all families from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add double-click handler to show family details
        # TODO: Add right-click menu (edit/view members)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all families
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\marriage_table.py (2 code lines)
"""Table view for listing all marriages in the database."""

from PySide6.QtWidgets import QTableWidget


class MarriageTable(QTableWidget):
    """Sortable, filterable table of all marriages."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Husband, Wife, Start Date, End Date, Type)
        # TODO: Load all marriages from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all marriages
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\person_table.py (2 code lines)
"""Table view for listing all people in the database."""

from PySide6.QtWidgets import QTableWidget


class PersonTable(QTableWidget):
    """Sortable, filterable table of all people."""

    def __init__(self, database_connection) -> None:
        """Initialize the person table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Name, Gender, Birth, Death, etc.)
        # TODO: Load all people from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add row selection highlighting
        # TODO: Add double-click handler to show person details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all people
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\timeline_view\event_marker.py (1 code lines)
"""Visual marker for person events on timeline."""

from PySide6.QtWidgets import QGraphicsWidget


class EventMarker(QGraphicsWidget):
    """Small marker showing an event on a person's timeline bar."""

    def __init__(self, event_id: int) -> None:
        """Initialize the event marker widget."""
        super().__init__()
        self.event_id = event_id
        # TODO: Load event data from database
        # TODO: Draw small icon/shape at event year
        # TODO: Use different colors for event types
        # TODO: Add tooltip showing event details
        # TODO: Add click handler for event editing
        pass


>> ðŸ“‹ views\timeline_view\family_bar.py (1 code lines)
"""Horizontal bar representing a family's timespan."""

from PySide6.QtWidgets import QGraphicsWidget


class FamilyBar(QGraphicsWidget):
    """Visual bar showing family existence over time."""

    def __init__(self, family_id: int) -> None:
        """Initialize the family bar widget."""
        super().__init__()
        self.family_id = family_id
        # TODO: Calculate family start year (earliest member birth)
        # TODO: Calculate family end year (latest member death or current)
        # TODO: Draw horizontal bar spanning timespan
        # TODO: Add family name label
        # TODO: Add click handler to show family details
        # TODO: Add PersonBar widgets for each family member
        pass


>> ðŸ“‹ views\timeline_view\major_event_marker.py (1 code lines)
"""Visual marker for major historical events."""

from PySide6.QtWidgets import QGraphicsWidget


class MajorEventMarker(QGraphicsWidget):
    """Vertical line showing major events across all families."""

    def __init__(self, major_event_id: int) -> None:
        """Initialize the major event marker widget."""
        super().__init__()
        self.major_event_id = major_event_id
        # TODO: Load major event data from database
        # TODO: Draw vertical line at event year
        # TODO: Add event name label
        # TODO: Use distinctive color/style
        # TODO: Add tooltip with event description
        # TODO: Add click handler for editing
        pass


>> ðŸ“‹ views\timeline_view\person_bar.py (1 code lines)
"""Horizontal bar representing a person's lifespan."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBar(QGraphicsWidget):
    """Visual bar showing person's life from birth to death."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person bar widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load person data from database
        # TODO: Calculate x position from birth_year
        # TODO: Calculate width from birth_year to death_year (or current)
        # TODO: Draw horizontal bar with portrait thumbnail
        # TODO: Add name label
        # TODO: Add event markers along bar
        # TODO: Add click handler to show person details
        pass


>> ðŸ“‹ views\timeline_view\timeline_canvas.py (2 code lines)
"""Main canvas for the timeline visualization view."""

from PySide6.QtWidgets import QGraphicsView


class TimelineCanvas(QGraphicsView):
    """Scrollable canvas displaying families and events over time."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the timeline canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Add horizontal time axis (year scale)
        # TODO: Add vertical scrolling for families
        # TODO: Implement zoom for time scale
        # TODO: Add major event markers
        # TODO: Load all families and events from database
        pass

    def refresh_timeline(self) -> None:
        """Reload and redraw entire timeline from database."""
        # TODO: Clear scene
        # TODO: Reload all data
        # TODO: Recreate all visual elements
        pass


>> ðŸ“‹ views\timeline_view.py (0 code lines)


>> ðŸ“‹ views\tree_view\__init__.py (0 code lines)
"""Tree view components for family tree visualization."""

from .enhanced_tooltip_panel import EnhancedTooltipPanel
from .person_box import PersonBox
from .relationship_line import RelationshipLine

__all__ = [
    "EnhancedTooltipPanel",
    "PersonBox",
    "RelationshipLine",
]

>> âœ… views\tree_view\enhanced_tooltip_panel.py (376 code lines)
"""Enhanced tooltip panel for person details."""

from PySide6.QtWidgets import QGraphicsWidget
from PySide6.QtCore import Qt, QRectF, Signal, QTimer, QPoint
from PySide6.QtGui import QPainter, QColor, QPen, QBrush, QFont, QCursor
from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from models.person import Person
    from database.db_manager import DatabaseManager
    from views.tree_view.person_box import PersonBox


class EnhancedTooltipPanel(QGraphicsWidget):
    """Enhanced tooltip showing detailed person information."""
    
    closed: Signal = Signal()
    manually_moved: Signal = Signal()
    
    PANEL_WIDTH: int = 300
    PANEL_HEIGHT: int = 600
    PADDING: int = 15
    CORNER_RADIUS: int = 8
    
    LOCK_ICON_SIZE: int = 10
    LOCK_INDICATOR_SIZE: int = 20
    LOCK_START_DELAY: int = 1000
    HOVER_LOCK_DURATION: int = 3000
    
    SECTION_HEADER_SPACING: int = 20
    SECTION_BOTTOM_SPACING: int = 10
    SEPARATOR_BOTTOM_SPACING: int = 15
    LINE_SPACING: int = 16
    LINE_SPACING_SMALL: int = 14
    LINE_SPACING_TINY: int = 4
    
    INDENT_LEVEL_0: int = 0
    INDENT_LEVEL_1: int = 10
    INDENT_LEVEL_2: int = 20
    INDENT_LEVEL_3: int = 30
    
    LOCK_ICON_OFFSET_X: float = 6.5
    LOCK_ICON_OFFSET_Y: float = 4
    LOCK_INDICATOR_X_OFFSET: int = 63
    LOCK_INDICATOR_Y_OFFSET: int = 15
    LOCK_ICON_CLICKABLE_SIZE: int = 25

    
    CLOSE_BUTTON_X_OFFSET: int = 30
    CLOSE_BUTTON_Y_OFFSET: int = 10
    CLOSE_BUTTON_SIZE: int = 20
    CLOSE_BUTTON_LINE_LENGTH: int = 15
    
    HEADER_HEIGHT: int = 50
    HEADER_PARTIAL_HEIGHT: int = 25
    HEADER_TEXT_Y_OFFSET: int = 10
    HEADER_TEXT_HEIGHT: int = 30
    HEADER_RIGHT_MARGIN: int = 70
    
    INITIAL_CONTENT_Y: int = 70
    DESCENDANTS_MAX_Y_OFFSET: int = 150
    EVENTS_MAX_Y_OFFSET: int = 20
    
    GENERATION_HEADER_Y_OFFSET: int = 14
    GENERATION_HEADER_HEIGHT: int = 16
    GENERATION_GROUP_SPACING: int = 18
    
    PERSON_ENTRY_NAME_OFFSET: int = 14
    PERSON_ENTRY_DATE_OFFSET: int = 16
    PERSON_ENTRY_DATE_INDENT: int = 10
    PERSON_ENTRY_ARRIVAL_OFFSET: int = 12
    
    SIBLING_DISPLAY_COUNT: int = 3
    SIBLING_OVERFLOW_INDENT: int = 10
    
    EVENT_TYPE_INDENT: int = 10
    
    PIE_START_ANGLE: int = 90 * 16
    PIE_FULL_CIRCLE: int = 360 * 16
    
    HOVER_HIDE_DELAY: int = 100
    
    COLOR_BG: QColor = QColor(255, 255, 255)
    COLOR_BORDER: QColor = QColor(100, 100, 255)
    COLOR_HEADER_BG: QColor = QColor(240, 240, 255)
    COLOR_TEXT: QColor = QColor(33, 33, 33)
    COLOR_TEXT_LIGHT: QColor = QColor(100, 100, 100)
    COLOR_CLOSE_BUTTON: QColor = QColor(200, 0, 0)
    COLOR_CLOSE_BUTTON_IDLE: QColor = QColor(150, 150, 150)
    COLOR_SEPARATOR: QColor = QColor(220, 220, 220)
    COLOR_LOCK_FILL: QColor = QColor(100, 100, 255)
    COLOR_LOCK_INDICATOR: QColor = QColor(100, 100, 255, 100)
    COLOR_LOCK_ICON_INACTIVE: QColor = QColor(80, 80, 80)
    
    def __init__(
        self,
        person_id: int,
        db_manager: 'DatabaseManager',
        current_year: int
    ) -> None:
        super().__init__()
        
        self.person_id: int = person_id
        self.db: 'DatabaseManager' = db_manager
        self.current_year: int = current_year
        
        self.person: 'Person | None' = None
        self.events: list = []
        self.relationships: dict = {}
        
        self._load_person_data()
        self._load_events()
        self.relationships = self._load_relationships()
        
        self.setMinimumSize(self.PANEL_WIDTH, self.PANEL_HEIGHT)
        self.setMaximumSize(self.PANEL_WIDTH, self.PANEL_HEIGHT)
        
        self._close_button_hovered: bool = False
        self._is_being_dragged: bool = False
        self._drag_start_pos: QPoint | None = None
        self.is_hovered: bool = False
        self.is_locked: bool = False
        self.parent_person_box: 'PersonBox | None' = None
        
        self._collapsed_generations: dict[str, bool] = {
            'descendants': False,
            'children': True,
            'grandchildren': True,
            'great_grandchildren': True,
            'great_great_grandchildren': True
        }
        self._generation_click_rects: dict[str, QRectF] = {}
        
        self._font_icon_small: QFont = QFont("Segoe UI Emoji", self.LOCK_ICON_SIZE)
        
        self._lock_delay_timer: QTimer = QTimer()
        self._lock_delay_timer.setSingleShot(True)
        self._lock_delay_timer.timeout.connect(self._start_lock_timer)
        
        self._hover_timer: QTimer = QTimer()
        self._hover_timer.setSingleShot(True)
        self._hover_timer.timeout.connect(self._on_hover_lock)
        
        self._animation_timer: QTimer = QTimer()
        self._animation_timer.setInterval(50)
        self._animation_timer.timeout.connect(self.update)
        
        self.setAcceptHoverEvents(True)
        self.setFlags(
            QGraphicsWidget.GraphicsItemFlag.ItemIsMovable |
            QGraphicsWidget.GraphicsItemFlag.ItemIsSelectable
        )
    
    # ========================================
    # Data Loading
    # ========================================
    
    def _load_person_data(self) -> None:
        """Load person data from database."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person WHERE id = ?", (self.person_id,))
        row = cursor.fetchone()
        
        if not row:
            return
        
        person_dict: dict = dict(row)
        
        from models.person import Person
        
        self.person = Person(
            id=person_dict.get('id'),
            first_name=person_dict.get('first_name', ''),
            middle_name=person_dict.get('middle_name', ''),
            last_name=person_dict.get('last_name', ''),
            maiden_name=person_dict.get('maiden_name') or '',
            nickname=person_dict.get('nickname', ''),
            gender=person_dict.get('gender', 'Unknown'),
            birth_year=person_dict.get('birth_year'),
            birth_month=person_dict.get('birth_month'),
            birth_day=person_dict.get('birth_day'),
            death_year=person_dict.get('death_year'),
            death_month=person_dict.get('death_month'),
            death_day=person_dict.get('death_day'),
            arrival_year=person_dict.get('arrival_year'),
            arrival_month=person_dict.get('arrival_month'),
            arrival_day=person_dict.get('arrival_day'),
            moved_out_year=person_dict.get('moved_out_year'),
            moved_out_month=person_dict.get('moved_out_month'),
            moved_out_day=person_dict.get('moved_out_day'),
            father_id=person_dict.get('father_id'),
            mother_id=person_dict.get('mother_id'),
            family_id=person_dict.get('family_id'),
            dynasty_id=person_dict.get('dynasty_id', 1),
            is_founder=bool(person_dict.get('is_founder', 0)),
            education=person_dict.get('education', 0),
            notes=person_dict.get('notes', '')
        )
    
    def _load_events(self) -> None:
        """Load events for this person."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("""
            SELECT * FROM Event 
            WHERE person_id = ?
            ORDER BY start_year, start_month, start_day
        """, (self.person_id,))
        
        self.events = cursor.fetchall()
    
    def _load_relationships(self) -> dict:
        """Load family relationships including full and half siblings."""
        if not self.db or not self.db.conn or not self.person:
            return {}
        
        cursor = self.db.conn.cursor()

        siblings: dict[str, list[str]] = {
            'brothers': [], 
            'sisters': [], 
            'other': [],
            'half_brothers': [],
            'half_sisters': [],
            'half_other': []
        }
        
        has_parents: bool = self.person.father_id is not None or self.person.mother_id is not None
        
        if has_parents:
            cursor.execute("""
                SELECT id, first_name, last_name, gender, father_id, mother_id
                FROM Person 
                WHERE (father_id = ? OR mother_id = ?)
                AND id != ?
            """, (self.person.father_id, self.person.mother_id, self.person_id))
            
            for row in cursor.fetchall():
                sibling: dict = dict(row)
                sibling_name: str = f"{sibling['first_name']} {sibling['last_name']}"
                
                shares_father: bool = sibling['father_id'] == self.person.father_id and self.person.father_id is not None
                shares_mother: bool = sibling['mother_id'] == self.person.mother_id and self.person.mother_id is not None
                is_full_sibling: bool = shares_father and shares_mother
                
                sibling_gender: str = sibling['gender']
                category_suffix: str = '' if is_full_sibling else 'half_'
                
                if sibling_gender == 'Male':
                    siblings[f'{category_suffix}brothers'].append(sibling_name)
                elif sibling_gender == 'Female':
                    siblings[f'{category_suffix}sisters'].append(sibling_name)
                else:
                    siblings[f'{category_suffix}other'].append(sibling_name)

        descendants: dict = self._load_all_descendants()
        
        return {
            'siblings': siblings,
            'descendants': descendants
        }

    def _load_all_descendants(self) -> dict[str, list[dict] | dict]:
        """Load all descendants with full details for collapsible list."""
        if not self.db or not self.db.conn:
            return {'all': [], 'by_generation': {}}
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, first_name, last_name, birth_year, death_year, gender, arrival_year, moved_out_year
            FROM Person 
            WHERE father_id = ? OR mother_id = ?
            ORDER BY birth_year
        """, (self.person_id, self.person_id))
        
        children: list[dict] = [dict(row) for row in cursor.fetchall()]
        all_descendants: list[dict] = []
        descendants_by_generation: dict[str, list[dict]] = {'children': children}
        
        for child in children:
            all_descendants.append(self._create_descendant_dict(child, 'child'))
        
        current_generation_ids: list[int] = [c['id'] for c in children]
        generation_names: list[str] = ['grandchildren', 'great_grandchildren', 'great_great_grandchildren']
        
        for generation_name in generation_names:
            if not current_generation_ids:
                break
            
            next_generation: list[dict] = self._fetch_generation(cursor, current_generation_ids)
            
            if next_generation:
                descendants_by_generation[generation_name] = next_generation
                
                for person in next_generation:
                    generation_label: str = generation_name.replace('_', ' ')
                    all_descendants.append(self._create_descendant_dict(person, generation_label))
                
                current_generation_ids = [p['id'] for p in next_generation]
            else:
                break
        
        return {
            'all': all_descendants,
            'by_generation': descendants_by_generation
        }

    def _fetch_generation(self, cursor, parent_ids: list[int]) -> list[dict]:
        """Fetch a generation of descendants given parent IDs."""
        placeholders: str = ','.join('?' * len(parent_ids))
        cursor.execute(f"""
            SELECT id, first_name, last_name, birth_year, death_year, gender, arrival_year, moved_out_year
            FROM Person 
            WHERE father_id IN ({placeholders}) OR mother_id IN ({placeholders})
            ORDER BY birth_year
        """, parent_ids + parent_ids)
        
        return [dict(row) for row in cursor.fetchall()]

    def _create_descendant_dict(self, person: dict, generation: str) -> dict:
        """Create standardized descendant dictionary."""
        return {
            'id': person['id'],
            'first_name': person['first_name'],
            'last_name': person['last_name'],
            'name': f"{person['first_name']} {person['last_name']}",
            'generation': generation,
            'gender': person.get('gender', 'Unknown'),
            'birth_year': person['birth_year'],
            'death_year': person['death_year'],
            'arrival_year': person.get('arrival_year'),
            'moved_out_year': person.get('moved_out_year')
        }
    
    # ========================================
    # Helper Methods
    # ========================================
    
    def _get_close_button_rect(self) -> QRectF:
        """Get close button clickable area."""
        close_x: float = self.PANEL_WIDTH - self.CLOSE_BUTTON_X_OFFSET
        close_y: float = self.CLOSE_BUTTON_Y_OFFSET
        return QRectF(close_x, close_y, self.CLOSE_BUTTON_SIZE, self.CLOSE_BUTTON_SIZE)
    
    def _get_lock_icon_rect(self) -> QRectF:
        """Get clickable area for lock icon."""
        indicator_x: float = self.PANEL_WIDTH - self.LOCK_INDICATOR_X_OFFSET
        indicator_y: float = self.LOCK_ICON_OFFSET_Y
        return QRectF(indicator_x - 5, indicator_y, self.LOCK_ICON_CLICKABLE_SIZE, 20)
    
    def _get_generation_header_rect(self, y: float, generation_key: str) -> QRectF:
        """Get clickable rectangle for generation header."""
        if generation_key == 'descendants':
            rect: QRectF = QRectF(
                self.PADDING + self.INDENT_LEVEL_1, 
                y - self.GENERATION_HEADER_Y_OFFSET, 
                self.PANEL_WIDTH - self.PADDING - self.INDENT_LEVEL_2, 
                self.GENERATION_HEADER_HEIGHT
        )
        else:
            rect: QRectF = QRectF(
                self.PADDING + self.INDENT_LEVEL_1, 
                y - self.GENERATION_HEADER_Y_OFFSET, 
                self.PANEL_WIDTH - self.PADDING - self.INDENT_LEVEL_2, 
                self.GENERATION_HEADER_HEIGHT
        )
        self._generation_click_rects[generation_key] = rect
        return rect
    
    def _get_generation_display_name(self, generation_key: str) -> str:
        """Get display name for generation with proper formatting."""
        generation_names: dict[str, str] = {
            'children': 'Children',
            'grandchildren': 'Grandchildren',
            'great_grandchildren': 'Great Grandchildren',
            'great_great_grandchildren': 'GÂ² Grandchildren'
        }
        
        if generation_key.startswith('great_'):
            great_count: int = generation_key.count('great_')
            if great_count > 2:
                return f"G^{great_count} Grandchildren"
        
        return generation_names.get(generation_key, generation_key.replace('_', ' ').title())
    
    def _get_gender_symbol(self, gender: str) -> str:
        """Get gender symbol for display."""
        return {"Male": "â™‚", "Female": "â™€"}.get(gender, "âš²")
    
    def _toggle_generation(self, generation_key: str) -> None:
        """Toggle collapse state for a generation and repaint."""
        current_state: bool = self._collapsed_generations.get(generation_key, True)
        self._collapsed_generations[generation_key] = not current_state
        self.update()
    
    def _start_lock_timer(self) -> None:
        """Start the hover lock timer."""
        if not self.is_locked:
            self._hover_timer.start(self.HOVER_LOCK_DURATION)
            self._animation_timer.start()
    
    def _on_hover_lock(self) -> None:
        """Called when lock timer completes."""
        self.is_locked = True
        self._animation_timer.stop()
        self.update()
    
    def _check_self_hide(self) -> None:
        """Hide tooltip if mouse isn't back in it and not locked."""
        mouse_not_in_tooltip: bool = not self.is_hovered
        tooltip_not_locked: bool = not self.is_locked
        
        should_hide: bool = mouse_not_in_tooltip and tooltip_not_locked
        
        if should_hide and self.scene():
            self.scene().removeItem(self)
            self.closed.emit()
    
    def _format_single_date(self, year: int | None, month: int | None, day: int | None) -> str:
        """Format a single date with month abbreviation."""
        if year is None:
            return "?"
        
        month_names: dict[int, str] = {
            1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr',
            5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug',
            9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'
        }
        
        if day and month:
            month_abbr: str = month_names.get(month, '')
            return f"{day} {month_abbr} {year}"
        elif month:
            month_abbr: str = month_names.get(month, '')
            return f"{month_abbr} {year}"
        else:
            return str(year)

    def _format_years(self, birth_year: int | None, death_year: int | None) -> str:
        """Format birth and death years for display."""
        birth_text: str = f"b. {birth_year}" if birth_year else "b. ?"
        
        if death_year:
            return f"({birth_text} - d. {death_year})"
        
        return f"({birth_text})"
    
    def _format_person_dates(self, person: dict) -> str:
        """Format all important dates for a person."""
        dates_parts: list[str] = []
        
        arrival_year: int | None = person.get('arrival_year')
        arrival_month: int | None = person.get('arrival_month')
        moved_out_year: int | None = person.get('moved_out_year')
        moved_out_month: int | None = person.get('moved_out_month')
        birth_year: int | None = person.get('birth_year')
        birth_month: int | None = person.get('birth_month')
        death_year: int | None = person.get('death_year')
        death_month: int | None = person.get('death_month')
        
        arrival_text: str = f"Arrival {arrival_month} {arrival_year}"
        if arrival_year and moved_out_year:
            dates_parts.append(f"{arrival_text} - Departure {moved_out_month} {moved_out_year}")
        elif arrival_year:
            dates_parts.append(f"{arrival_text}")

        birth_text: str = f"b. {birth_month} {birth_year}" if birth_month and birth_year else "b. ?"
        if death_year:
            dates_parts.append(f"{birth_text} - d. {death_month} {death_year}")
        else:
            dates_parts.append(birth_text)
        
        return " | ".join(dates_parts) if dates_parts else ""
    
    def _draw_section_header(self, painter: QPainter, y: float, section_font: QFont, text: str) -> float:
        """Draw a section header and return updated y position."""
        painter.setFont(section_font)
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING, int(y), text)
        return y + self.SECTION_HEADER_SPACING
    
    def _draw_separator_line(self, painter: QPainter, y: float) -> float:
        """Draw horizontal separator line and return updated y position."""
        painter.setPen(QPen(self.COLOR_SEPARATOR, 1))
        painter.drawLine(self.PADDING, int(y), self.PANEL_WIDTH - self.PADDING, int(y))
        return y + self.SEPARATOR_BOTTOM_SPACING
    
    # ========================================
    # Painting
    # ========================================
    
    def paint(self, painter: QPainter, option, widget=None) -> None:
        """Draw the tooltip panel."""
        if not self.person:
            return
        
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        painter.setPen(QPen(self.COLOR_BORDER, 2))
        painter.setBrush(QBrush(self.COLOR_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.PANEL_WIDTH, self.PANEL_HEIGHT),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )
        
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(self.COLOR_HEADER_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.PANEL_WIDTH, self.HEADER_HEIGHT),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )
        painter.drawRect(QRectF(0, self.HEADER_PARTIAL_HEIGHT, self.PANEL_WIDTH, self.HEADER_PARTIAL_HEIGHT))
        
        self._draw_lock_indicator(painter)
        self._draw_close_button(painter)
        self._draw_header(painter)
        self._draw_content(painter)
    
    def _draw_lock_indicator(self, painter: QPainter) -> None:
        """Draw lock indicator with countdown animation and clickable icon."""
        indicator_x: float = self.PANEL_WIDTH - self.LOCK_INDICATOR_X_OFFSET
        indicator_y: float = self.LOCK_INDICATOR_Y_OFFSET
        center_x: float = indicator_x + self.LOCK_INDICATOR_SIZE / 2
        center_y: float = indicator_y + self.LOCK_INDICATOR_SIZE / 2
        
        is_timer_active: bool = self._hover_timer.isActive()
        
        if is_timer_active:
            elapsed: int = self._hover_timer.interval() - self._hover_timer.remainingTime()
            fill_percent: float = min(1.0, elapsed / self.HOVER_LOCK_DURATION)
            
            painter.setPen(QPen(self.COLOR_LOCK_INDICATOR, 2))
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawEllipse(
                int(indicator_x), 
                int(indicator_y), 
                self.LOCK_INDICATOR_SIZE, 
                self.LOCK_INDICATOR_SIZE
            )
            
            if fill_percent > 0:
                painter.setBrush(QBrush(self.COLOR_LOCK_FILL))
                span_angle: int = int(-self.PIE_FULL_CIRCLE * fill_percent)
                painter.drawPie(
                    int(indicator_x), 
                    int(indicator_y), 
                    self.LOCK_INDICATOR_SIZE, 
                    self.LOCK_INDICATOR_SIZE,
                    self.PIE_START_ANGLE,
                    span_angle
                )
        
        painter.setFont(self._font_icon_small)
        
        if self.is_locked:
            painter.setPen(QPen(self.COLOR_LOCK_FILL))
            painter.drawText(
                int(center_x - self.LOCK_ICON_OFFSET_X), 
                int(center_y + self.LOCK_ICON_OFFSET_Y), 
                "ðŸ”’"
            )
        else:
            painter.setPen(QPen(self.COLOR_LOCK_ICON_INACTIVE))
            painter.drawText(
                int(center_x - self.LOCK_ICON_OFFSET_X), 
                int(center_y + self.LOCK_ICON_OFFSET_Y), 
                "ðŸ”“"
            )
    
    def _draw_close_button(self, painter: QPainter) -> None:
        """Draw close button."""
        close_x: float = self.PANEL_WIDTH - self.CLOSE_BUTTON_X_OFFSET
        close_y: float = self.CLOSE_BUTTON_Y_OFFSET
        button_color: QColor = self.COLOR_CLOSE_BUTTON if self._close_button_hovered else self.COLOR_CLOSE_BUTTON_IDLE
        
        painter.setPen(QPen(button_color, 2))
        painter.drawLine(
            int(close_x), 
            int(close_y), 
            int(close_x + self.CLOSE_BUTTON_LINE_LENGTH), 
            int(close_y + self.CLOSE_BUTTON_LINE_LENGTH)
        )
        painter.drawLine(
            int(close_x + self.CLOSE_BUTTON_LINE_LENGTH), 
            int(close_y), 
            int(close_x), 
            int(close_y + self.CLOSE_BUTTON_LINE_LENGTH)
        )
    
    def _draw_header(self, painter: QPainter) -> None:
        """Draw header with person name."""
        if not self.person:
            return
        
        painter.setPen(QPen(self.COLOR_TEXT))
        title_font: QFont = QFont("Segoe UI", 12, QFont.Weight.Bold)
        painter.setFont(title_font)
        painter.drawText(
            QRectF(
                self.PADDING, 
                self.HEADER_TEXT_Y_OFFSET, 
                self.PANEL_WIDTH - self.HEADER_RIGHT_MARGIN, 
                self.HEADER_TEXT_HEIGHT
            ), 
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, 
            self.person.full_name
        )
    
    def _draw_content(self, painter: QPainter) -> None:
        """Draw all content sections."""
        y: float = self.INITIAL_CONTENT_Y
        normal_font: QFont = QFont("Segoe UI", 9)
        section_font: QFont = QFont("Segoe UI", 10, QFont.Weight.Bold)
        
        section_methods: list[Callable] = [
            self._draw_statistics,
            self._draw_relationships,
            self._draw_descendants,
            self._draw_events
        ]
        
        for section_method in section_methods:
            y = section_method(painter, y, section_font, normal_font)
    
    def _draw_statistics(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw statistics section."""
        if not self.person:
            return y
        
        y = self._draw_section_header(painter, y, section_font, "Statistics")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        stats: list[str] = [
            f"Birth: {self._format_single_date(self.person.birth_year, self.person.birth_month, self.person.birth_day)}",
            f"Death: {self._format_single_date(self.person.death_year, self.person.death_month, self.person.death_day)}" if self.person.is_deceased else "Status: Living",
            f"Age: {self.person.get_age(self.current_year) or 'Unknown'}",
        ]
        
        for stat in stats:
            painter.drawText(self.PADDING, int(y), stat)
            y += self.LINE_SPACING
        
        return y + self.SECTION_BOTTOM_SPACING
    
    def _draw_relationships(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw relationships section."""
        y = self._draw_section_header(painter, y, section_font, "Relationships")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        siblings: dict[str, list[str]] = self.relationships.get('siblings', {})
        
        sibling_types: list[tuple[str, str]] = [
            ('brothers', 'Brothers'),
            ('half_brothers', 'Half-Brothers'),
            ('sisters', 'Sisters'),
            ('half_sisters', 'Half-Sisters'),
            ('other', 'Other Siblings'),
            ('half_other', 'Half-Siblings (Other)')
        ]
        
        for key, label in sibling_types:
            sibling_list: list[str] = siblings.get(key, [])
            if sibling_list:
                y = self._draw_sibling_group(painter, y, label, sibling_list)
        
        y += self.SECTION_BOTTOM_SPACING
        y = self._draw_separator_line(painter, y)
        return y

    def _draw_sibling_group(self, painter: QPainter, y: float, label: str, sibling_list: list[str]) -> float:
        """Draw a group of siblings with overflow handling."""
        displayed_names: str = ', '.join(sibling_list[:self.SIBLING_DISPLAY_COUNT])
        painter.drawText(self.PADDING, int(y), f"{label}: {displayed_names}")
        y += self.LINE_SPACING
        
        overflow_count: int = len(sibling_list) - self.SIBLING_DISPLAY_COUNT
        if overflow_count > 0:
            painter.drawText(
                self.PADDING + self.SIBLING_OVERFLOW_INDENT, 
                int(y), 
                f"...and {overflow_count} more"
            )
            y += self.LINE_SPACING
        
        return y
    
    def _draw_descendants(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw descendants section with collapsible generations."""
        descendants: dict = self.relationships.get('descendants', {})
        descendants_by_generation: dict = descendants.get('by_generation', {})
        all_descendants: list[dict] = descendants.get('all', [])
        
        if not all_descendants:
            return y
        
        is_collapsed: bool = self._collapsed_generations.get('descendants', False)
        arrow: str = "â–¶" if is_collapsed else "â–¼"
        
        painter.setFont(section_font)
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING, int(y), f"Descendants ({len(all_descendants)}) {arrow}")
        self._get_generation_header_rect(y, 'descendants')
        
        y += self.SECTION_HEADER_SPACING
        
        if is_collapsed:
            y += self.SECTION_BOTTOM_SPACING
            y = self._draw_separator_line(painter, y)
            return y

        descendants_section_max_y: float = self.PANEL_HEIGHT - self.DESCENDANTS_MAX_Y_OFFSET
        
        generation_order: list[str] = sorted(
            descendants_by_generation.keys(),
            key=lambda x: (x.count('great_'), x)
        )
        
        for generation_key in generation_order:
            generation_list: list[dict] = descendants_by_generation[generation_key]
            if not generation_list:
                continue
            
            if y > descendants_section_max_y:
                break
            
            y = self._draw_generation_group(painter, y, generation_key, generation_list, normal_font, descendants_section_max_y)
        
        y += self.SECTION_BOTTOM_SPACING
        y = self._draw_separator_line(painter, y)
        return y

    def _draw_generation_group(
        self, 
        painter: QPainter, 
        y: float, 
        generation_key: str, 
        generation_list: list[dict],
        normal_font: QFont,
        max_y: float
    ) -> float:
        """Draw a collapsible generation group."""
        is_collapsed: bool = self._collapsed_generations.get(generation_key, True)
        arrow: str = "â–¶" if is_collapsed else "â–¼"
        
        generation_name: str = self._get_generation_display_name(generation_key)
        
        self._get_generation_header_rect(y, generation_key)
        
        painter.setFont(QFont("Segoe UI", 9, QFont.Weight.Bold))
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(
            self.PADDING + self.INDENT_LEVEL_1, 
            int(y), 
            f"{arrow} {generation_name} ({len(generation_list)})"
        )
        y += self.GENERATION_GROUP_SPACING
        
        if is_collapsed:
            return y
        
        painter.setFont(normal_font)
        
        for person in generation_list:
            if y > max_y:
                remaining: int = len(generation_list) - generation_list.index(person)
                painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
                painter.drawText(self.PADDING + self.INDENT_LEVEL_2, int(y), f"...and {remaining} more")
                break
            
            y = self._draw_person_entry(painter, y, person)
        
        return y

    def _draw_person_entry(self, painter: QPainter, y: float, person: dict) -> float:
        """Draw a single person entry with name, gender, and dates on separate lines."""
        person_name: str = f"{person['first_name']} {person['last_name']}"
        gender_symbol: str = self._get_gender_symbol(person.get('gender', 'Unknown'))
        
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING + self.INDENT_LEVEL_2, int(y), f"{person_name} {gender_symbol}")
        y += self.PERSON_ENTRY_NAME_OFFSET
        
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        painter.setFont(QFont("Segoe UI", 8))
        
        has_arrival: bool = person.get('arrival_year') is not None
        
        if has_arrival:
            arrival_text: str = self._format_single_date(
                person.get('arrival_year'),
                person.get('arrival_month'),
                person.get('arrival_day')
            )
            
            has_departure: bool = person.get('moved_out_year') is not None
            
            if has_departure:
                departure_text: str = self._format_single_date(
                    person.get('moved_out_year'),
                    person.get('moved_out_month'),
                    person.get('moved_out_day')
                )
                painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"Arr: {arrival_text} - Dep: {departure_text}")
            else:
                painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"Arrival: {arrival_text}")
            
            y += self.PERSON_ENTRY_ARRIVAL_OFFSET
        
        birth_text: str = self._format_single_date(
            person.get('birth_year'),
            person.get('birth_month'),
            person.get('birth_day')
        )
        
        has_death: bool = person.get('death_year') is not None
        
        if has_death:
            death_text: str = self._format_single_date(
                person.get('death_year'),
                person.get('death_month'),
                person.get('death_day')
            )
            painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"b. {birth_text} - d. {death_text}")
        else:
            painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"b. {birth_text}")
        
        painter.setFont(QFont("Segoe UI", 9))
        y += self.PERSON_ENTRY_DATE_OFFSET
        
        return y
    
    def _draw_events(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw events timeline section."""
        y = self._draw_section_header(painter, y, section_font, f"Life Events ({len(self.events)})")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        max_y: float = self.PANEL_HEIGHT - self.PADDING
        event_count: int = 0
        
        for event in self.events:
            if y > max_y - self.EVENTS_MAX_Y_OFFSET:
                remaining_events: int = len(self.events) - event_count
                painter.drawText(self.PADDING, int(y), f"...and {remaining_events} more")
                break
            
            event_dict: dict = dict(event)
            event_year: str = str(event_dict.get('start_year', '?'))
            event_title: str = event_dict.get('event_title', 'Unknown')
            event_type: str = event_dict.get('event_type', '')
            
            painter.drawText(self.PADDING, int(y), f"{event_year}: {event_title}")
            y += self.LINE_SPACING_SMALL
            
            if event_type:
                painter.drawText(self.PADDING + self.EVENT_TYPE_INDENT, int(y), f"({event_type})")
                y += self.LINE_SPACING_SMALL
            
            event_count += 1
            y += self.LINE_SPACING_TINY
        
        return y
    
    # ========================================
    # Qt Event Handlers
    # ========================================
    
    def boundingRect(self) -> QRectF:
        """Define widget bounds for Qt rendering system."""
        return QRectF(0, 0, self.PANEL_WIDTH, self.PANEL_HEIGHT)

    def hoverEnterEvent(self, event) -> None:
        """Track when mouse enters tooltip and start lock delay timer."""
        self.is_hovered = True
        self._lock_delay_timer.start(self.LOCK_START_DELAY)
        super().hoverEnterEvent(event)

    def hoverMoveEvent(self, event) -> None:
        """Track close button, lock icon, and generation header hover states."""
        mouse_position = event.pos()
        
        close_rect: QRectF = self._get_close_button_rect()
        self._close_button_hovered = close_rect.contains(mouse_position)
        
        lock_rect: QRectF = self._get_lock_icon_rect()
        lock_icon_hovered: bool = lock_rect.contains(mouse_position)
        
        hovering_header: bool = False
        for rect in self._generation_click_rects.values():
            if rect.contains(mouse_position):
                hovering_header = True
                break
        
        is_hovering_interactive_element: bool = self._close_button_hovered or hovering_header or lock_icon_hovered
        
        if is_hovering_interactive_element:
            self.setCursor(Qt.CursorShape.PointingHandCursor)
        else:
            self.setCursor(Qt.CursorShape.ArrowCursor)
        
        self.update()
        super().hoverMoveEvent(event)

    def hoverLeaveEvent(self, event) -> None:
        """Track when mouse leaves tooltip and potentially hide."""
        self.is_hovered = False
        self._lock_delay_timer.stop()
        self._hover_timer.stop()
        self._animation_timer.stop()
        
        if not self.is_locked:
            QTimer.singleShot(self.HOVER_HIDE_DELAY, self._check_self_hide)
        
        super().hoverLeaveEvent(event)

    def mousePressEvent(self, event) -> None:
        """Handle clicks on close button, lock icon, generation headers, or start drag."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if not is_left_click:
            super().mousePressEvent(event)
            return
        
        click_position = event.pos()
        
        close_rect: QRectF = self._get_close_button_rect()
        clicked_close_button: bool = close_rect.contains(click_position)
        
        if clicked_close_button:
            self.closed.emit()
            if self.scene():
                self.scene().removeItem(self)
            return
        
        lock_rect: QRectF = self._get_lock_icon_rect()
        clicked_lock_icon: bool = lock_rect.contains(click_position)
        
        if clicked_lock_icon:
            self.is_locked = not self.is_locked
            if self.is_locked:
                self._lock_delay_timer.stop()
                self._hover_timer.stop()
                self._animation_timer.stop()
            self.update()
            return
        
        for generation_key, rect in self._generation_click_rects.items():
            if rect.contains(click_position):
                self._toggle_generation(generation_key)
                return
        
        self._is_being_dragged = True
        self._drag_start_pos = click_position
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:
        """Handle dragging."""
        if self._is_being_dragged:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event) -> None:
        """Handle drag end and mark as manually moved."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if is_left_click and self._is_being_dragged:
            self.manually_moved.emit()
            self._is_being_dragged = False
        
        super().mouseReleaseEvent(event)

>> ðŸ“‹ views\tree_view\generation_band.py (2 code lines)
"""Horizontal band showing a generation level in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class GenerationBand(QGraphicsWidget):
    """Background band for highlighting a generation level."""

    def __init__(self, generation: int, y_position: float, height: float) -> None:
        """Initialize the generation band widget."""
        super().__init__()
        self.generation = generation
        self.y_position = y_position
        self.height = height
        # TODO: Draw horizontal background rectangle
        # TODO: Use alternating colors for visual separation
        # TODO: Add generation label on left side
        # TODO: Update position when tree layout changes
        pass

    def update_position(self, new_y: float, new_height: float) -> None:
        """Adjust band position and height."""
        # TODO: Update y_position and height
        # TODO: Redraw band
        pass


>> ðŸ“‹ views\tree_view\layout_engine.py (2 code lines)
"""Automatic layout engine for positioning people in the tree."""


class TreeLayoutEngine:
    """Calculate automatic positions for people in the family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the layout engine."""
        self.db = database_connection

    def calculate_positions(self) -> dict[int, tuple[float, float]]:
        """Calculate x,y positions for all people."""
        # TODO: Implement generational hierarchy algorithm
        # TODO: Group siblings together
        # TODO: Consider cohort positioning (move-in dates)
        # TODO: Return dict: person_id -> (x, y)
        pass


>> ðŸ“‹ views\tree_view\marriage_node.py (1 code lines)
"""Visual representation of a marriage in the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class MarriageNode(QGraphicsWidget):
    """Node connecting spouses in the family tree."""

    def __init__(self, marriage_id: int) -> None:
        """Initialize the marriage node widget."""
        super().__init__()
        self.marriage_id = marriage_id
        # TODO: Draw small connector shape (circle/diamond)
        # TODO: Display marriage date on hover
        # TODO: Connect to both spouse PersonBox widgets
        # TODO: Add click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete marriage)
        pass


>> âœ… views\tree_view\person_box.py (333 code lines)
"""Person box widget for the tree view."""

from PySide6.QtWidgets import QGraphicsWidget
from PySide6.QtCore import Qt, QRectF, QPointF, QTimer, Signal
from PySide6.QtGui import QPainter, QColor, QPen, QBrush, QFont, QPixmap, QPainterPath, QFontMetrics
from datetime import datetime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from models.person import Person
    from database.db_manager import DatabaseManager
    from views.tree_view.enhanced_tooltip_panel import EnhancedTooltipPanel


class PersonBox(QGraphicsWidget):
    """Visual representation of a person in the family tree."""
    
    person_double_clicked: Signal = Signal(int)
    person_selected: Signal = Signal(int)
    favorite_toggled: Signal = Signal(int, bool)
    
    BOX_MIN_WIDTH: int = 300
    BOX_MAX_WIDTH: int = 300
    BOX_HEIGHT: int = 130
    PHOTO_SIZE: int = 110
    BORDER_WIDTH: int = 3
    CORNER_RADIUS: int = 8
    TEXT_PADDING: int = 10
    
    TOOLTIP_WIDTH: int = 300
    TOOLTIP_HEIGHT: int = 600
    TOOLTIP_OFFSET_X: int = 10
    TOOLTIP_DELAY: int = 1000
    
    FAVORITE_STAR_SIZE: int = 20
    
    COLOR_LIVING: QColor = QColor(76, 175, 80)
    COLOR_DECEASED: QColor = QColor(158, 158, 158)
    COLOR_BG: QColor = QColor(255, 255, 255)
    COLOR_TEXT: QColor = QColor(33, 33, 33)
    COLOR_TEXT_LIGHT: QColor = QColor(120, 120, 120)
    COLOR_SEPARATOR: QColor = QColor(200, 200, 200)
    COLOR_FAVORITE_STAR: QColor = QColor(255, 215, 0)
    COLOR_FAVORITE_HOVER: QColor = QColor(200, 200, 200)
    
    def __init__(
        self, 
        person_id: int, 
        db_manager: 'DatabaseManager',
        current_year: int | None = None
    ) -> None:
        super().__init__()
        
        self.person_id: int = person_id
        self.db: 'DatabaseManager' = db_manager
        self.current_year: int = current_year if current_year is not None else datetime.now().year
        
        self.person: 'Person | None' = None
        self.portrait_pixmap: QPixmap | None = None
        self.is_favorite: bool = False
        
        self._font_name_bold: QFont = QFont("Segoe UI", 11, QFont.Weight.Bold)
        self._font_normal: QFont = QFont("Segoe UI", 9)
        self._font_icon: QFont = QFont("Segoe UI Emoji", 12)

        self._load_person_data()
        self._load_portrait()
        self._load_favorite_status()
        
        self.box_width: float = self._calculate_box_width()
        _, name_line2 = self._get_display_name_lines()
        self.box_height: float = self.BOX_HEIGHT + (18 if name_line2 else 0)
        
        self.setFlags(
            QGraphicsWidget.GraphicsItemFlag.ItemIsMovable |
            QGraphicsWidget.GraphicsItemFlag.ItemIsSelectable |
            QGraphicsWidget.GraphicsItemFlag.ItemSendsGeometryChanges
        )
        self.setAcceptHoverEvents(True)
        self.setMinimumSize(self.box_width, self.box_height)
        self.setMaximumSize(self.box_width, self.box_height)
        
        self._is_dragging: bool = False
        self._drag_start_pos: QPointF | None = None
        
        self._tooltip_delay_timer: QTimer = QTimer()
        self._tooltip_delay_timer.setSingleShot(True)
        self._tooltip_delay_timer.timeout.connect(self._show_enhanced_tooltip)
        
        self._is_hovered: bool = False
        self._is_name_hovered: bool = False
        self._is_star_hovered: bool = False
        self._tooltip_manually_positioned: bool = False
        self._tooltip_panel: 'EnhancedTooltipPanel | None' = None
    
    def _query_one(self, sql: str, params: tuple = ()) -> dict | None:
        """Execute query and return first row as dict."""
        if not self.db or not self.db.conn:
            return None
        cursor = self.db.conn.cursor()
        cursor.execute(sql, params)
        row = cursor.fetchone()
        return dict(row) if row else None
    
    def _load_person_data(self) -> None:
        """Load person data from database."""
        row: dict | None = self._query_one("SELECT * FROM Person WHERE id = ?", (self.person_id,))
        if not row:
            return
        
        from models.person import Person
        
        self.person = Person(
            id=row.get('id'),
            first_name=row.get('first_name', ''),
            middle_name=row.get('middle_name', ''),
            last_name=row.get('last_name', ''),
            maiden_name=row.get('maiden_name') or '',
            nickname=row.get('nickname', ''),
            gender=row.get('gender', 'Unknown'),
            birth_year=row.get('birth_year'),
            birth_month=row.get('birth_month'),
            birth_day=row.get('birth_day'),
            death_year=row.get('death_year'),
            death_month=row.get('death_month'),
            death_day=row.get('death_day'),
            arrival_year=row.get('arrival_year'),
            arrival_month=row.get('arrival_month'),
            arrival_day=row.get('arrival_day'),
            moved_out_year=row.get('moved_out_year'),
            moved_out_month=row.get('moved_out_month'),
            moved_out_day=row.get('moved_out_day'),
            father_id=row.get('father_id'),
            mother_id=row.get('mother_id'),
            family_id=row.get('family_id'),
            dynasty_id=row.get('dynasty_id', 1),
            is_founder=bool(row.get('is_founder', 0)),
            education=row.get('education', 0),
            notes=row.get('notes', '')
        )
    
    def _load_portrait(self) -> None:
        """Load portrait image from database if exists."""
        row: dict | None = self._query_one(
            "SELECT image_path FROM Portrait WHERE person_id = ? AND is_primary = 1 ORDER BY display_order LIMIT 1",
            (self.person_id,)
        )
        
        if row and row['image_path']:
            pixmap: QPixmap = QPixmap(row['image_path'])
            if not pixmap.isNull():
                self.portrait_pixmap = pixmap.scaled(
                    self.PHOTO_SIZE, 
                    self.PHOTO_SIZE, 
                    Qt.AspectRatioMode.KeepAspectRatio, 
                    Qt.TransformationMode.SmoothTransformation
                )
    
    def _load_favorite_status(self) -> None:
        """Load favorite status from database."""
        row: dict | None = self._query_one("SELECT is_favorite FROM Person WHERE id = ?", (self.person_id,))
        if row:
            self.is_favorite = bool(row['is_favorite'])
    
    # ========================================
    # Helper Methods
    # ========================================
    
    def _calculate_box_width(self) -> float:
        """Return fixed box width."""
        return self.BOX_MIN_WIDTH

    def _get_display_name_lines(self) -> tuple[str, str | None]:
        """Get name text, split across two lines if exceeds 32 characters."""
        if not self.person:
            return ("", None)
        
        full_name: str = f"{self.person.first_name} {self.person.last_name}"
        
        if len(full_name) <= 32:
            return (full_name, None)
        
        metrics: QFontMetrics = QFontMetrics(self._font_name_bold)
        gear_space: int = 30
        available_width: float = self.BOX_MIN_WIDTH - (self.PHOTO_SIZE + 15 + self.TEXT_PADDING) - gear_space
        
        first_name: str = self.person.first_name
        last_name: str = self.person.last_name
        
        if metrics.horizontalAdvance(first_name) <= available_width:
            return (first_name, last_name)
        
        for i in range(len(first_name), 0, -1):
            truncated: str = first_name[:i] + "..."
            if metrics.horizontalAdvance(truncated) <= available_width:
                return (truncated, last_name)
        
        return (first_name[:10] + "...", last_name)
    
    def _get_birth_display_text(self) -> str:
        """Get birth date display text with month if available."""
        if not self.person:
            return "?"
        return self.person.get_birth_date_string()
    
    def _get_death_display_text(self) -> str:
        """Get death date display text with month if available."""
        if not self.person:
            return ""
        
        if not self.person.is_deceased:
            return ""
        
        return self.person.get_death_date_string()

    def _is_sick(self) -> bool:
        """Check if person has any active illness events."""
        if not self.db or not self.db.conn:
            return False
        
        cursor = self.db.conn.cursor()
        cursor.execute(
            "SELECT COUNT(*) as count FROM Event WHERE person_id = ? AND event_type = 'Illness' AND (end_year IS NULL OR end_year >= ?)",
            (self.person_id, self.current_year)
        )
        row = cursor.fetchone()
        return row['count'] > 0 if row else False
    
    def _is_immigrant(self) -> bool:
        """Check if person immigrated."""
        if not self.person:
            return False
        has_arrival_date: bool = self.person.arrival_year is not None
        is_not_founder: bool = not self.person.is_founder
        return has_arrival_date and is_not_founder
    
    def _get_gender_symbol(self) -> str:
        """Get the gender symbol for display."""
        if not self.person:
            return "âš²"
        return {"Male": "â™‚", "Female": "â™€"}.get(self.person.gender, "âš²")
    
    def _get_age_text(self) -> str:
        """Generate age text like 'd. 64 (now 108)' or 'Age: 45'."""
        if not self.person or not self.person.birth_year:
            return ""
        
        is_deceased: bool = self.person.is_deceased
        has_death_year: bool = self.person.death_year is not None
        
        if is_deceased and has_death_year:
            age_at_death: int | None = self.person.get_age_at_death()
            if age_at_death is None:
                return "d. ?"
            would_be_age: int = self.current_year - self.person.birth_year
            return f"d. {age_at_death} (now {would_be_age})"
        
        current_age: int | None = self.person.get_age(self.current_year)
        return f"Age: {current_age}" if current_age else ""
    
    def _get_star_rect(self) -> QRectF:
        """Get clickable area for favorite star."""
        star_x: float = self.box_width - 55
        star_y: float = 10
        return QRectF(star_x, star_y, self.FAVORITE_STAR_SIZE, self.FAVORITE_STAR_SIZE)
    
    def _get_name_rect(self) -> QRectF:
        """Get hoverable area for tooltip trigger."""
        return QRectF(0, 0, self.box_width, self.box_height)
    
    def _is_mouse_near_tooltip(self, mouse_pos: QPointF) -> bool:
        """Check if mouse is in grace area between box and tooltip."""
        if not self._tooltip_panel:
            return False
        
        grace_width: int = 30
        grace_rect: QRectF = QRectF(
            self.box_width - grace_width,
            0,
            self.TOOLTIP_OFFSET_X + grace_width * 2,
            self.box_height
        )
        return grace_rect.contains(mouse_pos)
    
    def _stop_tooltip_timer(self) -> None:
        """Stop tooltip delay timer."""
        self._tooltip_delay_timer.stop()

    def _format_date_for_box(self, year: int | None, month: int | None) -> str:
        """Format date for PersonBox display with full month name."""
        if year is None:
            return "?"
        
        month_names: dict[int, str] = {
            1: 'January', 2: 'February', 3: 'March', 4: 'April',
            5: 'May', 6: 'June', 7: 'July', 8: 'August',
            9: 'September', 10: 'October', 11: 'November', 12: 'December'
        }
        
        if month:
            month_name: str = month_names.get(month, '')
            return f"{month_name} {year}"
        else:
            return str(year)
    
    # ========================================
    # Painting
    # ========================================
    
    def paint(self, painter: QPainter, option, widget=None) -> None:
        """Draw the person box with all visual elements."""
        if not self.person:
            return
        
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        border_color: QColor = self.COLOR_DECEASED if self.person.is_deceased else self.COLOR_LIVING
        painter.setPen(QPen(border_color, self.BORDER_WIDTH))
        painter.setBrush(QBrush(self.COLOR_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.box_width, self.box_height), 
            self.CORNER_RADIUS, 
            self.CORNER_RADIUS
        )
        
        photo_rect: QRectF = QRectF(
            self.BORDER_WIDTH, 
            self.BORDER_WIDTH, 
            self.PHOTO_SIZE + 10, 
            self.box_height - 2 * self.BORDER_WIDTH
        )
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(QColor(245, 245, 245)))
        
        path: QPainterPath = QPainterPath()
        path.addRoundedRect(photo_rect, self.CORNER_RADIUS, self.CORNER_RADIUS)
        painter.setClipPath(path)
        painter.drawRect(photo_rect)
        painter.setClipping(False)
        
        if self.portrait_pixmap:
            x_offset: float = (self.PHOTO_SIZE + 10 - self.portrait_pixmap.width()) / 2 + self.BORDER_WIDTH
            y_offset: float = (self.box_height - self.portrait_pixmap.height()) / 2
            painter.drawPixmap(int(x_offset), int(y_offset), self.portrait_pixmap)
        else:
            self._draw_placeholder_portrait(painter, photo_rect)
        
        separator_x: float = self.PHOTO_SIZE + 15
        painter.setPen(QPen(self.COLOR_SEPARATOR, 1))
        painter.drawLine(
            int(separator_x), 
            int(self.BORDER_WIDTH + 5), 
            int(separator_x), 
            int(self.box_height - self.BORDER_WIDTH - 5)
        )
        
        self._draw_text_content(painter, separator_x + self.TEXT_PADDING)
        
        should_draw_star: bool = self._is_hovered or self.is_favorite
        if should_draw_star:
            self._draw_favorite_star(painter)
    
    def _draw_placeholder_portrait(self, painter: QPainter, photo_rect: QRectF) -> None:
        """Draw silhouette placeholder when no portrait exists."""
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(QColor(200, 200, 200)))
        
        center_x: float = photo_rect.center().x()
        center_y: float = photo_rect.top() + 30
        painter.drawEllipse(QPointF(center_x, center_y), 15, 15)
        
        body_width: float = 30
        body_height: float = 35
        body_x: float = center_x - body_width / 2
        body_y: float = center_y + 18
        painter.drawRoundedRect(QRectF(body_x, body_y, body_width, body_height), 5, 5)
        
        painter.setFont(QFont("Segoe UI", 7))
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        text_rect: QRectF = QRectF(photo_rect.left() + 5, photo_rect.top() + 85, photo_rect.width() - 10, 25)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, "Click to add\nportrait")
    
    def _draw_text_content(self, painter: QPainter, start_x: float) -> None:
        """Draw all text content on right side of box."""
        if not self.person:
            return
        
        icon_y: float = 25
        icon_x: float = start_x
        
        painter.setFont(self._font_icon)
        painter.setPen(QPen(self.COLOR_TEXT))
        
        icon_conditions: list[tuple[bool, str]] = [
            (self.person.is_founder, "ðŸƒ"),
            (self._is_immigrant(), "â†“"),
            (self.person.is_deceased, "ðŸ’€"),
            (self._is_sick(), "ðŸ¤’")
        ]
        
        for condition, icon in icon_conditions:
            if condition:
                painter.drawText(int(icon_x), int(icon_y), icon)
                icon_x += 20
        
        painter.drawText(int(self.box_width - 30), int(icon_y), "âš™")
        
        name_line1, name_line2 = self._get_display_name_lines()
        name_y: float = 50
        
        painter.setFont(self._font_name_bold)
        painter.drawText(int(start_x), int(name_y), name_line1)
        
        if name_line2:
            name_y += 18
            painter.drawText(int(start_x), int(name_y), name_line2)
        
        painter.setFont(self._font_normal)
        painter.setPen(QPen(QColor(100, 100, 100)))
        
        gender_y: float = name_y + 18
        gender_text: str = f"{self._get_gender_symbol()} {self.person.gender}"
        painter.drawText(int(start_x), int(gender_y), gender_text)
        
        current_y: float = gender_y + 16
        painter.setFont(QFont("Segoe UI", 9))
        painter.setPen(QPen(self.COLOR_TEXT))
        
        has_arrival: bool = self.person.arrival_year is not None
        
        if has_arrival:
            arrival_text: str = self._format_date_for_box(
                self.person.arrival_year,
                self.person.arrival_month
            )
            
            has_departure: bool = self.person.moved_out_year is not None
            
            if has_departure:
                departure_text: str = self._format_date_for_box(
                    self.person.moved_out_year,
                    self.person.moved_out_month
                )
                painter.drawText(int(start_x), int(current_y), f"A: {arrival_text} | D: {departure_text}")
            else:
                painter.drawText(int(start_x), int(current_y), f"A: {arrival_text}")
            
            current_y += 14

        birth_text: str = self._format_date_for_box(
            self.person.birth_year,
            self.person.birth_month
        )

        if self.person.is_deceased:
            death_text: str = self._format_date_for_box(
                self.person.death_year,
                self.person.death_month
            )
            life_dates: str = f"b. {birth_text} - d. {death_text}"
        else:
            life_dates: str = f"b. {birth_text} -"

        painter.drawText(int(start_x), int(current_y), life_dates)
        current_y += 14

        painter.setPen(QPen(QColor(100, 100, 100)))

        if self.person.is_deceased:
            age_at_death: int | None = self.person.get_age_at_death()
            if age_at_death is not None:
                painter.drawText(int(start_x), int(current_y), f"Died at {age_at_death} years old")
                current_y += 14
            
            if self.person.birth_year:
                years_since_birth: int = self.current_year - self.person.birth_year
                painter.drawText(int(start_x), int(current_y), f"Age: {years_since_birth}")
        else:
            current_age: int | None = self.person.get_age(self.current_year)
            if current_age is not None:
                painter.drawText(int(start_x), int(current_y), f"Age: {current_age}")
            
    def _draw_favorite_star(self, painter: QPainter) -> None:
        """Draw favorite star (filled if favorite, hollow if hovering)."""
        painter.setFont(QFont("Segoe UI Emoji", 16))
        
        star_x: float = self.box_width - 55
        star_y: float = 10
        
        if self.is_favorite:
            painter.setPen(QPen(self.COLOR_FAVORITE_STAR))
            painter.drawText(int(star_x), int(star_y + 15), "â˜…")
        elif self._is_star_hovered or self._is_hovered:
            painter.setPen(QPen(self.COLOR_FAVORITE_HOVER))
            painter.drawText(int(star_x), int(star_y + 15), "â˜†")
    
    # ========================================
    # Tooltip Management
    # ========================================
    
    def _show_enhanced_tooltip(self) -> None:
        """Show enhanced tooltip panel next to person box."""
        tooltip_already_exists: bool = self._tooltip_panel is not None
        no_scene_available: bool = not self.scene()
        
        if tooltip_already_exists or no_scene_available:
            return
        
        from views.tree_view.enhanced_tooltip_panel import EnhancedTooltipPanel
        
        self._tooltip_panel = EnhancedTooltipPanel(self.person_id, self.db, self.current_year)
        
        if not self._tooltip_panel:
            return
        
        self._tooltip_panel.parent_person_box = self
        self._tooltip_panel.manually_moved.connect(self._on_tooltip_manually_moved)
        self._tooltip_panel.closed.connect(self._on_tooltip_closed)
        
        tooltip_x: float = self.pos().x() + self.box_width + self.TOOLTIP_OFFSET_X
        tooltip_y: float = self.pos().y()
        self._tooltip_panel.setPos(tooltip_x, tooltip_y)
        
        self.scene().addItem(self._tooltip_panel)

    def _on_tooltip_manually_moved(self) -> None:
        """Handle tooltip being manually repositioned by user."""
        self._tooltip_manually_positioned = True
    
    def _on_tooltip_closed(self) -> None:
        """Handle tooltip being closed."""
        self._tooltip_panel = None
    
    def _hide_enhanced_tooltip(self) -> None:
        """Remove enhanced tooltip from scene."""
        if self._tooltip_panel and self.scene():
            self.scene().removeItem(self._tooltip_panel)
            self._tooltip_panel = None

    def _check_hide_tooltip(self) -> None:
        """Check if tooltip should be hidden after leaving person box."""
        if not self._tooltip_panel:
            return
        
        tooltip_is_hovered: bool = self._tooltip_panel.is_hovered
        tooltip_is_locked: bool = self._tooltip_panel.is_locked
        
        should_keep_tooltip: bool = tooltip_is_hovered or tooltip_is_locked
        
        if not should_keep_tooltip:
            self._hide_enhanced_tooltip()
    
    # ========================================
    # Qt Event Handlers
    # ========================================
    
    def boundingRect(self) -> QRectF:
        """Define widget bounds for Qt rendering system."""
        return QRectF(0, 0, self.box_width, self.box_height)
    
    def hoverEnterEvent(self, event) -> None:
        """Start tooltip delay timer when mouse enters box."""
        self._is_hovered = True
        self._tooltip_delay_timer.start(self.TOOLTIP_DELAY)
        self.update()
        super().hoverEnterEvent(event)
    
    def hoverMoveEvent(self, event) -> None:
        """Track hover state for name and star areas."""
        mouse_position: QPointF = event.pos()
        
        self._is_name_hovered = self._get_name_rect().contains(mouse_position)
        self._is_star_hovered = self._get_star_rect().contains(mouse_position)
        
        mouse_left_box: bool = not self._is_name_hovered
        tooltip_exists: bool = self._tooltip_panel is not None
        tooltip_unlocked: bool = not (self._tooltip_panel.is_locked if self._tooltip_panel else False)
        mouse_not_near_tooltip: bool = not self._is_mouse_near_tooltip(mouse_position)
        
        should_hide_tooltip: bool = (
            mouse_left_box and 
            tooltip_exists and 
            tooltip_unlocked and 
            mouse_not_near_tooltip
        )
        
        if should_hide_tooltip:
            self._hide_enhanced_tooltip()
        
        self.update()
        super().hoverMoveEvent(event)
    
    def hoverLeaveEvent(self, event) -> None:
        """Stop timers and potentially hide tooltip when mouse leaves."""
        self._is_hovered = False
        self._is_name_hovered = False
        self._is_star_hovered = False
        self._stop_tooltip_timer()
        
        tooltip_exists: bool = self._tooltip_panel is not None
        tooltip_is_unlocked: bool = not (self._tooltip_panel.is_locked if self._tooltip_panel else True)
        
        if tooltip_exists and tooltip_is_unlocked:
            QTimer.singleShot(200, self._check_hide_tooltip)
        
        self.update()
        super().hoverLeaveEvent(event)
    
    def mousePressEvent(self, event) -> None:
        """Handle clicks on star (favorite toggle) or box (drag start)."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if not is_left_click:
            super().mousePressEvent(event)
            return
        
        click_position: QPointF = event.pos()
        clicked_on_star: bool = self._get_star_rect().contains(click_position)
        
        if clicked_on_star:
            self.is_favorite = not self.is_favorite
            self.favorite_toggled.emit(self.person_id, self.is_favorite)
            self._save_favorite_status()
            self.update()
            return
        
        self._is_dragging = True
        self._drag_start_pos = click_position
        self.person_selected.emit(self.person_id)
        self._stop_tooltip_timer()
        
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:
        """Handle dragging - move box and tooltip together if not manually positioned."""
        if not self._is_dragging:
            super().mouseMoveEvent(event)
            return
        
        self._stop_tooltip_timer()
        
        tooltip_exists: bool = self._tooltip_panel is not None

        if tooltip_exists and self._tooltip_panel:
            expected_x: float = self.pos().x() + self.box_width + self.TOOLTIP_OFFSET_X
            expected_y: float = self.pos().y()
            
            actual_x: float = self._tooltip_panel.pos().x()
            actual_y: float = self._tooltip_panel.pos().y()
            
            position_tolerance: int = 10
            x_difference: float = abs(actual_x - expected_x)
            y_difference: float = abs(actual_y - expected_y)
            
            is_in_default_position: bool = x_difference <= position_tolerance and y_difference <= position_tolerance
            should_move_tooltip: bool = is_in_default_position or not self._tooltip_manually_positioned
            
            if should_move_tooltip:
                self._tooltip_panel.setPos(expected_x, expected_y)
        
        super().mouseMoveEvent(event)
        
    def mouseReleaseEvent(self, event) -> None:
        """End drag operation."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        if is_left_click:
            self._is_dragging = False
        super().mouseReleaseEvent(event)
    
    def mouseDoubleClickEvent(self, event) -> None:
        """Emit signal on double-click."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        if is_left_click:
            self.person_double_clicked.emit(self.person_id)
        super().mouseDoubleClickEvent(event)
    
    def _save_favorite_status(self) -> None:
        """Persist favorite status to database."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        favorite_value: int = 1 if self.is_favorite else 0
        cursor.execute(
            "UPDATE Person SET is_favorite = ? WHERE id = ?",
            (favorite_value, self.person_id)
        )
        self.db.conn.commit()

>> ðŸ“‹ views\tree_view\relationship_line.py (7 code lines)
"""Visual line connecting related people in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class RelationshipLine(QGraphicsWidget):
    """Line connecting parent to child or spouse to spouse."""

    def __init__(
        self,
        start_person_id: int,
        end_person_id: int,
        line_type: str,  # "parent", "marriage", "sibling"
    ) -> None:
        """Initialize the relationship line widget."""
        super().__init__()
        self.start_person_id = start_person_id
        self.end_person_id = end_person_id
        self.line_type = line_type
        # TODO: Draw line between two PersonBox widgets
        # TODO: Use different styles for different line types
        # TODO: Update position when PersonBox moves
        # TODO: Add hover highlighting
        pass

    def update_endpoints(self) -> None:
        """Recalculate line position based on connected boxes."""
        # TODO: Get current positions of connected PersonBox widgets
        # TODO: Redraw line with new coordinates
        pass


>> ðŸ“‹ views\tree_view\tree_canvas.py (1 code lines)
"""Main canvas for displaying the family tree."""

from PySide6.QtWidgets import QGraphicsView


class TreeCanvas(QGraphicsView):
    """Scrollable, zoomable canvas for displaying the family tree."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the tree canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Implement zoom functionality
        # TODO: Implement pan functionality
        # TODO: Add minimap (optional)
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WIDGETS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ widgets\__init__.py (0 code lines)


>> âœ… widgets\date_picker.py (82 code lines)
"""Custom date picker widget supporting flexible precision."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, 
    QSpinBox, QLabel, QCheckBox
)
from PySide6.QtCore import Signal

from utils.date_formatter import DateFormatter

if TYPE_CHECKING:
    pass


class MonthSpinBox(QSpinBox):
    """Custom spinbox that displays month names instead of just numbers."""
    
    yearAdjustNeeded: Signal = Signal(int)
    
    MONTH_MIN: int = 1
    MONTH_MAX: int = 12
    MONTH_JANUARY_NUM: int = 1
    MONTH_DECEMBER_NUM: int = 12
    DEFAULT_MONTH: int = 1
    
    DISPLAY_FORMAT: str = "{name} ({num})"
    TEXT_SEPARATOR_OPEN: str = "("
    TEXT_SEPARATOR_CLOSE: str = ")"
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize month spinbox."""
        super().__init__(parent)
        self.setWrapping(True)
    
    def textFromValue(self, value: int) -> str:
        """Convert internal value (1-12) to display text."""
        if not (self.MONTH_MIN <= value <= self.MONTH_MAX):
            return str(value)
        
        month_name: str | None = DateFormatter.MONTHS_FULL.get(value)
        if month_name is None:
            return str(value)
        
        return self.DISPLAY_FORMAT.format(name=month_name, num=value)
    
    def valueFromText(self, text: str) -> int:
        """Convert display text back to internal value (1-12)."""
        value: int | None = self._extract_number_from_text(text)
        if value is not None:
            return value
        
        value = self._match_month_name(text)
        if value is not None:
            return value
        
        value = self._parse_as_integer(text)
        return value if value is not None else self.DEFAULT_MONTH
    
    def _extract_number_from_text(self, text: str) -> int | None:
        """Extract month number from formatted text like 'January (1)'."""
        if self.TEXT_SEPARATOR_OPEN not in text or self.TEXT_SEPARATOR_CLOSE not in text:
            return None
        
        try:
            number_part: str = text.split(self.TEXT_SEPARATOR_OPEN)[1].split(self.TEXT_SEPARATOR_CLOSE)[0]
            return int(number_part)
        except (ValueError, IndexError):
            return None
    
    def _match_month_name(self, text: str) -> int | None:
        """Match text against month names using DateFormatter."""
        return DateFormatter.month_name_to_int(text.strip())
    
    def _parse_as_integer(self, text: str) -> int | None:
        """Try to parse text as integer."""
        try:
            return int(text)
        except ValueError:
            return None
    
    def stepBy(self, steps: int) -> None:
        """Override step behavior to handle year adjustment on wrap."""
        old_value: int = self.value()
        super().stepBy(steps)
        new_value: int = self.value()
        
        if self._wrapped_forward(old_value, new_value, steps):
            self.yearAdjustNeeded.emit(1)
        elif self._wrapped_backward(old_value, new_value, steps):
            self.yearAdjustNeeded.emit(-1)
    
    def _wrapped_forward(self, old_value: int, new_value: int, steps: int) -> bool:
        """Check if month wrapped forward from December to January."""
        return steps > 0 and old_value == self.MONTH_DECEMBER_NUM and new_value == self.MONTH_JANUARY_NUM
    
    def _wrapped_backward(self, old_value: int, new_value: int, steps: int) -> bool:
        """Check if month wrapped backward from January to December."""
        return steps < 0 and old_value == self.MONTH_JANUARY_NUM and new_value == self.MONTH_DECEMBER_NUM


class DatePicker(QWidget):
    """Widget for entering dates with flexible precision (Year + Month)."""
    
    dateChanged: Signal = Signal()
    
    LABEL_YEAR: str = "Year"
    LABEL_MONTH: str = "Month"
    CHECKBOX_UNKNOWN: str = "Unknown"
    
    YEAR_MIN_DEFAULT: int = 1500
    YEAR_MAX_DEFAULT: int = 2000
    YEAR_DEFAULT: int = 1721
    
    MONTH_MIN: int = 1
    MONTH_MAX: int = 12
    MONTH_DEFAULT: int = 1
    
    LAYOUT_MARGIN: int = 0
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the date picker widget."""
        super().__init__(parent)
        
        self.min_year: int | None = None
        self.min_month: int | None = None
        
        self._setup_ui()
        self._update_month_state()
    
    def _setup_ui(self) -> None:
        """Create the date picker layout."""
        main_layout: QHBoxLayout = QHBoxLayout(self)
        main_layout.setContentsMargins(self.LAYOUT_MARGIN, self.LAYOUT_MARGIN, self.LAYOUT_MARGIN, self.LAYOUT_MARGIN)
        
        year_layout: QVBoxLayout = self._create_year_section()
        month_layout: QVBoxLayout = self._create_month_section()
        
        main_layout.addLayout(year_layout)
        main_layout.addLayout(month_layout)
        main_layout.addStretch()
    
    def _create_year_section(self) -> QVBoxLayout:
        """Create year input section."""
        year_layout: QVBoxLayout = QVBoxLayout()
        
        year_label: QLabel = QLabel(self.LABEL_YEAR, self)
        
        self.year_spin: QSpinBox = QSpinBox(self)
        self.year_spin.setRange(self.YEAR_MIN_DEFAULT, self.YEAR_MAX_DEFAULT)
        self.year_spin.setValue(self.YEAR_DEFAULT)
        self.year_spin.valueChanged.connect(self._on_date_changed)
        
        year_layout.addWidget(year_label)
        year_layout.addWidget(self.year_spin)
        
        return year_layout
    
    def _create_month_section(self) -> QVBoxLayout:
        """Create month input section with unknown checkbox."""
        month_layout: QVBoxLayout = QVBoxLayout()
        
        month_label: QLabel = QLabel(self.LABEL_MONTH, self)
        month_controls: QHBoxLayout = self._create_month_controls()
        
        month_layout.addWidget(month_label)
        month_layout.addLayout(month_controls)
        
        return month_layout
    
    def _create_month_controls(self) -> QHBoxLayout:
        """Create month spinbox and unknown checkbox."""
        month_controls: QHBoxLayout = QHBoxLayout()
        
        self.month_spin: MonthSpinBox = MonthSpinBox(self)
        self.month_spin.setRange(self.MONTH_MIN, self.MONTH_MAX)
        self.month_spin.setValue(self.MONTH_DEFAULT)
        self.month_spin.valueChanged.connect(self._on_date_changed)
        self.month_spin.yearAdjustNeeded.connect(self._on_year_adjust)
        
        self.unknown_check: QCheckBox = QCheckBox(self.CHECKBOX_UNKNOWN, self)
        self.unknown_check.setChecked(False)
        self.unknown_check.stateChanged.connect(self._on_unknown_toggled)
        
        month_controls.addWidget(self.month_spin)
        month_controls.addWidget(self.unknown_check)
        
        return month_controls
    
    def set_min_date(self, min_year: int, min_month: int | None = None) -> None:
        """Set minimum allowable date."""
        self.min_year = min_year
        self.min_month = min_month if min_month else self.MONTH_MIN
        
        if self.min_year:
            self.year_spin.setMinimum(self.min_year)
    
    def _on_year_adjust(self, direction: int) -> None:
        """Adjust year when month wraps around."""
        current_year: int = self.year_spin.value()
        new_year: int = current_year + direction
        
        if self.year_spin.minimum() <= new_year <= self.year_spin.maximum():
            self.year_spin.setValue(new_year)
    
    def _on_unknown_toggled(self) -> None:
        """Handle unknown checkbox state change."""
        self._update_month_state()
        self._on_date_changed()
    
    def _update_month_state(self) -> None:
        """Enable or disable month spinbox based on unknown checkbox."""
        is_unknown: bool = self.unknown_check.isChecked()
        self.month_spin.setEnabled(not is_unknown)
    
    def _on_date_changed(self) -> None:
        """Internal handler when date changes - emits signal."""
        self.dateChanged.emit()
    
    def get_date(self) -> tuple[int, int | None]:
        """Get the selected date as (year, month) tuple."""
        year: int = self.year_spin.value()
        
        if self.unknown_check.isChecked():
            return (year, None)
        
        return (year, self.month_spin.value())
    
    def set_date(self, year: int, month: int | str | None = None) -> None:
        """Set the date to specific values."""
        self.year_spin.setValue(year)
        
        if month is None or month == "":
            self.unknown_check.setChecked(True)
            self._update_month_state()
            return
        
        self.unknown_check.setChecked(False)
        
        if isinstance(month, str):
            self._set_month_from_string(month)
        else:
            self.month_spin.setValue(int(month))
        
        self._update_month_state()
    
    def _set_month_from_string(self, month_name: str) -> None:
        """Set month value from string name."""
        month_num: int | None = DateFormatter.month_name_to_int(month_name)
        
        if month_num is not None:
            self.month_spin.setValue(month_num)
        else:
            self.unknown_check.setChecked(True)
    
    def clear(self) -> None:
        """Reset to default values (1721, Unknown)."""
        self.set_date(self.YEAR_DEFAULT, None)

>> ðŸ“‹ widgets\extended_details_panel.py (2 code lines)
"""Panel widget for displaying detailed person information."""

from PySide6.QtWidgets import QWidget


class ExtendedDetailsPanel(QWidget):
    """Panel showing comprehensive person details and relationships."""

    def __init__(self, person_id: int | None = None) -> None:
        """Initialize the extended details panel."""
        super().__init__()
        self.person_id = person_id
        # TODO: Display full person information
        # TODO: Show all marriages with dates
        # TODO: Show all children with clickable links
        # TODO: Show all events in chronological order
        # TODO: Show portrait gallery
        # TODO: Add edit button for each section
        # TODO: Add relationship path calculator
        pass

    def set_person(self, person_id: int) -> None:
        """Update panel to show different person."""
        # TODO: Clear current display
        # TODO: Load new person data
        # TODO: Refresh all sections
        pass


>> âœ… widgets\person_selector.py (73 code lines)
"""Widget for selecting a person from the database with autocomplete."""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtWidgets import QWidget, QLineEdit, QVBoxLayout, QCompleter
from PySide6.QtCore import Signal, Qt, QStringListModel, QSortFilterProxyModel, QModelIndex, QPersistentModelIndex

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from models.person import Person

from database.person_repository import PersonRepository
from utils.text_normalizer import TextNormalizer


class AccentInsensitiveProxyModel(QSortFilterProxyModel):
    """Proxy model that performs accent-insensitive filtering."""
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the proxy model."""
        super().__init__(parent)
        self.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
    
    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex | QPersistentModelIndex) -> bool:
        """Check if row matches filter using accent-insensitive comparison."""
        source_model = self.sourceModel()
        if not source_model:
            return False
        
        index: QModelIndex = source_model.index(source_row, 0, source_parent)
        data: str = source_model.data(index, Qt.ItemDataRole.DisplayRole)
        
        if not data:
            return False
        
        filter_text: str = self.filterRegularExpression().pattern()
        if not filter_text:
            return True
        
        normalized_data: str = TextNormalizer.normalize_for_search(data)
        normalized_filter: str = TextNormalizer.normalize_for_search(filter_text)
        
        return normalized_filter in normalized_data


class PersonSelector(QWidget):
    """Autocomplete text field for selecting a person from the database."""
    
    # ------------------------------------------------------------------
    # Constants
    # ------------------------------------------------------------------
    
    # UI Text
    PLACEHOLDER_TEXT: str = "Type to search for a person..."
    
    # Date Display Formats
    DATE_FORMAT_LIFESPAN: str = "{birth}-{death}"
    DATE_FORMAT_BIRTH_ONLY: str = "b. {year}"
    DATE_FORMAT_UNKNOWN: str = "dates unknown"
    DATE_PLACEHOLDER_UNKNOWN: str = "?"
    
    # Person Display Format
    PERSON_DISPLAY_FORMAT: str = "{name} ({dates})"
    
    # Gender Filter Values
    GENDER_UNKNOWN: str = "Unknown"
    
    # Completer Settings
    COMPLETER_MAX_VISIBLE: int = 10
    
    # Layout
    LAYOUT_MARGIN: int = 0
    
    # ------------------------------------------------------------------
    # Signals
    # ------------------------------------------------------------------
    
    personSelected: Signal = Signal(int)
    selectionCleared: Signal = Signal()
    
    # ------------------------------------------------------------------
    # Initialization
    # ------------------------------------------------------------------
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize the person selector widget."""
        super().__init__(parent)
        
        self.db_manager: DatabaseManager = db_manager
        self.person_repo: PersonRepository = PersonRepository(db_manager)
        
        self.gender_filter: str | None = None
        self._name_to_id: dict[str, int] = {}
        self._selected_person_id: int | None = None
        
        self._setup_ui()
        self._load_people()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create the autocomplete text field."""
        layout: QVBoxLayout = QVBoxLayout(self)
        layout.setContentsMargins(
            self.LAYOUT_MARGIN,
            self.LAYOUT_MARGIN,
            self.LAYOUT_MARGIN,
            self.LAYOUT_MARGIN
        )
        
        self.text_field: QLineEdit = self._create_text_field()
        self.completer: QCompleter = self._create_completer()
        
        self.text_field.setCompleter(self.completer)
        
        self._connect_signals()
        
        layout.addWidget(self.text_field)
    
    def _create_text_field(self) -> QLineEdit:
        """Create the text input field."""
        text_field: QLineEdit = QLineEdit(self)
        text_field.setPlaceholderText(self.PLACEHOLDER_TEXT)
        text_field.setClearButtonEnabled(True)
        return text_field
    
    def _create_completer(self) -> QCompleter:
        """Create the autocomplete completer with accent-insensitive filtering."""
        completer: QCompleter = QCompleter(self)
        completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        completer.setFilterMode(Qt.MatchFlag.MatchContains)
        completer.setMaxVisibleItems(self.COMPLETER_MAX_VISIBLE)
        
        self.proxy_model: AccentInsensitiveProxyModel = AccentInsensitiveProxyModel(self)
        completer.setModel(self.proxy_model)
        
        return completer
    
    def _connect_signals(self) -> None:
        """Connect widget signals to handlers."""
        self.completer.activated.connect(self._on_person_selected)
        self.text_field.textChanged.connect(self._on_text_changed)
    
    # ------------------------------------------------------------------
    # Data Loading
    # ------------------------------------------------------------------
    
    def _load_people(self) -> None:
        """Load all people from database and populate completer."""
        if not self.db_manager.is_open:
            return
        
        all_people: list[Person] = self.person_repo.get_all()
        filtered_people: list[Person] = self._apply_gender_filter(all_people)
        
        self._name_to_id.clear()
        display_names: list[str] = self._build_display_names(filtered_people)
        display_names.sort()
        
        self._update_completer_model(display_names)
    
    def _apply_gender_filter(self, people: list[Person]) -> list[Person]:
        """Filter people by gender if filter is set."""
        if not self.gender_filter:
            return people
        
        return [
            p for p in people
            if p.gender in (self.gender_filter, self.GENDER_UNKNOWN)
        ]
    
    def _build_display_names(self, people: list[Person]) -> list[str]:
        """Build list of display names for people."""
        display_names: list[str] = []
        
        for person in people:
            if person.id is None:
                continue
            
            display_name: str = self._format_person_display(person)
            display_names.append(display_name)
            self._name_to_id[display_name] = person.id
        
        return display_names
    
    def _update_completer_model(self, display_names: list[str]) -> None:
        """Update the completer's data model with proxy for accent-insensitive search."""
        source_model: QStringListModel = QStringListModel(display_names)
        self.proxy_model.setSourceModel(source_model)
    
    # ------------------------------------------------------------------
    # Display Formatting
    # ------------------------------------------------------------------
    
    def _format_person_display(self, person: Person) -> str:
        """Format a person's info for display in the dropdown."""
        name: str = person.display_name
        date_str: str = self._format_date_info(person)
        
        return self.PERSON_DISPLAY_FORMAT.format(name=name, dates=date_str)
    
    def _format_date_info(self, person: Person) -> str:
        """Format date information for person display."""
        if person.death_year:
            return self._format_lifespan(person)
        
        if person.birth_year:
            return self.DATE_FORMAT_BIRTH_ONLY.format(year=person.birth_year)
        
        return self.DATE_FORMAT_UNKNOWN
    
    def _format_lifespan(self, person: Person) -> str:
        """Format lifespan string for deceased person."""
        birth: str = str(person.birth_year) if person.birth_year else self.DATE_PLACEHOLDER_UNKNOWN
        death: str = str(person.death_year)
        
        return self.DATE_FORMAT_LIFESPAN.format(birth=birth, death=death)
    
    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------
    
    def _on_person_selected(self, display_name: str) -> None:
        """Handle person selection from dropdown."""
        person_id: int | None = self._name_to_id.get(display_name)
        
        if person_id is None:
            return
        
        self._selected_person_id = person_id
        self.personSelected.emit(person_id)
    
    def _on_text_changed(self, text: str) -> None:
        """Handle text field changes."""
        if not text.strip():
            self._clear_selection()
    
    def _clear_selection(self) -> None:
        """Clear the current selection."""
        self._selected_person_id = None
        self.selectionCleared.emit()
    
    # ------------------------------------------------------------------
    # Public Interface
    # ------------------------------------------------------------------
    
    def get_person_id(self) -> int | None:
        """Get the currently selected person's ID."""
        return self._selected_person_id
    
    def set_person(self, person_id: int | None) -> None:
        """Set the selected person by ID."""
        if person_id is None:
            self.clear()
            return
        
        display_name: str | None = self._find_display_name_for_id(person_id)
        
        if display_name:
            self.text_field.setText(display_name)
            self._selected_person_id = person_id
        else:
            self.clear()
    
    def _find_display_name_for_id(self, person_id: int) -> str | None:
        """Find display name for a given person ID."""
        for display_name, pid in self._name_to_id.items():
            if pid == person_id:
                return display_name
        return None
    
    def clear(self) -> None:
        """Clear the selection."""
        self.text_field.clear()
        self._selected_person_id = None
        self.selectionCleared.emit()
    
    def refresh(self) -> None:
        """Reload people from database (call after adding/editing people)."""
        current_id: int | None = self._selected_person_id
        self._load_people()
        
        if current_id is not None:
            self.set_person(current_id)
    
    def set_filter(self, gender: str | None = None) -> None:
        """Filter the displayed people by gender."""
        self.gender_filter = gender
        self._load_people()

>> ðŸ“‹ widgets\portrait_gallery.py (1 code lines)
"""Widget for displaying and managing person portraits."""

from PySide6.QtWidgets import QWidget


class PortraitGallery(QWidget):
    """Gallery widget for viewing and selecting portraits."""

    def __init__(self, person_id: int) -> None:
        """Initialize the portrait gallery widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load portraits from Portrait table
        # TODO: Display portraits in grid layout
        # TODO: Add portrait selection highlighting
        # TODO: Add upload new portrait button
        # TODO: Add delete portrait button
        # TODO: Emit signal on portrait selection
        pass


>> ðŸ“‹ widgets\search_bar.py (2 code lines)
"""Search bar widget for finding people by name."""

from PySide6.QtWidgets import QWidget


class SearchBar(QWidget):
    """Search widget with autocomplete for finding people."""

    def __init__(self) -> None:
        """Initialize the search bar widget."""
        super().__init__()
        # TODO: Add QLineEdit for search input
        # TODO: Implement autocomplete using QCompleter
        # TODO: Load all person names from database
        # TODO: Add search icon/button
        # TODO: Add clear button
        # TODO: Emit signal when person is selected
        # TODO: Support fuzzy matching (optional)
        pass

    def update_completions(self) -> None:
        """Refresh autocomplete list from database."""
        # TODO: Reload all person names
        # TODO: Update QCompleter model
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UTILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ utils\__init__.py (0 code lines)
"""Utility modules for calculations and helpers."""

from .date_formatter import DateFormatter

__all__ = [
    "DateFormatter",
]


>> ðŸ“‹ utils\color_manager.py (5 code lines)
"""Color utilities for UI elements."""

from PySide6.QtGui import QColor


class ColorManager:
    """Manage colors for various UI elements."""

    def __init__(self) -> None:
        """Initialize the color manager."""
        # TODO: Define color palettes
        # TODO: Define gender-specific colors
        # TODO: Define generation band colors
        # TODO: Define event type colors
        pass

    def get_person_color(self, gender: str | None) -> QColor: # type: ignore 
        """Get color for person based on gender."""
        # TODO: Return blue for male
        # TODO: Return pink for female
        # TODO: Return gray for unknown
        pass

    def get_generation_color(self, generation: int) -> QColor: # type: ignore 
        """Get alternating color for generation bands."""
        # TODO: Return alternating colors based on generation number
        pass

    def get_event_color(self, event_type: str) -> QColor: # type: ignore 
        """Get color for event type."""
        # TODO: Return different colors for different event types
        # TODO: Birth, death, marriage, arrival, etc.
        pass

    def interpolate_color(self, color1: QColor, color2: QColor, ratio: float) -> QColor: # type: ignore 
        """Blend two colors together."""
        # TODO: Calculate intermediate color
        # TODO: Return blended QColor
        pass


>> ðŸ“‹ utils\csv_importer.py (4 code lines)
"""CSV import utility for bulk data loading."""

import csv


class CSVImporter:
    """Import genealogy data from CSV files."""

    def __init__(self, database_connection) -> None:
        """Initialize the CSV importer."""
        self.db = database_connection

    def import_people(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import people from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert people into database
        # TODO: Return count of imported people
        pass

    def import_marriages(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import marriages from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data (check person IDs exist)
        # TODO: Insert marriages into database
        # TODO: Return count of imported marriages
        pass

    def import_events(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import events from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert events into database
        # TODO: Return count of imported events
        pass


>> âœ… utils\date_formatter.py (53 code lines)
"""Date formatting utilities for canonical and display-oriented date rendering."""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Optional


class MonthStyle(Enum):
    """Supported month rendering styles."""

    NUMERIC = "numeric"
    NUMERIC_PADDED = "numeric_padded"
    FULL_NAME = "full_name"
    ABBREVIATED = "abbreviated"


class DateOrder(Enum):
    """Supported date component ordering."""

    YMD = "YMD"
    DMY = "DMY"
    MDY = "MDY"


@dataclass(frozen=True)
class DateParts:
    """Normalized date components."""

    year: int
    month: Optional[int] = None
    day: Optional[int] = None

    def has_month(self) -> bool:
        """Return True if month component is present."""
        return self.month is not None

    def has_day(self) -> bool:
        """Return True if day component is present."""
        return self.day is not None

    def is_year_only(self) -> bool:
        """Return True if only year component is present."""
        return self.month is None and self.day is None

    def is_year_month(self) -> bool:
        """Return True if year and month are present without day."""
        return self.month is not None and self.day is None


class DateFormatter:
    """Render date components into canonical or display-oriented strings."""

    MONTHS_FULL: dict[int, str] = {
        1: "January", 2: "February", 3: "March", 4: "April",
        5: "May", 6: "June", 7: "July", 8: "August",
        9: "September", 10: "October", 11: "November", 12: "December",
    }

    MONTHS_ABBREVIATED: dict[int, str] = {
        1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr",
        5: "May", 6: "Jun", 7: "Jul", 8: "Aug",
        9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec",
    }

    MONTH_NAME_TO_INT: dict[str, int] ={
        name: month for month, name in MONTHS_FULL.items()
    }

    UNKNOWN_DATE: str = "?"

    # ------------------------------------------------------------------
    # Canonical formatting (non-configurable)
    # ------------------------------------------------------------------

    @staticmethod
    def format_iso(date: DateParts) -> str:
        """Return canonical ISO-8601 date string (YYYY-MM-DD)."""
        if not (date.has_month() and date.has_day()):
            raise ValueError("ISO format requires year, month, and day.")
        return f"{date.year:04d}-{date.month:02d}-{date.day:02d}"

    # ------------------------------------------------------------------
    # Display formatting (configurable)
    # ------------------------------------------------------------------

    @staticmethod
    def format_display(
        date: DateParts,
        *,
        order: DateOrder = DateOrder.YMD,
        separator: str = "/",
        month_style: MonthStyle = MonthStyle.NUMERIC,
        pad_day: bool = False,
    ) -> str:
        """Return a user-facing formatted date string."""
        if date.year is None:
            return DateFormatter.UNKNOWN_DATE

        components = DateFormatter._build_components(
            date=date,
            month_style=month_style,
            pad_day=pad_day,
        )

        ordered = DateFormatter._order_components(
            date=date,
            components=components,
            order=order,
        )

        return separator.join(ordered)

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    @staticmethod
    def month_name_to_int(month: str) -> int | None:
        """Convert full month name to integer value."""
        return DateFormatter.MONTH_NAME_TO_INT.get(month)

    @staticmethod
    def normalize_month(value: int | str | None) -> int | None:
        """Normalize month value to integer representation."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, str):
            if value.isdigit():
                return int(value)
            return DateFormatter.month_name_to_int(value)
        return None

    @staticmethod
    def _build_components(
        *,
        date: DateParts,
        month_style: MonthStyle,
        pad_day: bool,
    ) -> list[str]:
        """Build rendered date components."""
        parts: dict[str, str] = {"year": str(date.year)}

        if date.has_month():
            parts["month"] = DateFormatter._render_month(
                month=date.month,  # type: ignore[arg-type]
                style=month_style,
            )

        if date.has_day():
            parts["day"] = f"{date.day:02d}" if pad_day else str(date.day)

        return [parts[key] for key in ("year", "month", "day") if key in parts]

    @staticmethod
    def _order_components(
        *,
        date: DateParts,
        components: list[str],
        order: DateOrder,
    ) -> list[str]:
        """Order date components according to defined layout rules."""
        # Partial dates are always year-first
        if date.is_year_only() or date.is_year_month():
            return components

        if order is DateOrder.YMD:
            return components
        if order is DateOrder.DMY:
            return components[::-1]
        if order is DateOrder.MDY:
            year, month, day = components
            return [month, day, year]

        return components

    @staticmethod
    def _render_month(
        *,
        month: int,
        style: MonthStyle,
    ) -> str:
        """Render month according to requested style."""
        if style is MonthStyle.NUMERIC:
            return str(month)
        if style is MonthStyle.NUMERIC_PADDED:
            return f"{month:02d}"
        if style is MonthStyle.FULL_NAME:
            return DateFormatter.MONTHS_FULL.get(month, "")
        if style is MonthStyle.ABBREVIATED:
            return DateFormatter.MONTHS_ABBREVIATED.get(month, "")
        raise ValueError(f"Unsupported MonthStyle: {style}")


>> ðŸ“‹ utils\generation_calculator.py (2 code lines)
"""Calculate generation levels for all people."""


class GenerationCalculator:
    """Compute generation levels for genealogical hierarchy."""

    def __init__(self, database_connection) -> None:
        """Initialize the generation calculator."""
        self.db = database_connection

    def recompute_all_generations(self) -> None:
        """Recalculate generation levels for all people."""
        # TODO: Find all founders (no parents)
        # TODO: Run BFS from founders
        # TODO: Assign generation numbers
        # TODO: Handle edge cases (adoptions, step-relations)
        pass


>> ðŸ“‹ utils\relationship_calculator.py (3 code lines)
"""Calculate relationships between people using graph traversal."""


class RelationshipCalculator:
    """Calculate familial relationships between two people."""

    def __init__(self, database_connection) -> None:
        """Initialize the relationship calculator."""
        self.db = database_connection

    def find_relationship_path(self, person1_id: int, person2_id: int) -> list[int] | None:
        """Find the shortest relationship path between two people."""
        # TODO: Implement BFS graph traversal
        # TODO: Return list of person IDs in the path
        pass

    def describe_relationship(self, person1_id: int, person2_id: int) -> str:
        """Return a human-readable relationship description."""
        # TODO: Implement relationship naming logic
        # TODO: Handle parents, siblings, cousins, etc.
        # TODO: Handle "removed" relationships
        pass


>> âœ… utils\settings_manager.py (96 code lines)
"""User preferences and settings management."""

from __future__ import annotations
from typing import Any
from PySide6.QtCore import QSettings

class SettingsManager:
    """Manages user preferences and disk persistence."""

    DEFAULTS = {
        "shortcuts": {
            # File Menu shortcuts
            "file.new": "Ctrl+N",
            "file.open": "Ctrl+O",
            "file.save": "Ctrl+S",
            "file.save_as": "Ctrl+Shift+S",
            "file.exit": "Ctrl+Q",

            # Edit Menu shortcuts
            "edit.undo": "Ctrl+Z",
            "edit.redo": "Ctrl+Y",
            "edit.add_person": "Ctrl+P",
            "edit.remove_person": "Del",
            "edit.add_new_family": "Ctrl+F",

            # View Menu shortcuts
            "view.family_trees": "Ctrl+1",
            "view.timeline": "Ctrl+2",
            "view.dynasty": "Ctrl+3",
            "view.data_table": "Ctrl+4",

            # Tools Menu shortcuts
            "tools.rebuild_scene": "F5",
            "tools.recompute_generations": "Ctrl+R",
            "tools.validate_marriages": "Ctrl+M",
            "tools.validate_parentage": "Ctrl+Shift+P",

            # Settings Menu shortcuts
            "settings.settings": "Ctrl+,",
            "settings.general": "",
            "settings.shortcuts": "",
            "settings.display": "",
            "settings.appearance": "",
            "settings.formats": "",

            # Help Menu shortcuts
            "help.about": "F1",
        },

        "general": {
            # TODO: Define general settings defaults
            # e.g., autosave interval, default file paths, etc.
            # including different header sections as above
        },

        "display": {
            # TODO: Define display settings defaults
            # e.g., default zoom level, layout preferences, etc.
            # including different header sections as above
            # window size, position, maximized state, fonts, themes etc.
        },

        "appearance": {
            # TODO: Define appearance settings defaults
            # e.g., color schemes, node styles, edge styles, Colorblindness modes,
            # Male/Female/Unknown color preferences, generation band colors, genetic line styles, etc.
            # including different header sections as above to keep things organized
        },

        "formats": {
            # TODO: Define format settings defaults
            # e.g., date formats, name display formats, event display formats, etc.
            # Undo/Redo stack size, autosave file format, import/export preferences, etc.
            # including different header sections as above
        },
    }

    def __init__(self) -> None:
        """Initialize settings manager and load user settings."""
        
        self.qsettings = QSettings("DynastyVizualizer", "DynastyVisualizer")

        self.custom_shortcuts: dict[str, str | None] = {}
        self.custom_general: dict[str, Any] = {}
        self.custom_display: dict[str, Any] = {}
        self.custom_appearance: dict[str, Any] = {}
        self.custom_formats: dict[str, Any] = {}
    
        self._load_from_disk()

    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------

    def _get_custom_dict(self, category: str) -> dict[str, Any]:
        """Get the custom dictionary for a given category."""
        category_map = {
            "shortcuts": self.custom_shortcuts,
            "general": self.custom_general,
            "display": self.custom_display,
            "appearance": self.custom_appearance,
            "formats": self.custom_formats,
        }
        return category_map.get(category, {})

    def _load_from_disk(self) -> None:
        """Load user's saved settings from disk."""
        for category in self.DEFAULTS.keys():
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if self.qsettings.contains(key):
                    value = self.qsettings.value(key)
                    custom_dict[key] = value if value else None
            
            self.qsettings.endGroup()
    def _save_to_disk(self) -> None:
        """Save user's custom settings to disk."""
        for category in self.DEFAULTS.keys():
            # Clear existing category on disk
            self.qsettings.beginGroup(category)
            self.qsettings.remove("")
            self.qsettings.endGroup()
            
            # Save only settings that exist in current DEFAULTS
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if key in custom_dict:  
                    value = custom_dict[key]
                    default = self.DEFAULTS[category][key]

                    if value != default:
                        self.qsettings.setValue(key, value if value else "")
            
            self.qsettings.endGroup()
        
        self.qsettings.sync()

    # ------------------------------------------------------------------
    # Shortcut Operations (Specific, Type-Safe)
    # ------------------------------------------------------------------

    def get_shortcut(self, action_name: str) -> str:
        """Get the shortcut for a given action, falling back to default if not customized."""
        return self.get_setting("shortcuts", action_name)

    def set_shortcut(self, action_name: str, shortcut: str) -> None:
        """Set custom shortcut in memory without saving to disk."""
        self.set_setting("shortcuts", action_name, shortcut)

        if shortcut:
            for other_action in list(self.custom_shortcuts.keys()):
                if other_action != action_name:
                    if self.custom_shortcuts[other_action] == shortcut:
                        self.custom_shortcuts[other_action] = None


    # ------------------------------------------------------------------
    # Generic Settings Operations
    # ------------------------------------------------------------------

    def get_setting(self, category: str, key: str) -> Any:
        """Get setting from any category, checking custom then default."""
        # Check custom value first
        custom_dict = self._get_custom_dict(category)
        if key in custom_dict:
            value = custom_dict[key]
            return value if value is not None else ""
        
        # Fall back to default
        if category in self.DEFAULTS and key in self.DEFAULTS[category]:
            return self.DEFAULTS[category][key]
        
        return ""
    
    def set_setting(self, category: str, key: str, value: Any) -> None:
        """Set setting in any category (memory only, not saved to disk)."""
        custom_dict = self._get_custom_dict(category)
        custom_dict[key] = value if value else None

    # ------------------------------------------------------------------
    # Save/Discard/Reset Operations
    # ------------------------------------------------------------------

    def save(self) -> None:
        """Save all custom settings to disk."""
        self._save_to_disk()

    def discard_changes(self) -> None:
        """Discard unsaved changes by reloading from disk."""
        self.custom_shortcuts.clear()
        self.custom_general.clear()
        self.custom_display.clear()
        self.custom_appearance.clear()
        self.custom_formats.clear()
        self._load_from_disk()

    def reset_category_to_defaults(self, category: str) -> None:
        """Reset one category to defaults and save to disk."""
        custom_dict = self._get_custom_dict(category)
        custom_dict.clear()
        self._save_to_disk()

    def reset_all_to_defaults(self) -> None:
        """Reset all categories to defaults and save to disk."""
        for category in self.DEFAULTS.keys():
            self.reset_category_to_defaults(category)

    # ------------------------------------------------------------------
    # Recent Files Operations
    # ------------------------------------------------------------------

    def get_recent_files(self) -> list[str]:
        """Get list of recent file paths."""
        self.qsettings.beginGroup("recent_files")
        size = self.qsettings.beginReadArray("files")
        recent = []
        for i in range(size):
            self.qsettings.setArrayIndex(i)
            path = self.qsettings.value("path")
            if path:
                recent.append(path)
        self.qsettings.endArray()
        self.qsettings.endGroup()
        return recent

    def add_recent_file(self, file_path: str) -> None:
        """Add file to recent files list (most recent first)."""
        recent = self.get_recent_files()

        if file_path in recent:
            recent.remove(file_path)
        
        recent.insert(0, file_path)

        recent = recent[:10]

        self.qsettings.beginGroup("recent_files")
        self.qsettings.beginWriteArray("files")
        for i, path in enumerate(recent):
            self.qsettings.setArrayIndex(i)
            self.qsettings.setValue("path", path)
        self.qsettings.endArray()
        self.qsettings.endGroup()
        self.qsettings.sync()

    def clear_recent_files(self) -> None:
        """Clear all recent files."""
        self.qsettings.beginGroup("recent_files")
        self.qsettings.remove("")
        self.qsettings.endGroup()
        self.qsettings.sync()

>> ðŸ“‹ utils\skin_manager.py (4 code lines)
"""Skin/theme management for UI customization."""

from PySide6.QtWidgets import QApplication


class SkinManager:
    """Manage application color schemes and themes."""

    def __init__(self) -> None:
        """Initialize the skin manager with built-in themes."""
        self.skins: dict[str, dict[str, str]] = {}
        # TODO: Define default skin
        # TODO: Define dark mode skin
        # TODO: Define light mode skin
        # TODO: Define custom color schemes
        pass

    def load_skin(self, skin_name: str) -> None:
        """Apply a color scheme to the application."""
        # TODO: Get color definitions for skin_name
        # TODO: Generate QSS stylesheet
        # TODO: Apply to QApplication
        pass

    def get_available_skins(self) -> list[str]:
        """Get list of available skin names."""
        # TODO: Return list of skin keys
        pass

    def create_custom_skin(self, name: str, colors: dict[str, str]) -> None:
        """Create a new custom color scheme."""
        # TODO: Validate color values
        # TODO: Store in skins dictionary
        # TODO: Optionally save to Settings table
        pass


>> ðŸ“‹ utils\text_normalizer.py (6 code lines)
"""Text normalization utilities for searching and comparison."""
import unicodedata
from typing import Literal


class TextNormalizer:
    """Normalize text for accent-insensitive comparison."""
    
    ENCODING_ASCII: Literal["ascii"] = "ascii"
    ENCODING_UTF8: Literal["utf-8"] = "utf-8"
    NORMALIZATION_FORM: Literal["NFD"] = "NFD"
    IGNORE_ERRORS: Literal["ignore"] = "ignore"
    
    @staticmethod
    def normalize_for_search(text: str) -> str:
        """Remove accents and convert to lowercase for searching."""
        normalized: str = unicodedata.normalize(
            TextNormalizer.NORMALIZATION_FORM, 
            text
        )
        ascii_text: bytes = normalized.encode(
            TextNormalizer.ENCODING_ASCII, 
            TextNormalizer.IGNORE_ERRORS
        )
        return ascii_text.decode(TextNormalizer.ENCODING_UTF8).lower()

>> âœ… utils\validators.py (193 code lines)
"""Data validation tools for detecting inconsistencies."""

from __future__ import annotations

from typing import TYPE_CHECKING
from dataclasses import dataclass

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager
    from database.person_repository import PersonRepository
    from models.person import Person
    from models.marriage import Marriage


@dataclass
class ValidationIssue:
    """Represents a data validation issue."""
    
    issue_type: str
    category: str
    message: str
    entity_type: str

    TYPE_ERROR: str = "error"
    TYPE_WARNING: str = "warning"
    TYPE_INFO: str = "info"
    
    entity_id: int | None = None
    details: dict | None = None


class MarriageValidator:
    """Validate marriage data for inconsistencies."""
    
    CATEGORY_OVERLAPPING: str = "overlapping_marriages"
    CATEGORY_INVALID_DATE: str = "invalid_date"
    CATEGORY_SELF_MARRIAGE: str = "self_marriage"
    CATEGORY_IMPOSSIBLE_AGE: str = "impossible_age"
    CATEGORY_DEATH_CONFLICT: str = "death_conflict"
    
    MIN_MARRIAGE_AGE: int = 12
    MAX_REASONABLE_AGE_GAP: int = 50
    
    def __init__(self, database_connection: DatabaseManager) -> None:
        """Initialize the marriage validator."""
        self.db: DatabaseManager = database_connection
    
    def validate_all(self) -> list[ValidationIssue]:
        """Check all marriages for issues."""
        from database.marriage_repository import MarriageRepository
        
        marriage_repo: MarriageRepository = MarriageRepository(self.db)
        issues: list[ValidationIssue] = []
        
        marriages: list[Marriage] = self._get_all_marriages(marriage_repo)
        
        for marriage in marriages:
            issues.extend(self._validate_marriage(marriage))
        
        issues.extend(self._check_overlapping_marriages(marriages))
        
        return issues
    
    def _get_all_marriages(self, marriage_repo) -> list[Marriage]:
        """Get all marriages from repository."""
        return []
    
    def _validate_marriage(self, marriage: Marriage) -> list[ValidationIssue]:
        """Validate a single marriage."""
        issues: list[ValidationIssue] = []
        
        self_marriage_issue: ValidationIssue | None = self._check_self_marriage(marriage)
        if self_marriage_issue:
            issues.append(self_marriage_issue)
        
        date_issue: ValidationIssue | None = self._check_marriage_dates(marriage)
        if date_issue:
            issues.append(date_issue)
        
        age_issues: list[ValidationIssue] = self._check_spouse_ages(marriage)
        issues.extend(age_issues)
        
        death_issue: ValidationIssue | None = self._check_death_conflicts(marriage)
        if death_issue:
            issues.append(death_issue)
        
        return issues
    
    def _check_self_marriage(self, marriage: Marriage) -> ValidationIssue | None:
        """Check if person is married to themselves."""
        if marriage.spouse1_id == marriage.spouse2_id:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_SELF_MARRIAGE,
                message="Person cannot be married to themselves",
                entity_type="Marriage",
                entity_id=marriage.id,
                details={"spouse_id": marriage.spouse1_id}
            )
        return None
    
    def _check_marriage_dates(self, marriage: Marriage) -> ValidationIssue | None:
        """Check if marriage dates are valid."""
        if marriage.marriage_year is None:
            return None
        
        if not marriage.dissolution_year:
            return None
        
        if marriage.dissolution_year < marriage.marriage_year:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_INVALID_DATE,
                message="Marriage ended before it started",
                entity_type="Marriage",
                entity_id=marriage.id,
                details={
                    "marriage_year": marriage.marriage_year,
                    "dissolution_year": marriage.dissolution_year
                }
            )

        if marriage.dissolution_year != marriage.marriage_year:
            return None
        
        if not (marriage.marriage_month and marriage.dissolution_month):
            return None
        
        if marriage.dissolution_month < marriage.marriage_month:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_INVALID_DATE,
                message="Marriage ended before it started (same year, earlier month)",
                entity_type="Marriage",
                entity_id=marriage.id
            )
        
        return None
    
    def _check_spouse_ages(self, marriage: Marriage) -> list[ValidationIssue]:
        """Check if spouses were reasonable age at marriage."""
        from database.person_repository import PersonRepository
        
        issues: list[ValidationIssue] = []
        
        if marriage.marriage_year is None:
            return issues
        
        person_repo: PersonRepository = PersonRepository(self.db)
        
        if marriage.spouse1_id:
            spouse1: Person | None = person_repo.get_by_id(marriage.spouse1_id)
            if spouse1:
                spouse1_issue: ValidationIssue | None = self._check_single_spouse_age(
                    marriage, spouse1, "spouse1"
                )
                if spouse1_issue:
                    issues.append(spouse1_issue)
        
        if marriage.spouse2_id:
            spouse2: Person | None = person_repo.get_by_id(marriage.spouse2_id)
            if spouse2:
                spouse2_issue: ValidationIssue | None = self._check_single_spouse_age(
                    marriage, spouse2, "spouse2"
                )
                if spouse2_issue:
                    issues.append(spouse2_issue)
        
        return issues
    
    def _check_single_spouse_age(
        self,
        marriage: Marriage,
        spouse: Person,
        spouse_label: str
    ) -> ValidationIssue | None:
        """Check if a single spouse was reasonable age at marriage."""
        if spouse.birth_year is None or marriage.marriage_year is None:
            return None
        
        age_at_marriage: int = marriage.marriage_year - spouse.birth_year
        
        if age_at_marriage < 0:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message="Person married before they were born",
                entity_type="Marriage",
                entity_id=marriage.id,
                details={
                    "person_id": spouse.id,
                    "person_name": spouse.display_name,
                    "spouse": spouse_label
                }
            )
        
        if age_at_marriage < self.MIN_MARRIAGE_AGE:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_WARNING,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message=f"Person was very young at marriage (age {age_at_marriage})",
                entity_type="Marriage",
                entity_id=marriage.id,
                details={
                    "person_id": spouse.id,
                    "person_name": spouse.display_name,
                    "age_at_marriage": age_at_marriage,
                    "spouse": spouse_label
                }
            )
        
        return None
    
    def _check_death_conflicts(self, marriage: Marriage) -> ValidationIssue | None:
        """Check if marriage occurred after death of spouse."""
        from database.person_repository import PersonRepository
        
        if marriage.marriage_year is None:
            return None
        
        person_repo: PersonRepository = PersonRepository(self.db)
        
        for spouse_id, spouse_label in [(marriage.spouse1_id, "spouse1"), (marriage.spouse2_id, "spouse2")]:
            if not spouse_id:
                continue
            
            spouse: Person | None = person_repo.get_by_id(spouse_id)
            if not spouse or spouse.death_year is None:
                continue
            
            if marriage.marriage_year > spouse.death_year:
                return ValidationIssue(
                    issue_type=ValidationIssue.TYPE_ERROR,
                    category=self.CATEGORY_DEATH_CONFLICT,
                    message="Marriage occurred after death of spouse",
                    entity_type="Marriage",
                    entity_id=marriage.id,
                    details={
                        "person_id": spouse.id,
                        "person_name": spouse.display_name,
                        "death_year": spouse.death_year,
                        "marriage_year": marriage.marriage_year
                    }
                )
        
        return None
    
    def _check_overlapping_marriages(self, marriages: list[Marriage]) -> list[ValidationIssue]:
        """Check for overlapping marriages for each person."""
        from database.person_repository import PersonRepository
        
        issues: list[ValidationIssue] = []
        person_repo: PersonRepository = PersonRepository(self.db)
        
        person_ids: set[int] = set()
        for marriage in marriages:
            if marriage.spouse1_id:
                person_ids.add(marriage.spouse1_id)
            if marriage.spouse2_id:
                person_ids.add(marriage.spouse2_id)
        
        for person_id in person_ids:
            person_marriages: list[Marriage] = self._get_marriages_for_person(marriages, person_id)
            overlap_issues: list[ValidationIssue] = self._find_overlapping_marriages(
                person_marriages, person_id, person_repo
            )
            issues.extend(overlap_issues)
        
        return issues
    
    @staticmethod
    def _get_marriages_for_person(marriages: list[Marriage], person_id: int) -> list[Marriage]:
        """Get all marriages for a specific person."""
        return [
            m for m in marriages
            if m.spouse1_id == person_id or m.spouse2_id == person_id
        ]
    
    def _find_overlapping_marriages(
        self,
        marriages: list[Marriage],
        person_id: int,
        person_repo: PersonRepository
    ) -> list[ValidationIssue]:
        """Find overlapping marriages for a person."""
        issues: list[ValidationIssue] = []
        
        sorted_marriages: list[Marriage] = sorted(
            marriages,
            key=lambda m: m.marriage_year if m.marriage_year else 0
        )
        
        for i, marriage1 in enumerate(sorted_marriages):
            for marriage2 in sorted_marriages[i + 1:]:
                overlap_issue: ValidationIssue | None = self._check_marriage_overlap(
                    marriage1, marriage2, person_id, person_repo
                )
                if overlap_issue:
                    issues.append(overlap_issue)
        
        return issues
    
    def _check_marriage_overlap(
        self,
        marriage1: Marriage,
        marriage2: Marriage,
        person_id: int,
        person_repo: PersonRepository
    ) -> ValidationIssue | None:
        """Check if two marriages overlap in time."""
        if marriage1.marriage_year is None or marriage2.marriage_year is None:
            return None
        
        if marriage1.dissolution_year is None:
            return self._create_overlap_issue(marriage1, marriage2, person_id, person_repo)
        
        if marriage1.dissolution_year >= marriage2.marriage_year:
            return self._create_overlap_issue(marriage1, marriage2, person_id, person_repo)
        
        return None
    
    def _create_overlap_issue(
        self,
        marriage1: Marriage,
        marriage2: Marriage,
        person_id: int,
        person_repo: PersonRepository
    ) -> ValidationIssue:
        """Create a validation issue for overlapping marriages."""
        person: Person | None = person_repo.get_by_id(person_id)
        person_name: str = person.display_name if person else f"Person {person_id}"
        
        return ValidationIssue(
            issue_type=ValidationIssue.TYPE_WARNING,
            category=self.CATEGORY_OVERLAPPING,
            message=f"Overlapping marriages detected for {person_name}",
            entity_type="Marriage",
            entity_id=marriage1.id,
            details={
                "person_id": person_id,
                "person_name": person_name,
                "marriage1_id": marriage1.id,
                "marriage2_id": marriage2.id,
                "marriage1_year": marriage1.marriage_year,
                "marriage2_year": marriage2.marriage_year
            }
        )


class ParentageValidator:
    """Validate parent-child relationships."""
    
    CATEGORY_CIRCULAR: str = "circular_parentage"
    CATEGORY_IMPOSSIBLE_AGE: str = "impossible_age"
    CATEGORY_GENDER_MISMATCH: str = "gender_mismatch"
    CATEGORY_DEATH_CONFLICT: str = "death_conflict"
    
    MIN_PARENT_AGE: int = 12
    MAX_REASONABLE_PARENT_AGE: int = 60
    MIN_REASONABLE_PARENT_AGE: int = 15
    
    def __init__(self, database_connection: DatabaseManager) -> None:
        """Initialize the parentage validator."""
        self.db: DatabaseManager = database_connection
    
    def validate_all(self) -> list[ValidationIssue]:
        """Check all parentage relationships for issues."""
        from database.person_repository import PersonRepository
        
        person_repo: PersonRepository = PersonRepository(self.db)
        issues: list[ValidationIssue] = []
        
        all_people: list[Person] = person_repo.get_all()
        
        for person in all_people:
            issues.extend(self._validate_person_parentage(person, person_repo))
        
        return issues
    
    def _validate_person_parentage(
        self,
        person: Person,
        person_repo: PersonRepository
    ) -> list[ValidationIssue]:
        """Validate parentage for a single person."""
        issues: list[ValidationIssue] = []
        
        circular_issue: ValidationIssue | None = self._check_circular_parentage(person, person_repo)
        if circular_issue:
            issues.append(circular_issue)
        
        if person.father_id:
            father_issues: list[ValidationIssue] = self._validate_parent(
                person, person.father_id, "father", person_repo
            )
            issues.extend(father_issues)
        
        if person.mother_id:
            mother_issues: list[ValidationIssue] = self._validate_parent(
                person, person.mother_id, "mother", person_repo
            )
            issues.extend(mother_issues)
        
        return issues
    
    def _check_circular_parentage(
        self,
        person: Person,
        person_repo: PersonRepository
    ) -> ValidationIssue | None:
        """Check for circular parent-child relationships."""
        if person.id is None:
            return None
        
        visited: set[int] = set()
        current_id: int | None = person.id
        
        while current_id is not None:
            if current_id in visited:
                return ValidationIssue(
                    issue_type=ValidationIssue.TYPE_ERROR,
                    category=self.CATEGORY_CIRCULAR,
                    message="Circular parentage detected in family tree",
                    entity_type="Person",
                    entity_id=person.id,
                    details={"circular_person_id": current_id}
                )
            
            visited.add(current_id)
            current_person: Person | None = person_repo.get_by_id(current_id)
            
            if not current_person:
                break
            
            current_id = current_person.father_id
        
        return None
    
    def _validate_parent(
        self,
        child: Person,
        parent_id: int,
        parent_type: str,
        person_repo: PersonRepository
    ) -> list[ValidationIssue]:
        """Validate a parent-child relationship."""
        issues: list[ValidationIssue] = []
        
        parent: Person | None = person_repo.get_by_id(parent_id)
        if not parent:
            return issues
        
        gender_issue: ValidationIssue | None = self._check_parent_gender(child, parent, parent_type)
        if gender_issue:
            issues.append(gender_issue)
        
        age_issue: ValidationIssue | None = self._check_parent_age(child, parent, parent_type)
        if age_issue:
            issues.append(age_issue)
        
        death_issue: ValidationIssue | None = self._check_parent_alive_at_birth(
            child, parent, parent_type
        )
        if death_issue:
            issues.append(death_issue)
        
        return issues
    
    def _check_parent_gender(
        self,
        child: Person,
        parent: Person,
        parent_type: str
    ) -> ValidationIssue | None:
        """Check if parent's gender matches their role."""
        expected_gender: str = Person.GENDER_MALE if parent_type == "father" else Person.GENDER_FEMALE
        
        if parent.gender != expected_gender and parent.gender != Person.GENDER_UNKNOWN:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_WARNING,
                category=self.CATEGORY_GENDER_MISMATCH,
                message=f"{parent_type.capitalize()} has unexpected gender",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "expected_gender": expected_gender,
                    "actual_gender": parent.gender
                }
            )
        
        return None
    
    def _check_parent_age(
        self,
        child: Person,
        parent: Person,
        parent_type: str
    ) -> ValidationIssue | None:
        """Check if parent was reasonable age at child's birth."""
        if child.birth_year is None or parent.birth_year is None:
            return None
        
        parent_age_at_birth: int = child.birth_year - parent.birth_year
        
        if parent_age_at_birth < 0:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message=f"{parent_type.capitalize()} was born after child",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "parent_age": parent_age_at_birth
                }
            )
        
        if parent_age_at_birth < self.MIN_PARENT_AGE:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message=f"{parent_type.capitalize()} was very young at child's birth (age {parent_age_at_birth})",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "parent_age": parent_age_at_birth
                }
            )
        
        if parent_age_at_birth < self.MIN_REASONABLE_PARENT_AGE:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_WARNING,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message=f"{parent_type.capitalize()} was unusually young at child's birth (age {parent_age_at_birth})",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "parent_age": parent_age_at_birth
                }
            )
        
        if parent_age_at_birth > self.MAX_REASONABLE_PARENT_AGE:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_WARNING,
                category=self.CATEGORY_IMPOSSIBLE_AGE,
                message=f"{parent_type.capitalize()} was unusually old at child's birth (age {parent_age_at_birth})",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "parent_age": parent_age_at_birth
                }
            )
        
        return None
    
    def _check_parent_alive_at_birth(
        self,
        child: Person,
        parent: Person,
        parent_type: str
    ) -> ValidationIssue | None:
        """Check if parent was alive when child was born."""
        if child.birth_year is None or parent.death_year is None:
            return None
        
        if parent.death_year < child.birth_year:
            return ValidationIssue(
                issue_type=ValidationIssue.TYPE_ERROR,
                category=self.CATEGORY_DEATH_CONFLICT,
                message=f"{parent_type.capitalize()} died before child was born",
                entity_type="Person",
                entity_id=child.id,
                details={
                    "child_name": child.display_name,
                    "child_birth_year": child.birth_year,
                    "parent_id": parent.id,
                    "parent_name": parent.display_name,
                    "parent_type": parent_type,
                    "parent_death_year": parent.death_year
                }
            )
        
        return None


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCRIPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… scripts\create_codebase_summary.py (101 code lines)
"""
Generate dynasty_codebase.txt - Complete codebase snapshot optimized for LLMs.

Creates a token-efficient snapshot of ALL source code that LLMs can use to
understand the complete project state in a single context window.

Usage:
    python scripts/create_codebase_summary.py

Output:
    dynasty_codebase.txt - Complete codebase, LLM-optimized

Features:
    - Token-efficient: Minimal headers, maximum code density
    - Complete: ALL Python files included
    - Organized: Grouped by category for easy parsing
    - Compact: No visual trees, just clean code listings
    - Smart encoding: Handles UTF-8, UTF-16
"""

from __future__ import annotations

import os
from pathlib import Path
from datetime import datetime


# ------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------

OUTPUT_FILE: str = "dynasty_codebase.txt"
PROJECT_NAME: str = "DynastyVizualizer"

IGNORE_PATTERNS: set[str] = {
    "__pycache__", ".git", ".pytest_cache", ".venv", "venv", "env",
    ".env", "*.pyc", "*.pyo", "*.pyd", ".DS_Store", "*.egg-info",
    "dist", "build", ".idea", ".vscode", "*.dyn", "*.backup",
    "node_modules", "*.md", "dynasty_codebase.txt"
}

SOURCE_EXTENSIONS: set[str] = {".py"}
CONFIG_FILES: set[str] = {"requirements.txt"}

INDENT: str = "\t"
MAX_FILES_PER_LINE: int = 50

# ------------------------------------------------------------------
# File Discovery
# ------------------------------------------------------------------

def should_ignore(path: Path) -> bool:
    """Check if path or any parent should be ignored."""
    path_str: str = str(path)
    
    for part in path.parts:
        if part in IGNORE_PATTERNS:
            return True
    
    name: str = path.name
    for pattern in IGNORE_PATTERNS:
        if "*" in pattern:
            ext: str = pattern.replace("*", "")
            if path_str.endswith(ext):
                return True
    
    if name == OUTPUT_FILE:
        return True
    
    return False


def discover_files(root_dir: Path) -> tuple[list[Path], list[Path]]:
    """Discover all source and config files."""
    source_files: list[Path] = []
    config_files: list[Path] = []
    
    for path in sorted(root_dir.rglob("*")):
        if path.is_dir():
            continue
        
        if should_ignore(path):
            continue
        
        if path.suffix in SOURCE_EXTENSIONS:
            source_files.append(path)
        elif path.name in CONFIG_FILES:
            config_files.append(path)
    
    return source_files, config_files


def get_relative_path(filepath: Path, root: Path) -> str:
    """Get path relative to project root."""
    try:
        return str(filepath.relative_to(root))
    except ValueError:
        return str(filepath)


# ------------------------------------------------------------------
# File Analysis
# ------------------------------------------------------------------

def count_code_lines(filepath: Path) -> int:
    """Count non-empty, non-comment lines."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            count: int = 0
            in_multiline: bool = False
            
            for line in f:
                stripped: str = line.strip()
                
                if not stripped:
                    continue
                
                if '"""' in stripped or "'''" in stripped:
                    in_multiline = not in_multiline
                    continue
                
                if in_multiline or stripped.startswith('#'):
                    continue
                
                count += 1
            
            return count
    except Exception:
        return 0


def read_file_content(filepath: Path) -> str:
    """Read file content with multiple encoding support."""
    for encoding in ['utf-8', 'utf-16', 'utf-16-le', 'latin-1']:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                content: str = f.read()
                if '\x00' not in content or encoding.startswith('utf-16'):
                    return content
        except (UnicodeDecodeError, Exception):
            continue
    
    try:
        with open(filepath, 'rb') as f:
            return f.read().decode('utf-8', errors='replace')
    except Exception as e:
        return f"[Error: {e}]"


# ------------------------------------------------------------------
# File Categorization
# ------------------------------------------------------------------

def categorize_files(source_files: list[Path], root: Path) -> dict[str, list[Path]]:
    """Organize files by category with hierarchy."""
    categories: dict[str, list[Path]] = {
        "Core": [],
        "Database": [],
        "Models": [],
        "Actions": [],
        "Commands": [],
        "Dialogs": [],
        "Views": [],
        "Widgets": [],
        "Utils": [],
        "Scripts": []
    }
    
    for f in source_files:
        rel_path: str = get_relative_path(f, root)
        parent: str = str(Path(rel_path).parent)
        
        if rel_path == "main.py":
            categories["Core"].append(f)
        elif "database" in parent:
            categories["Database"].append(f)
        elif "models" in parent:
            categories["Models"].append(f)
        elif "actions" in parent:
            categories["Actions"].append(f)
        elif "commands" in parent:
            categories["Commands"].append(f)
        elif "dialogs" in parent:
            categories["Dialogs"].append(f)
        elif "views" in parent:
            categories["Views"].append(f)
        elif "widgets" in parent:
            categories["Widgets"].append(f)
        elif "utils" in parent:
            categories["Utils"].append(f)
        elif "scripts" in parent:
            categories["Scripts"].append(f)
        else:
            categories["Core"].append(f)
    
    return categories


def get_file_depth(filepath: str) -> int:
    """Get nesting depth of file based on directory separators."""
    parts: tuple[str, ...] = Path(filepath).parts
    
    if len(parts) == 1:
        return 0
    
    return len(parts) - 2


def format_file_index(categories: dict[str, list[Path]], root: Path) -> str:
    """Format file index with hierarchical indentation."""
    output: list[str] = ["FILE INDEX:"]
    
    for category, files in categories.items():
        if not files:
            continue
        
        output.append(f"{category}:")
        
        sorted_files: list[Path] = sorted(files, key=lambda f: get_relative_path(f, root))
        
        for filepath in sorted_files:
            rel_path: str = get_relative_path(filepath, root)
            depth: int = get_file_depth(rel_path)
            indent: str = INDENT * (depth + 1)
            
            output.append(f"{indent}{rel_path},")
    
    return "\n".join(output)


# ------------------------------------------------------------------
# Summary Generation
# ------------------------------------------------------------------

def write_header(out, stats: dict) -> None:
    """Write compact header to output file."""
    out.write(f"{'='*70}\n")
    out.write(f"{PROJECT_NAME} - Complete Codebase\n")
    out.write(f"{'='*70}\n")
    out.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
    out.write(f"Files: {stats['implemented']}/{stats['total']} implemented | ")
    out.write(f"{stats['code_lines']} code lines\n")
    out.write(f"Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern\n")
    out.write(f"Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)\n")
    out.write(f"{'='*70}\n\n")


def write_context(out) -> None:
    """Write quick context section."""
    out.write("QUICK CONTEXT:\n")
    out.write("Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,\n")
    out.write("undo/redo, flexible dates, special char support, DB migration.\n")
    out.write("Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database\n\n")


def write_file_index(out, categories: dict[str, list[Path]], root: Path) -> None:
    """Write hierarchical file index."""
    out.write(format_file_index(categories, root))
    out.write(f"\n\n{'='*70}\n")
    out.write("COMPLETE SOURCE CODE\n")
    out.write(f"{'='*70}\n\n")


def write_category_code(out, category: str, files: list[Path], root: Path) -> None:
    """Write code for a single category."""
    if not files:
        return
    
    out.write(f"\n{'â”€'*70}\n")
    out.write(f"{category.upper()}\n")
    out.write(f"{'â”€'*70}\n\n")
    
    for filepath in sorted(files):
        rel_path: str = get_relative_path(filepath, root)
        lines: int = count_code_lines(filepath)
        status: str = "âœ…" if lines > 20 else "ðŸ“‹"
        
        out.write(f">> {status} {rel_path} ({lines} code lines)\n")
        out.write(read_file_content(filepath))
        out.write("\n\n")
        
        print(f"âœ… {rel_path} ({lines} lines)")


def write_config_files(out, config_files: list[Path], root: Path) -> None:
    """Write configuration files section."""
    if not config_files:
        return
    
    out.write(f"\n{'â”€'*70}\n")
    out.write("CONFIGURATION\n")
    out.write(f"{'â”€'*70}\n\n")
    
    for filepath in config_files:
        rel_path: str = get_relative_path(filepath, root)
        out.write(f">> {rel_path}\n")
        out.write(read_file_content(filepath))
        out.write("\n\n")


def write_footer(out, stats: dict) -> None:
    """Write compact footer."""
    out.write(f"\n{'='*70}\n")
    out.write(f"END - {stats['implemented']}/{stats['total']} files, ")
    out.write(f"{stats['code_lines']} code lines\n")
    out.write(f"{'='*70}\n")


def calculate_stats(source_files: list[Path]) -> dict:
    """Calculate file statistics."""
    total: int = len(source_files)
    implemented: int = sum(1 for f in source_files if count_code_lines(f) > 20)
    code_lines: int = sum(count_code_lines(f) for f in source_files)
    
    return {
        'total': total,
        'implemented': implemented,
        'code_lines': code_lines
    }


def generate_summary(root_dir: Path) -> None:
    """Generate the token-efficient codebase snapshot."""
    print(f"ðŸ” Discovering files in {PROJECT_NAME}...")
    source_files, config_files = discover_files(root_dir)
    
    stats: dict = calculate_stats(source_files)
    
    print(f"ðŸ“Š Found {stats['total']} files ({stats['implemented']} implemented, ")
    print(f"    {stats['code_lines']} code lines)")
    
    categories: dict[str, list[Path]] = categorize_files(source_files, root_dir)
    output_path: Path = root_dir / OUTPUT_FILE
    
    with open(output_path, 'w', encoding='utf-8') as out:
        write_header(out, stats)
        write_context(out)
        write_file_index(out, categories, root_dir)
        
        for category, files in categories.items():
            write_category_code(out, category, files, root_dir)
        
        write_config_files(out, config_files, root_dir)
        write_footer(out, stats)
    
    print(f"\nâœ… Generated {OUTPUT_FILE}")
    print(f"ðŸ“Š {stats['implemented']}/{stats['total']} files, {stats['code_lines']:,} code lines")
    print(f"ðŸ“„ Output: {output_path}")
    print(f"ðŸ¤– Token-optimized for LLM consumption!\n")


# ------------------------------------------------------------------
# Main Entry Point
# ------------------------------------------------------------------

def main() -> None:
    """Main entry point for script."""
    script_dir: Path = Path(__file__).parent
    project_root: Path = script_dir.parent
    os.chdir(project_root)
    
    print(f"{'='*60}")
    print(f"  {PROJECT_NAME} - Codebase Generator")
    print(f"{'='*60}\n")
    
    generate_summary(project_root)


if __name__ == "__main__":
    main()

>> âœ… scripts\migrate_database.py (57 code lines)
"""
Migration script to upgrade existing .dyn files to the new schema.

This script safely adds:
1. Day fields to all date columns (birth, death, arrival, etc.)
2. New tables (Portrait, Family, MajorEvent, PersonPosition, Settings)
3. Additional Person fields (maiden_name, family_id, notes)
4. Marriage type field

Usage:
    python scripts/migrate_database.py <path_to_dynasty_file.dyn>

Example:
    python scripts/migrate_database.py "MyDynasty.dyn"

This migration is SAFE:
- Existing data is preserved (new columns are NULL)
- No data is deleted or modified
- Backup is created before migration
"""

import sqlite3
import shutil
import sys
from pathlib import Path


def backup_database(file_path: str) -> str:
    """Create a backup of the database before migration."""
    backup_path = f"{file_path}.backup"
    shutil.copy2(file_path, backup_path)
    print(f"âœ… Backup created: {backup_path}")
    return backup_path


def get_existing_columns(cursor: sqlite3.Cursor, table_name: str) -> list[str]:
    """Get list of existing columns in a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return [row[1] for row in cursor.fetchall()]


def migrate_database(file_path: str) -> None:
    """Migrate an existing .dyn database to the new schema."""

    if not Path(file_path).exists():
        print(f"âŒ Error: File '{file_path}' not found")
        sys.exit(1)

    print(f"Migrating database: {file_path}")
    print("=" * 60)

    # Create backup
    backup_path = backup_database(file_path)

    try:
        # Connect to database
        conn = sqlite3.connect(file_path)
        conn.execute("PRAGMA foreign_keys = ON;")
        cursor = conn.cursor()

        # Migrate Person table
        print("\nðŸ“ Migrating Person table...")
        person_columns = get_existing_columns(cursor, "Person")

        person_migrations = [
            ("birth_day", "ALTER TABLE Person ADD COLUMN birth_day INTEGER"),
            ("death_day", "ALTER TABLE Person ADD COLUMN death_day INTEGER"),
            ("arrival_day", "ALTER TABLE Person ADD COLUMN arrival_day INTEGER"),
            ("moved_out_day", "ALTER TABLE Person ADD COLUMN moved_out_day INTEGER"),
            ("maiden_name", "ALTER TABLE Person ADD COLUMN maiden_name TEXT"),
            ("family_id", "ALTER TABLE Person ADD COLUMN family_id INTEGER REFERENCES Family(id) ON DELETE SET NULL"),
            ("notes", "ALTER TABLE Person ADD COLUMN notes TEXT"),
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
        ]

        for col_name, sql in person_migrations:
            if col_name not in person_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Event table
        print("\nðŸ“ Migrating Event table...")
        event_columns = get_existing_columns(cursor, "Event")

        event_migrations = [
            ("start_day", "ALTER TABLE Event ADD COLUMN start_day INTEGER"),
            ("end_day", "ALTER TABLE Event ADD COLUMN end_day INTEGER"),
        ]

        for col_name, sql in event_migrations:
            if col_name not in event_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Marriage table
        print("\nðŸ“ Migrating Marriage table...")
        marriage_columns = get_existing_columns(cursor, "Marriage")

        marriage_migrations = [
            ("marriage_day", "ALTER TABLE Marriage ADD COLUMN marriage_day INTEGER"),
            ("dissolution_day", "ALTER TABLE Marriage ADD COLUMN dissolution_day INTEGER"),
            ("marriage_type", "ALTER TABLE Marriage ADD COLUMN marriage_type TEXT DEFAULT 'spouse'"),
        ]

        for col_name, sql in marriage_migrations:
            if col_name not in marriage_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Create new tables
        print("\nðŸ“ Creating new tables...")

        new_tables = {
            "Portrait": """
                CREATE TABLE IF NOT EXISTS Portrait (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    person_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    valid_from_year INTEGER,
                    valid_from_month INTEGER,
                    valid_from_day INTEGER,
                    valid_to_year INTEGER,
                    valid_to_month INTEGER,
                    valid_to_day INTEGER,
                    is_primary INTEGER DEFAULT 0,
                    display_order INTEGER DEFAULT 0,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Family": """
                CREATE TABLE IF NOT EXISTS Family (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    surname TEXT NOT NULL,
                    move_in_year INTEGER,
                    move_in_month INTEGER,
                    move_in_day INTEGER,
                    coat_of_arms_path TEXT,
                    family_color TEXT,
                    is_extinct INTEGER DEFAULT 0,
                    notes TEXT
                )
            """,
            "MajorEvent": """
                CREATE TABLE IF NOT EXISTS MajorEvent (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_name TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    start_year INTEGER NOT NULL,
                    start_month INTEGER,
                    start_day INTEGER,
                    end_year INTEGER,
                    end_month INTEGER,
                    end_day INTEGER,
                    description TEXT,
                    color TEXT
                )
            """,
            "PersonPosition": """
                CREATE TABLE IF NOT EXISTS PersonPosition (
                    person_id INTEGER PRIMARY KEY,
                    view_type TEXT NOT NULL,
                    x_position REAL NOT NULL,
                    y_position REAL NOT NULL,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Settings": """
                CREATE TABLE IF NOT EXISTS Settings (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL
                )
            """
        }

        for table_name, create_sql in new_tables.items():
            # Check if table exists
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (table_name,)
            )
            if cursor.fetchone():
                print(f"  â­ï¸  Table already exists: {table_name}")
            else:
                cursor.execute(create_sql)
                print(f"  âœ… Created table: {table_name}")

        # Commit all changes
        conn.commit()
        conn.close()

        print("\n" + "=" * 60)
        print("âœ… Migration completed successfully!")
        print(f"âœ… Original database backed up to: {backup_path}")
        print(f"âœ… Migrated database: {file_path}")
        print("\nYour database is now ready for the full feature set!")
        print("All existing data has been preserved.")

    except Exception as e:
        print(f"\nâŒ Migration failed: {e}")
        print(f"Restoring from backup: {backup_path}")
        shutil.copy2(backup_path, file_path)
        print("âœ… Database restored to original state")
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/migrate_database.py <path_to_dynasty_file.dyn>")
        print("\nExample:")
        print('  python scripts/migrate_database.py "MyDynasty.dyn"')
        sys.exit(1)

    dynasty_file = sys.argv[1]
    migrate_database(dynasty_file)


>> âœ… scripts\test_edit_person_dialog.py (21 code lines)
import sys
from PySide6.QtWidgets import QApplication

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from dialogs.edit_person_dialog import EditPersonDialog

app = QApplication(sys.argv)

# Open database
db = DatabaseManager(None)
db.open_database("Struggberg Family Tree 1.dyn")  # Use your actual .dyn file

# Get a person to edit
repo = PersonRepository(db)
people = repo.get_all()

if people:
    person = people[0]  # Edit the first person
    
    dialog = EditPersonDialog(db, person)
    result = dialog.exec()
    
    if result:
        print("User clicked Save")
    else:
        print("User clicked Cancel")
else:
    print("No people in database!")

sys.exit(0)

>> ðŸ“‹ scripts\test_person_box.py (17 code lines)
"""Test script to visualize PersonBox widgets."""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from PySide6.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QMainWindow, QVBoxLayout, QWidget
from PySide6.QtGui import QBrush, QColor, QPainter


class TestWindow(QMainWindow):
    """Simple test window to display PersonBox widgets."""
    
    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.setWindowTitle("PersonBox Test")
        self.setGeometry(100, 100, 1200, 800)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        self.scene = QGraphicsScene()
        self.view = QGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setBackgroundBrush(QBrush(QColor(240, 240, 240)))
        
        layout.addWidget(self.view)
        
        self._add_test_person_boxes()
    
    def _add_test_person_boxes(self):
        """Add a few PersonBox widgets to test the display."""
        if not self.db or not self.db.conn:
            print("No database connection!")
            return
        
        # Import here to avoid issues
        from views.tree_view.person_box import PersonBox
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT id FROM Person LIMIT 6")
        people = cursor.fetchall()
        
        x = 50
        y = 50
        spacing_x = 320
        spacing_y = 150
        
        for i, person_row in enumerate(people):
            person_id = person_row['id']
            
            person_box = PersonBox(person_id, self.db)
            
            # Connect signals
            person_box.person_double_clicked.connect(self.on_person_double_clicked)
            person_box.person_selected.connect(self.on_person_selected)
            
            col = i % 3
            row = i // 3
            person_box.setPos(x + col * spacing_x, y + row * spacing_y)
            
            self.scene.addItem(person_box)
        
        self.scene.setSceneRect(0, 0, 1100, 600)
    
    def on_person_double_clicked(self, person_id: int):
        """Handle person double-click."""
        print(f"Double-clicked person ID: {person_id}")
    
    def on_person_selected(self, person_id: int):
        """Handle person selection."""
        print(f"Selected person ID: {person_id}")


if __name__ == "__main__":
    print("PersonBox Test")
    print("-" * 50)
    
    db_file = r"D:\Programs\DynastyVizualizer\Struggberg Family Tree 1.dyn"
    
    from database.db_manager import DatabaseManager
    
    db = DatabaseManager(None)
    db.open_database(db_file)
    
    app = QApplication(sys.argv)
    window = TestWindow(db)
    window.show()
    sys.exit(app.exec())
    
    from database.db_manager import DatabaseManager
    
    db = DatabaseManager(None)
    db.open_database(db_file)
    
    app = QApplication(sys.argv)
    window = TestWindow(db)
    window.show()
    sys.exit(app.exec())


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONFIGURATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> requirements.txt
packaging==25.0
PySide6==6.10.1
PySide6_Addons==6.10.1
PySide6_Essentials==6.10.1
QtPy==2.4.3
shiboken6==6.10.1



======================================================================
END - 41/106 files, 4499 code lines
======================================================================
