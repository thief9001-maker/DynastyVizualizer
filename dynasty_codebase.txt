======================================================================
DynastyVizualizer - Complete Codebase
======================================================================
Generated: 2026-01-03 08:12
Files: 30/105 implemented | 2967 code lines
Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern
Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)
======================================================================

QUICK CONTEXT:
Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,
undo/redo, flexible dates, special char support, DB migration.
Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database

FILE INDEX:
Core: main.py
Database: 
	database\__init__.py, 
	database\db_manager.py,
	database\event_repository.py, 
	database\marriage_repository.py, 
	database\person_repository.py
Models:
	models\__init__.py, 
	models\event.py, 
	models\family.py, 
	models\major_event.py, 
	models\marriage.py, 
	models\person.py, 
	models\portrait.py
Actions:
	actions\__init__.py,
	actions\edit_actions.py, 
	actions\file_actions.py, 
	actions\help_actions.py, 
	actions\settings_actions.py, 
	actions\tools_actions.py, 
	actions\view_actions.py
Commands: 
	commands\__init__.py, 
	commands\base_command.py, 
		commands\genealogy_commands\__init__.py, 
		commands\genealogy_commands\add_event.py, 
		commands\genealogy_commands\add_marriage.py,
		commands\genealogy_commands\add_person.py, 
		commands\genealogy_commands\assign_parent.py, 
		commands\genealogy_commands\create_child.py,
		commands\genealogy_commands\delete_event.py, 
		commands\genealogy_commands\delete_marriage.py, 
		commands\genealogy_commands\delete_person.py, 
		commands\genealogy_commands\edit_event.py, 
		commands\genealogy_commands\edit_marriage.py, 
		commands\genealogy_commands\edit_person.py, 
		commands\genealogy_commands\end_marriage.py, 
		commands\genealogy_commands\unassign_parent.py, 
		
		commands\GUI_commands\__init__.py, 
		commands\GUI_commands\change_skin.py, 
		commands\GUI_commands\change_view.py, 
		commands\GUI_commands\move_node.py, 
		commands\GUI_commands\move_person.py, 
		commands\GUI_commands\preference_changes.py, 
		commands\GUI_commands\rebuild_scene.py, 
		commands\GUI_commands\recompute_generation.py, 
		commands\GUI_commands\recompute_generations.py, 
		commands\GUI_commands\timeline_scroll.py, 
		commands\undo_redo_manager.py, 
		commands\view_changes.py
Dialogs:
	dialogs\__init__.py, 
	dialogs\about_dialog.py, 
	dialogs\add_person_dialog.py, 
	dialogs\create_child_dialog.py, 
	dialogs\create_event_dialog.py, 
	dialogs\create_marriage_dialog.py, 
	dialogs\edit_event_dialog.py, 
	dialogs\edit_person_dialog.py, 
		dialogs\edit_person_panels\__init__.py, 
		dialogs\edit_person_panels\event_panel.py, 
		dialogs\edit_person_panels\general_panel.py, 
		dialogs\edit_person_panels\relationships_panel.py, 
	dialogs\end_marriage_dialog.py, 
	dialogs\import_csv_dialog.py, 
	dialogs\settings_dialog.py
Views: 
	views\__init__.py, 
	views\data_table_view.py, 
	views\dynasty_view.py, 
		views\stats_view\charts.py, 
		views\stats_view\comparison_widget.py, 
		views\stats_view\family_dashboard.py,
 
		views\table_view\event_table.py, 
		views\table_view\family_table.py, 
		views\table_view\marriage_table.py, 
		views\table_view\person_table.py, 

		views\timeline_view\event_marker.py, 
		views\timeline_view\family_bar.py, 
		views\timeline_view\major_event_marker.py, 
		views\timeline_view\person_bar.py, 
		views\timeline_view\timeline_canvas.py, 
		views\timeline_view.py, 

		views\tree_view\__init__.py, 
		views\tree_view\enhanced_tooltip_panel.py, 
		views\tree_view\generation_band.py, 
		views\tree_view\layout_engine.py, 
		views\tree_view\marriage_node.py, 
		views\tree_view\person_box.py, 
		views\tree_view\relationship_line.py, 
		views\tree_view\tree_canvas.py
Widgets: 
	widgets\__init__.py, 
	widgets\date_picker.py, 
	widgets\extended_details_panel.py, 
	widgets\person_selector.py, 
	widgets\portrait_gallery.py, 
	widgets\search_bar.py
Utils: 
	utils\__init__.py, 
	utils\color_manager.py, 
	utils\csv_importer.py, 
	utils\generation_calculator.py, 
	utils\relationship_calculator.py, 
	utils\settings_manager.py, 
	utils\skin_manager.py, 
	utils\validators.py
Scripts:
	scripts\create_codebase_summary.py, 
	scripts\migrate_database.py, 
	scripts\test_edit_person_dialog.py,
	scripts\test_person_box.py

======================================================================
COMPLETE SOURCE CODE
======================================================================


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… main.py (180 code lines)
"""Main application window for Dynasty Visualizer."""

import sys, os

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QMenuBar, QMessageBox,
    QStackedWidget, QLabel
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QAction

from database.db_manager import DatabaseManager
from actions import FileActions, EditActions, ViewActions, ToolsActions, HelpActions, SettingsActions
from commands.undo_redo_manager import UndoRedoManager
from utils.settings_manager import SettingsManager


class MainWindow(QMainWindow):
    """Main application window for Dynasty Visualizer."""

    def __init__(self) -> None:
        super().__init__()

        self.setWindowTitle("Dynasty Visualizer")
        self.resize(1000, 700)

        self.db = DatabaseManager(self)
        self.undo_manager = UndoRedoManager()
        self.settings_manager = SettingsManager()

        self.file_actions = FileActions(self)
        self.edit_actions = EditActions(self)
        self.view_actions = ViewActions(self)
        self.tools_actions = ToolsActions(self)
        self.settings_actions = SettingsActions(self)
        self.help_actions = HelpActions(self)

        self._setup_central_widget()
        self._create_menus()
        self._connect_actions()
        
        self._create_untitled_database()

        self._show_family_trees()
        
        self._update_window_title()
        self._update_menu_states()

    def _create_untitled_database(self) -> None:
        """Create a temporary database for new sessions."""
        import tempfile
        
        temp_dir = tempfile.gettempdir()
        temp_file = os.path.join(temp_dir, "dynasty_untitled.dyn")
        
        if os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except:
                pass
        
        self.db.new_database(temp_file)

        self.db._temp_file_path = temp_file
        self.db.file_path = None
        
        self.refresh_ui()

    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------

    def _setup_central_widget(self) -> None:
        """Setup the central widget with stacked views."""
        self.view_stack = QStackedWidget()
        self.setCentralWidget(self.view_stack)
        
        self.genealogy_view = None
        self.timeline_view = None
        self.dynasty_view = None
        self.data_table_view = None

    def _create_menus(self) -> None:
        """Create all menu bars and menu items."""
        menubar = self.menuBar()

        self._create_file_menu(menubar)
        self._create_edit_menu(menubar)
        self._create_view_menu(menubar)
        self._create_tools_menu(menubar)
        self._create_settings_menu(menubar)
        self._create_help_menu(menubar)

    def _create_file_menu(self, menubar: QMenuBar) -> None:
        """Create the File menu."""
        file_menu = menubar.addMenu("File")

        self.action_new_dynasty = QAction("New Dynasty", self)
        self.action_new_dynasty.setObjectName("file.new")
        self.action_new_dynasty.setShortcut(self.settings_manager.get_shortcut("file.new"))

        self.action_open_dynasty = QAction("Open Dynasty", self)
        self.action_open_dynasty.setObjectName("file.open")
        self.action_open_dynasty.setShortcut(self.settings_manager.get_shortcut("file.open"))

        file_menu.addAction(self.action_new_dynasty)
        file_menu.addAction(self.action_open_dynasty)

        self.recent_files_menu = file_menu.addMenu("Recent Files")
        self._update_recent_files_menu()
        
        file_menu.addSeparator()

        self.action_save = QAction("Save", self)
        self.action_save.setObjectName("file.save")
        self.action_save.setShortcut(self.settings_manager.get_shortcut("file.save"))
        
        self.action_save_as = QAction("Save As", self)
        self.action_save_as.setObjectName("file.save_as")
        self.action_save_as.setShortcut(self.settings_manager.get_shortcut("file.save_as"))

        file_menu.addAction(self.action_save)
        file_menu.addAction(self.action_save_as)
        file_menu.addSeparator()

        self.action_exit = QAction("Exit", self)
        self.action_exit.setObjectName("file.exit")
        self.action_exit.setShortcut(self.settings_manager.get_shortcut("file.exit"))
        
        file_menu.addAction(self.action_exit)

    def _create_edit_menu(self, menubar: QMenuBar) -> None:
        """Create the Edit menu."""
        edit_menu = menubar.addMenu("Edit")

        self.action_undo = QAction("Undo", self)
        self.action_undo.setObjectName("edit.undo")
        self.action_undo.setShortcut(self.settings_manager.get_shortcut("edit.undo"))

        self.action_redo = QAction("Redo", self)
        self.action_redo.setObjectName("edit.redo")
        self.action_redo.setShortcut(self.settings_manager.get_shortcut("edit.redo"))
        
        self.action_add_person = QAction("Add Person", self)
        self.action_add_person.setObjectName("edit.add_person")
        self.action_add_person.setShortcut(self.settings_manager.get_shortcut("edit.add_person"))

        self.action_edit_person = QAction("Edit Person", self)
        self.action_edit_person.setObjectName("edit.edit_person")
        self.action_edit_person.setShortcut("Ctrl+E")  # Add to settings_manager later

        self.action_remove_person = QAction("Remove Person", self)
        self.action_remove_person.setObjectName("edit.remove_person")
        self.action_remove_person.setShortcut(self.settings_manager.get_shortcut("edit.remove_person"))

        self.action_add_new_family = QAction("Add New Family", self)
        self.action_add_new_family.setObjectName("edit.add_new_family")
        self.action_add_new_family.setShortcut(self.settings_manager.get_shortcut("edit.add_new_family"))
        self.action_add_new_family.setEnabled(False)  # Disabled for now

        edit_menu.addAction(self.action_undo)
        edit_menu.addAction(self.action_redo)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_person)
        edit_menu.addAction(self.action_edit_person)
        edit_menu.addAction(self.action_remove_person)
        edit_menu.addSeparator()
        edit_menu.addAction(self.action_add_new_family)

        self.edit_actions.undo_action = self.action_undo
        self.edit_actions.redo_action = self.action_redo
        self.edit_actions.update_undo_redo_actions()

    def _create_view_menu(self, menubar: QMenuBar) -> None:
        """Create the View menu."""
        view_menu = menubar.addMenu("View")

        self.action_view_family_trees = QAction("Family Trees", self)
        self.action_view_family_trees.setObjectName("view.family_trees")
        self.action_view_family_trees.setShortcut(self.settings_manager.get_shortcut("view.family_trees"))

        self.action_view_timeline = QAction("Timeline", self)
        self.action_view_timeline.setObjectName("view.timeline")
        self.action_view_timeline.setShortcut(self.settings_manager.get_shortcut("view.timeline"))
        
        self.action_view_dynasty = QAction("Dynasty", self)
        self.action_view_dynasty.setObjectName("view.dynasty")
        self.action_view_dynasty.setShortcut(self.settings_manager.get_shortcut("view.dynasty"))

        self.action_view_data_table = QAction("Data Table", self)
        self.action_view_data_table.setObjectName("view.data_table")
        self.action_view_data_table.setShortcut(self.settings_manager.get_shortcut("view.data_table"))

        view_menu.addAction(self.action_view_family_trees)
        view_menu.addAction(self.action_view_timeline)
        view_menu.addAction(self.action_view_dynasty)
        view_menu.addAction(self.action_view_data_table)

    def _create_tools_menu(self, menubar: QMenuBar) -> None:
        """Create the Tools menu."""
        tools_menu = menubar.addMenu("Tools")

        self.action_rebuild_scene = QAction("Rebuild Scene", self)
        self.action_rebuild_scene.setObjectName("tools.rebuild_scene")
        self.action_rebuild_scene.setShortcut(self.settings_manager.get_shortcut("tools.rebuild_scene"))

        self.action_recompute_generations = QAction("Recompute Generations", self)
        self.action_recompute_generations.setObjectName("tools.recompute_generations")
        self.action_recompute_generations.setShortcut(self.settings_manager.get_shortcut("tools.recompute_generations"))
        
        self.action_validate_marriages = QAction("Validate Marriages", self)
        self.action_validate_marriages.setObjectName("tools.validate_marriages")
        self.action_validate_marriages.setShortcut(self.settings_manager.get_shortcut("tools.validate_marriages"))

        self.action_validate_parentage = QAction("Validate Parentage", self)
        self.action_validate_parentage.setObjectName("tools.validate_parentage")
        self.action_validate_parentage.setShortcut(self.settings_manager.get_shortcut("tools.validate_parentage"))

        tools_menu.addAction(self.action_rebuild_scene)
        tools_menu.addAction(self.action_recompute_generations)
        tools_menu.addAction(self.action_validate_marriages)
        tools_menu.addAction(self.action_validate_parentage)

    def _create_settings_menu(self, menubar: QMenuBar) -> None:
        """Create the Settings menu."""
        settings_menu = menubar.addMenu("Settings")

        self.action_settings = QAction("Settings", self)
        self.action_settings.setObjectName("settings.settings")
        self.action_settings.setShortcut(self.settings_manager.get_shortcut("settings.settings"))

        self.action_general = QAction("General", self)
        self.action_general.setObjectName("settings.general")
        self.action_general.setShortcut(self.settings_manager.get_shortcut("settings.general"))

        self.action_shortcuts = QAction("Shortcuts", self)
        self.action_shortcuts.setObjectName("settings.shortcuts")
        self.action_shortcuts.setShortcut(self.settings_manager.get_shortcut("settings.shortcuts"))

        self.action_display = QAction("Display", self)
        self.action_display.setObjectName("settings.display")
        self.action_display.setShortcut(self.settings_manager.get_shortcut("settings.display"))

        self.action_appearance = QAction("Appearance", self)
        self.action_appearance.setObjectName("settings.appearance")
        self.action_appearance.setShortcut(self.settings_manager.get_shortcut("settings.appearance"))

        self.action_formats = QAction("Formats", self)
        self.action_formats.setObjectName("settings.formats")
        self.action_formats.setShortcut(self.settings_manager.get_shortcut("settings.formats"))

        settings_menu.addAction(self.action_settings)
        settings_menu.addSeparator()
        settings_menu.addAction(self.action_general)
        settings_menu.addAction(self.action_shortcuts)
        settings_menu.addAction(self.action_display)
        settings_menu.addAction(self.action_appearance)
        settings_menu.addAction(self.action_formats)

    def _create_help_menu(self, menubar: QMenuBar) -> None:
        """Create the Help menu."""
        help_menu = menubar.addMenu("Help")

        self.action_about = QAction("About", self)
        self.action_about.setObjectName("help.about")
        self.action_about.setShortcut(self.settings_manager.get_shortcut("help.about"))
        help_menu.addAction(self.action_about)

    # ------------------------------------------------------------------
    # Action Connections
    # ------------------------------------------------------------------

    def _connect_actions(self) -> None:
        """Connect all menu actions to their handler methods."""
        self.action_new_dynasty.triggered.connect(self.file_actions.new_dynasty)
        self.action_open_dynasty.triggered.connect(self.file_actions.open_dynasty)
        self.action_save.triggered.connect(self.file_actions.save)
        self.action_save_as.triggered.connect(self.file_actions.save_as)
        self.action_exit.triggered.connect(self.file_actions.exit_app)

        self.action_undo.triggered.connect(self.edit_actions.undo)
        self.action_redo.triggered.connect(self.edit_actions.redo)
        self.action_add_person.triggered.connect(self.edit_actions.add_person)
        self.action_edit_person.triggered.connect(self._edit_selected_person)
        self.action_remove_person.triggered.connect(self.edit_actions.remove_person)
        self.action_add_new_family.triggered.connect(self.edit_actions.add_new_family)

        self.action_view_family_trees.triggered.connect(self._show_family_trees)
        self.action_view_timeline.triggered.connect(self._show_timeline)
        self.action_view_dynasty.triggered.connect(self._show_dynasty)
        self.action_view_data_table.triggered.connect(self._show_data_table)

        self.action_rebuild_scene.triggered.connect(self.tools_actions.rebuild_scene)
        self.action_recompute_generations.triggered.connect(self.tools_actions.recompute_generations)
        self.action_validate_marriages.triggered.connect(self.tools_actions.validate_marriages)
        self.action_validate_parentage.triggered.connect(self.tools_actions.validate_parentage)

        self.action_settings.triggered.connect(self.settings_actions.settings)
        self.action_general.triggered.connect(self.settings_actions.general)
        self.action_shortcuts.triggered.connect(self.settings_actions.shortcuts)
        self.action_display.triggered.connect(self.settings_actions.display)
        self.action_appearance.triggered.connect(self.settings_actions.appearance)
        self.action_formats.triggered.connect(self.settings_actions.formats)

        self.action_about.triggered.connect(self.help_actions.about)

    # ------------------------------------------------------------------
    # Recent Files Management
    # ------------------------------------------------------------------

    def _update_recent_files_menu(self) -> None:
        """Update the Recent Files submenu with current list."""
        self.recent_files_menu.clear()
        
        recent = self.settings_manager.get_recent_files()
        
        if recent:
            for path in recent:
                filename = os.path.basename(path)
                action = QAction(filename, self)
                action.setData(path)
                action.triggered.connect(lambda checked, p=path: self._open_recent_file(p))
                self.recent_files_menu.addAction(action)
            
            self.recent_files_menu.addSeparator()
            
            clear_action = QAction("Clear Recent Files", self)
            clear_action.triggered.connect(self._clear_recent_files)
            self.recent_files_menu.addAction(clear_action)
        else:
            no_recent = QAction("(No Recent Files)", self)
            no_recent.setEnabled(False)
            self.recent_files_menu.addAction(no_recent)

    def _open_recent_file(self, path: str) -> None:
        """Open a file from recent files list."""
        if not os.path.exists(path):
            QMessageBox.warning(
                self,
                "File Not Found",
                f"The file '{path}' no longer exists."
            )
            self._remove_from_recent_files(path)
            return
        
        try:
            self.db.open_database(path)
            self.refresh_ui()
            self.file_actions._refresh_all_views()
            self.settings_manager.add_recent_file(path)
            self._update_recent_files_menu()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to open file:\n{str(e)}")

    def _remove_from_recent_files(self, path: str) -> None:
        """Remove a file from recent files list."""
        recent = self.settings_manager.get_recent_files()
        if path in recent:
            recent.remove(path)
            self.settings_manager.clear_recent_files()
            for p in recent:
                self.settings_manager.add_recent_file(p)
        self._update_recent_files_menu()

    def _clear_recent_files(self) -> None:
        """Clear the recent files list."""
        self.settings_manager.clear_recent_files()
        self._update_recent_files_menu()

    # ------------------------------------------------------------------
    # View Management
    # ------------------------------------------------------------------

    def _show_family_trees(self) -> None:
        """Switch to family trees view."""
        if self.genealogy_view is None:
            genealogy_placeholder = QLabel("Genealogy View\n(Coming Soon!)")
            genealogy_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            genealogy_placeholder.setStyleSheet("font-size: 24px; color: gray;")
            self.genealogy_view = genealogy_placeholder
            self.view_stack.addWidget(self.genealogy_view)
        
        self.view_stack.setCurrentWidget(self.genealogy_view)

    def _show_timeline(self) -> None:
        """Switch to timeline view."""
        if self.timeline_view is None:
            timeline_placeholder = QLabel("Timeline View\n(Coming Soon!)")
            timeline_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            timeline_placeholder.setStyleSheet("font-size: 24px; color: gray;")
            self.timeline_view = timeline_placeholder
            self.view_stack.addWidget(self.timeline_view)
        
        self.view_stack.setCurrentWidget(self.timeline_view)

    def _show_dynasty(self) -> None:
        """Switch to dynasty view."""
        if self.dynasty_view is None:
            dynasty_placeholder = QLabel("Dynasty View\n(Coming Soon!)")
            dynasty_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            dynasty_placeholder.setStyleSheet("font-size: 24px; color: gray;")
            self.dynasty_view = dynasty_placeholder
            self.view_stack.addWidget(self.dynasty_view)
        
        self.view_stack.setCurrentWidget(self.dynasty_view)

    def _show_data_table(self) -> None:
        """Switch to data table view."""
        if self.data_table_view is None:
            from views.data_table_view import DataTableView
            self.data_table_view = DataTableView(self.db, self)
            self.view_stack.addWidget(self.data_table_view)
        
        self.data_table_view.refresh_data()
        self.view_stack.setCurrentWidget(self.data_table_view)

    def _edit_selected_person(self) -> None:
        """Edit the currently selected person in the active view."""
        if self.data_table_view and self.view_stack.currentWidget() == self.data_table_view:
            self.data_table_view._edit_selected_person()
        else:
            QMessageBox.information(
                self,
                "Edit Person",
                "Please select a person to edit."
            )

    # ------------------------------------------------------------------
    # UI Update Methods
    # ------------------------------------------------------------------

    def _update_window_title(self) -> None:
        """Update the window title to reflect current database state."""
        if self.db.is_open:
            if self.db.file_path is None:
                title = "Dynasty Visualizer - Untitled *"
            else:
                dirty_marker = " *" if self.db.is_dirty else ""
                title = f"Dynasty Visualizer - {self.db.database_name}{dirty_marker}"
            self.setWindowTitle(title)
        else:
            self.setWindowTitle("Dynasty Visualizer")

    def _update_menu_states(self) -> None:
        """Enable or disable menu items based on current state."""
        has_db = self.db.is_open

        # Always allow Save/Save As even for untitled
        self.action_save.setEnabled(has_db)
        self.action_save_as.setEnabled(has_db)

        self.action_undo.setEnabled(self.undo_manager.can_undo())
        self.action_redo.setEnabled(self.undo_manager.can_redo())
        self.action_add_person.setEnabled(has_db)
        self.action_edit_person.setEnabled(has_db)
        self.action_remove_person.setEnabled(has_db)

        self.action_view_family_trees.setEnabled(has_db)
        self.action_view_timeline.setEnabled(has_db)
        self.action_view_dynasty.setEnabled(has_db)
        self.action_view_data_table.setEnabled(has_db)

        self.action_rebuild_scene.setEnabled(has_db)
        self.action_recompute_generations.setEnabled(has_db)
        self.action_validate_marriages.setEnabled(has_db)
        self.action_validate_parentage.setEnabled(has_db)

    def refresh_ui(self) -> None:
        """Refresh window title and menu states after database changes."""
        self._update_window_title()
        self._update_menu_states()

    # ------------------------------------------------------------------
    # Event Handlers
    # ------------------------------------------------------------------

    def closeEvent(self, event) -> None:
        """Handle window close event."""
        if self.db.is_open and self.db.is_dirty:
            msg = QMessageBox(self)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:
                if self.file_actions.save():
                    event.accept()
                else:
                    event.ignore()
            elif choice == QMessageBox.StandardButton.Discard:
                event.accept()
            else: 
                event.ignore()
        else:
            event.accept()


def main() -> None:
    """Application entry point."""
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ database\__init__.py (3 code lines)
from .db_manager import DatabaseManager
from .person_repository import PersonRepository

__all__ = ['DatabaseManager', 'PersonRepository']

>> âœ… database\db_manager.py (112 code lines)
"""Manages SQLite-based .dyn dynasty database files."""

import sqlite3
import shutil
import os


class DatabaseManager:
    """Manages SQLite-based .dyn dynasty database files."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        self.parent = parent
        self.conn: sqlite3.Connection | None = None
        self.file_path: str | None = None
        self._temp_file_path: str | None = None
        self._unsaved_changes: bool = False

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def is_dirty(self) -> bool:
        """Check if there are unsaved changes."""
        return self._unsaved_changes

    @property
    def is_open(self) -> bool:
        """Check if a database is currently open."""
        return self.conn is not None

    @property
    def database_name(self) -> str | None:
        """Get the filename of the current database without path."""
        return os.path.basename(self.file_path) if self.file_path else None

    @property
    def database_directory(self) -> str | None:
        """Get the directory path of the current database."""
        return os.path.dirname(self.file_path) if self.file_path else None

    @property
    def has_file_path(self) -> bool:
        """Check if database has an associated file path."""
        return self.file_path is not None

    # ------------------------------------------------------------------
    # Public Methods - Database Lifecycle
    # ------------------------------------------------------------------

    def new_database(self, file_path: str) -> None:
        """Create a brand-new .dyn file with the dynasty schema."""
        if os.path.exists(file_path):
            os.remove(file_path)
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._initialize_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to create database: {e}")

    def open_database(self, file_path: str) -> None:
        """Open an existing .dyn database file."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} does not exist.")
        
        try:
            self.conn = sqlite3.connect(file_path)
            self.conn.row_factory = sqlite3.Row
            self.conn.execute("PRAGMA foreign_keys = ON;")
            self.file_path = file_path
            self._migrate_schema()
            self._unsaved_changes = False
        except sqlite3.Error as e:
            raise RuntimeError(f"Failed to open database: {e}")

    def save_database(self, path: str | None = None) -> bool:
        """Save database, optionally to a new path."""
        if self.conn is None:
            return False
        
        if path is None:
            self.conn.commit()
            self._unsaved_changes = False
            return True
        
        self.conn.commit()
        
        current_path = self.file_path or getattr(self, '_temp_file_path', None)
        
        self.conn.close()
        
        if current_path and os.path.exists(current_path):
            shutil.copy2(current_path, path)
        else:
            raise RuntimeError("Cannot save: no source database file")
        
        self.conn = sqlite3.connect(path)
        self.conn.row_factory = sqlite3.Row
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.file_path = path
        self._unsaved_changes = False
        
        return True

    def close(self) -> None:
        """Close the current database connection and reset state."""
        if self.conn:
            self.conn.close()
        self.conn = None
        self.file_path = None
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Public Methods - State Management
    # ------------------------------------------------------------------

    def mark_dirty(self) -> None:
        """Mark the database as having unsaved changes."""
        if self.conn is not None:
            self._unsaved_changes = True

    def mark_clean(self) -> None:
        """Mark the database as having no unsaved changes."""
        self._unsaved_changes = False

    # ------------------------------------------------------------------
    # Private Methods - Schema Management
    # ------------------------------------------------------------------

    def _initialize_schema(self) -> None:
        """Create all required tables for a new dynasty database."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
        
        cursor = self.conn.cursor()

        schema_sql = """
        CREATE TABLE IF NOT EXISTS Person (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            middle_name TEXT DEFAULT '',
            last_name TEXT NOT NULL,
            maiden_name TEXT,
            nickname TEXT DEFAULT '',
            gender TEXT,
            birth_year INTEGER,
            birth_month INTEGER,
            birth_day INTEGER,
            death_year INTEGER,
            death_month INTEGER,
            death_day INTEGER,
            arrival_year INTEGER,
            arrival_month INTEGER,
            arrival_day INTEGER,
            moved_out_year INTEGER,
            moved_out_month INTEGER,
            moved_out_day INTEGER,
            father_id INTEGER,
            mother_id INTEGER,
            family_id INTEGER,
            dynasty_id INTEGER DEFAULT 1,
            is_founder INTEGER DEFAULT 0,
            education INTEGER DEFAULT 0,
            is_favorite INTEGER DEFAULT 0,
            notes TEXT,
            FOREIGN KEY(father_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(mother_id) REFERENCES Person(id) ON DELETE SET NULL,
            FOREIGN KEY(family_id) REFERENCES Family(id) ON DELETE SET NULL
        );

        CREATE TABLE IF NOT EXISTS Event (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            event_title TEXT NOT NULL,
            start_year INTEGER,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            notes TEXT,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS Marriage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            spouse1_id INTEGER,
            spouse2_id INTEGER,
            marriage_year INTEGER,
            marriage_month INTEGER,
            marriage_day INTEGER,
            dissolution_year INTEGER,
            dissolution_month INTEGER,
            dissolution_day INTEGER,
            dissolution_reason TEXT,
            marriage_type TEXT DEFAULT 'spouse',
            notes TEXT,
            FOREIGN KEY(spouse1_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL,
            FOREIGN KEY(spouse2_id) REFERENCES Person(id)
                ON UPDATE CASCADE ON DELETE SET NULL
        );

        CREATE TABLE IF NOT EXISTS Portrait (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            person_id INTEGER NOT NULL,
            image_path TEXT NOT NULL,
            valid_from_year INTEGER,
            valid_from_month INTEGER,
            valid_from_day INTEGER,
            valid_to_year INTEGER,
            valid_to_month INTEGER,
            valid_to_day INTEGER,
            is_primary INTEGER DEFAULT 0,
            display_order INTEGER DEFAULT 0,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS Family (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            surname TEXT NOT NULL,
            move_in_year INTEGER,
            move_in_month INTEGER,
            move_in_day INTEGER,
            coat_of_arms_path TEXT,
            family_color TEXT,
            is_extinct INTEGER DEFAULT 0,
            notes TEXT
        );

        CREATE TABLE IF NOT EXISTS MajorEvent (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT NOT NULL,
            event_type TEXT NOT NULL,
            start_year INTEGER NOT NULL,
            start_month INTEGER,
            start_day INTEGER,
            end_year INTEGER,
            end_month INTEGER,
            end_day INTEGER,
            description TEXT,
            color TEXT
        );

        CREATE TABLE IF NOT EXISTS PersonPosition (
            person_id INTEGER PRIMARY KEY,
            view_type TEXT NOT NULL,
            x_position REAL NOT NULL,
            y_position REAL NOT NULL,
            FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
        );
        """
        cursor.executescript(schema_sql)
        self.conn.commit()
    
    def _migrate_schema(self) -> None:
        """Migrate existing database schema to latest version."""
        if self.conn is None:
            raise RuntimeError("Database connection is not established.")
        
        cursor = self.conn.cursor()
        
        self._migrate_person_table(cursor)
        self._migrate_marriage_table(cursor)
        self._migrate_event_table_data(cursor)
        self._migrate_person_table_data(cursor)

        self.conn.commit()
    
    def _migrate_person_table(self, cursor: sqlite3.Cursor) -> None:
        """Apply Person table schema migrations."""
        existing_columns = self._get_table_columns(cursor, "Person")
        
        migrations = [
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
            ("is_favorite", "ALTER TABLE Person ADD COLUMN is_favorite INTEGER DEFAULT 0"),
        ]
        
        self._apply_column_migrations(cursor, existing_columns, migrations)
    
    def _migrate_marriage_table(self, cursor: sqlite3.Cursor) -> None:
        """Apply Marriage table schema migrations."""
        existing_columns = self._get_table_columns(cursor, "Marriage")
        
        migrations = [
            ("notes", "ALTER TABLE Marriage ADD COLUMN notes TEXT"),
        ]
        
        self._apply_column_migrations(cursor, existing_columns, migrations)
    
    def _migrate_event_table_data(self, cursor: sqlite3.Cursor) -> None:
        """Convert Event table month names from text to integers."""
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='Event'")
        if not cursor.fetchone():
            return
        
        cursor.execute("SELECT id, start_month FROM Event WHERE start_month IS NOT NULL LIMIT 1")
        row = cursor.fetchone()
        
        if not row or not row[1]:
            return
        
        if isinstance(row[1], str) and not row[1].isdigit():
            self._convert_event_months_to_integers(cursor)
    
    def _convert_event_months_to_integers(self, cursor: sqlite3.Cursor) -> None:
        """Convert text month names to integer values in Event table."""
        month_map = {
            "January": 1, "February": 2, "March": 3, "April": 4,
            "May": 5, "June": 6, "July": 7, "August": 8,
            "September": 9, "October": 10, "November": 11, "December": 12
        }
        
        cursor.execute("""
            SELECT id, start_month, end_month 
            FROM Event 
            WHERE start_month IS NOT NULL OR end_month IS NOT NULL
        """)
        
        for event_id, start_month, end_month in cursor.fetchall():
            new_start = month_map.get(start_month) if start_month else None
            new_end = month_map.get(end_month) if end_month else None
            
            cursor.execute("""
                UPDATE Event 
                SET start_month = ?, end_month = ? 
                WHERE id = ?
            """, (new_start, new_end, event_id))
    
    def _migrate_person_table_data(self, cursor: sqlite3.Cursor) -> None:
        """Convert Person table month names from text to integers."""
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='Person'")
        if not cursor.fetchone():
            return
        
        cursor.execute("SELECT id, birth_month FROM Person WHERE birth_month IS NOT NULL LIMIT 1")
        row = cursor.fetchone()
        
        if not row or not row[1]:
            return
        
        if isinstance(row[1], str) and not row[1].isdigit():
            self._convert_person_months_to_integers(cursor)

    def _convert_person_months_to_integers(self, cursor: sqlite3.Cursor) -> None:
        """Convert text month names to integer values in Person table."""
        month_map: dict[str, int] = {
            "January": 1, "February": 2, "March": 3, "April": 4,
            "May": 5, "June": 6, "July": 7, "August": 8,
            "September": 9, "October": 10, "November": 11, "December": 12
        }
        
        cursor.execute("""
            SELECT id, birth_month, death_month, arrival_month, moved_out_month
            FROM Person 
            WHERE birth_month IS NOT NULL 
            OR death_month IS NOT NULL 
            OR arrival_month IS NOT NULL 
            OR moved_out_month IS NOT NULL
        """)
        
        for person_id, birth_month, death_month, arrival_month, moved_out_month in cursor.fetchall():
            new_birth_month: int | None = month_map.get(birth_month) if birth_month else None
            new_death_month: int | None = month_map.get(death_month) if death_month else None
            new_arrival_month: int | None = month_map.get(arrival_month) if arrival_month else None
            new_moved_out_month: int | None = month_map.get(moved_out_month) if moved_out_month else None
            
            cursor.execute("""
                UPDATE Person 
                SET birth_month = ?, 
                    death_month = ?, 
                    arrival_month = ?, 
                    moved_out_month = ? 
                WHERE id = ?
            """, (new_birth_month, new_death_month, new_arrival_month, new_moved_out_month, person_id))    
    # ------------------------------------------------------------------
    # Private Methods - Utilities
    # ------------------------------------------------------------------
    
    @staticmethod
    def _get_table_columns(cursor: sqlite3.Cursor, table_name: str) -> set[str]:
        """Get set of column names for a table."""
        cursor.execute(f"PRAGMA table_info({table_name})")
        return {row[1] for row in cursor.fetchall()}
    
    @staticmethod
    def _apply_column_migrations(
        cursor: sqlite3.Cursor,
        existing_columns: set[str],
        migrations: list[tuple[str, str]]
    ) -> None:
        """Apply column addition migrations if columns don't exist."""
        for column_name, sql in migrations:
            if column_name not in existing_columns:
                cursor.execute(sql)

>> âœ… database\event_repository.py (32 code lines)
"""Repository for Event database operations."""

from database.db_manager import DatabaseManager
from models.event import Event


class EventRepository:
    """Handle database operations for events."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        self.db = db_manager
    
    def insert(self, event: Event) -> int:
        """Insert a new event into the database."""
        if not self.db.conn:
            return -1
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            INSERT INTO Event (
                person_id, event_type, event_title,
                start_year, start_month, start_day,
                end_year, end_month, end_day, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            event.person_id, event.event_type, event.event_title,
            event.start_year, event.start_month, event.start_day,
            event.end_year, event.end_month, event.end_day, event.notes
        ))
        
        self.db.conn.commit()
        return cursor.lastrowid or -1
    
    def get_by_id(self, event_id: int) -> Event | None:
        """Get an event by ID."""
        if not self.db.conn:
            return None
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, person_id, event_type, event_title,
                   start_year, start_month, start_day,
                   end_year, end_month, end_day, notes
            FROM Event
            WHERE id = ?
        """, (event_id,))
        
        row = cursor.fetchone()
        return self._row_to_event(row) if row else None
    
    def get_by_person(self, person_id: int) -> list[Event]:
        """Get all events for a person, sorted chronologically."""
        if not self.db.conn:
            return []
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, person_id, event_type, event_title,
                   start_year, start_month, start_day,
                   end_year, end_month, end_day, notes
            FROM Event
            WHERE person_id = ?
            ORDER BY start_year, start_month, start_day
        """, (person_id,))
        
        return [self._row_to_event(row) for row in cursor.fetchall()]
    
    def update(self, event: Event) -> None:
        """Update an existing event."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            UPDATE Event SET
                person_id = ?,
                event_type = ?,
                event_title = ?,
                start_year = ?,
                start_month = ?,
                start_day = ?,
                end_year = ?,
                end_month = ?,
                end_day = ?,
                notes = ?
            WHERE id = ?
        """, (
            event.person_id, event.event_type, event.event_title,
            event.start_year, event.start_month, event.start_day,
            event.end_year, event.end_month, event.end_day, event.notes,
            event.id
        ))
        
        self.db.conn.commit()
    
    def delete(self, event_id: int) -> None:
        """Delete an event by ID."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Event WHERE id = ?", (event_id,))
        self.db.conn.commit()
    
    @staticmethod
    def _to_int(value) -> int | None:
        """Convert database value to int or None."""
        return int(value) if value is not None else None
    
    def _row_to_event(self, row: tuple) -> Event:
        """Convert database row to Event object."""
        return Event(
            id=row[0],
            person_id=row[1],
            event_type=row[2] or "",
            event_title=row[3] or "",
            start_year=self._to_int(row[4]),
            start_month=self._to_int(row[5]),
            start_day=self._to_int(row[6]),
            end_year=self._to_int(row[7]),
            end_month=self._to_int(row[8]),
            end_day=self._to_int(row[9]),
            notes=row[10] or ""
        )

>> âœ… database\marriage_repository.py (85 code lines)
"""Repository for Marriage database operations."""

from database.db_manager import DatabaseManager
from models.marriage import Marriage


class MarriageRepository:
    """Handle database operations for marriages."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize the marriage repository."""
        self.db = db_manager
    
    def insert(self, marriage: Marriage) -> int:
        """Insert a new marriage into the database.
        
        Returns the new marriage ID, or -1 if database not open.
        """
        if not self.db.conn:
            return -1
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            INSERT INTO Marriage (
                spouse1_id, spouse2_id,
                marriage_year, marriage_month, marriage_day,
                dissolution_year, dissolution_month, dissolution_day,
                dissolution_reason, marriage_type, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes
        ))
        
        self.db.conn.commit()
        return cursor.lastrowid or -1
    
    def insert_with_id(self, marriage: Marriage) -> None:
        """Insert marriage with explicit ID (for undo/redo)."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            INSERT INTO Marriage (
                id, spouse1_id, spouse2_id,
                marriage_year, marriage_month, marriage_day,
                dissolution_year, dissolution_month, dissolution_day,
                dissolution_reason, marriage_type, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            marriage.id, marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes
        ))
        
        self.db.conn.commit()
    
    def get_by_id(self, marriage_id: int) -> Marriage | None:
        """Get a marriage by ID."""
        if not self.db.conn:
            return None
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE id = ?
        """, (marriage_id,))
        
        row = cursor.fetchone()
        if row:
            return self._row_to_marriage(row)
        return None
    
    def get_by_person(self, person_id: int) -> list[Marriage]:
        """Get all marriages for a person (as either spouse)."""
        if not self.db.conn:
            return []
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE spouse1_id = ? OR spouse2_id = ?
            ORDER BY marriage_year, marriage_month
        """, (person_id, person_id))
        
        return [self._row_to_marriage(row) for row in cursor.fetchall()]
    
    def get_active_marriages(self, person_id: int) -> list[Marriage]:
        """Get all active (not ended) marriages for a person."""
        if not self.db.conn:
            return []
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, spouse1_id, spouse2_id,
                   marriage_year, marriage_month, marriage_day,
                   dissolution_year, dissolution_month, dissolution_day,
                   dissolution_reason, marriage_type, notes
            FROM Marriage
            WHERE (spouse1_id = ? OR spouse2_id = ?)
              AND dissolution_year IS NULL
            ORDER BY marriage_year, marriage_month
        """, (person_id, person_id))
        
        return [self._row_to_marriage(row) for row in cursor.fetchall()]
    
    def get_spouse_id(self, marriage: Marriage, person_id: int) -> int | None:
        """Get the spouse ID for a given person in a marriage."""
        if marriage.spouse1_id == person_id:
            return marriage.spouse2_id
        elif marriage.spouse2_id == person_id:
            return marriage.spouse1_id
        return None
    
    def update(self, marriage: Marriage) -> None:
        """Update an existing marriage."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            UPDATE Marriage SET
                spouse1_id = ?,
                spouse2_id = ?,
                marriage_year = ?,
                marriage_month = ?,
                marriage_day = ?,
                dissolution_year = ?,
                dissolution_month = ?,
                dissolution_day = ?,
                dissolution_reason = ?,
                marriage_type = ?,
                notes = ?
            WHERE id = ?
        """, (
            marriage.spouse1_id, marriage.spouse2_id,
            marriage.marriage_year, marriage.marriage_month, marriage.marriage_day,
            marriage.dissolution_year, marriage.dissolution_month, marriage.dissolution_day,
            marriage.dissolution_reason, marriage.marriage_type, marriage.notes,
            marriage.id
        ))
        
        self.db.conn.commit()
    
    def delete(self, marriage_id: int) -> None:
        """Delete a marriage by ID."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Marriage WHERE id = ?", (marriage_id,))
        self.db.conn.commit()
    
    def end_marriage(self, marriage_id: int, dissolution_year: int, 
                     dissolution_month: int | None = None, 
                     dissolution_day: int | None = None, 
                     reason: str = "") -> None:
        """End a marriage by setting dissolution date and reason."""
        if not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            UPDATE Marriage SET
                dissolution_year = ?,
                dissolution_month = ?,
                dissolution_day = ?,
                dissolution_reason = ?
            WHERE id = ?
        """, (dissolution_year, dissolution_month, dissolution_day, reason, marriage_id))
        
        self.db.conn.commit()
    
    def _row_to_marriage(self, row: tuple) -> Marriage:
        """Convert database row to Marriage object."""
        return Marriage(
            id=row[0],
            spouse1_id=row[1],
            spouse2_id=row[2],
            marriage_year=row[3],
            marriage_month=row[4],
            marriage_day=row[5],
            dissolution_year=row[6],
            dissolution_month=row[7],
            dissolution_day=row[8],
            dissolution_reason=row[9] or "",
            marriage_type=row[10] or "spouse",
            notes=row[11] or ""
        )

>> âœ… database\person_repository.py (104 code lines)
"""Database repository for Person entity operations."""

from __future__ import annotations
import sqlite3
from typing import TYPE_CHECKING

from models.person import Person

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class PersonRepository:
    """Handles all database operations for Person objects."""
    
    def __init__(self, db_manager: DatabaseManager) -> None:
        """Initialize repository with database manager."""
        self.db = db_manager
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _row_to_person(self, row: sqlite3.Row) -> Person:
        """Convert database row to Person object using named column access."""
        return Person(
            id=row['id'],
            first_name=row['first_name'],
            middle_name=row['middle_name'],
            last_name=row['last_name'],
            maiden_name=row['maiden_name'],
            nickname=row['nickname'],
            gender=row['gender'],
            birth_year=row['birth_year'],
            birth_month=row['birth_month'],
            birth_day=row['birth_day'],
            death_year=row['death_year'],
            death_month=row['death_month'],
            death_day=row['death_day'],
            arrival_year=row['arrival_year'],
            arrival_month=row['arrival_month'],
            arrival_day=row['arrival_day'],
            moved_out_year=row['moved_out_year'],
            moved_out_month=row['moved_out_month'],
            moved_out_day=row['moved_out_day'],
            father_id=row['father_id'],
            mother_id=row['mother_id'],
            family_id=row['family_id'],
            dynasty_id=row['dynasty_id'] or 1,
            is_founder=bool(row['is_founder']),
            education=row['education'] or 0,
            notes=row['notes'] or ""
        )
    
    def _cursor(self):
        if self.db.conn is None:
            raise RuntimeError("DB connection not established.")
        return self.db.conn.cursor()
    
    # ------------------------------------------------------------------
    # Create Operations
    # ------------------------------------------------------------------
    
    def insert(self, person: Person) -> int:
        """Insert new person into database and return assigned ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            INSERT INTO Person (
                first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        person_id = cursor.lastrowid
        
        self.db.mark_dirty()
        return person_id if person_id is not None else -1
       
    def insert_with_id(self, person: Person) -> None:
        """Insert person with specific ID (for redo operations)"""
        if self.db.conn is None:
            raise RuntimeError("Database connection not establish.")
        
        if person.id is None:
            raise ValueError("Person must have an ID for insert_with_id")
        
        cursor = self.db.conn.cursor()

        sql = """
            INSERT INTO Person (
                id, first_name, middle_name, last_name, maiden_name, nickname,
                gender, birth_year, birth_month, birth_day,
                death_year, death_month, death_day,
                arrival_year, arrival_month, arrival_day,
                moved_out_year, moved_out_month, moved_out_day,
                father_id, mother_id, family_id,
                dynasty_id, is_founder, education, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            person.id,  # Explicitly set the ID
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
        

    # ------------------------------------------------------------------
    # Read Operations
    # ------------------------------------------------------------------
    
    def get_by_id(self, person_id: int) -> Person | None:
        """Retrieve person by ID, return None if not found."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person WHERE id = ?", (person_id,))
        row = cursor.fetchone()
        
        if row is None:
            return None
        
        return self._row_to_person(row)
    
    def get_all(self) -> list[Person]:
        """Retrieve all people from database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person ORDER BY last_name, first_name")
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_by_name(self, first_name: str, last_name: str) -> list[Person]:
        """Find people by first and last name."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE first_name = ? AND last_name = ?
            ORDER BY birth_year
        """
        cursor.execute(sql, (first_name, last_name))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_children(self, parent_id: int) -> list[Person]:
        """Retrieve all children of a given parent."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person 
            WHERE father_id = ? OR mother_id = ?
            ORDER BY birth_year, birth_month, birth_day
        """
        cursor.execute(sql, (parent_id, parent_id))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    def get_alive_in_year(self, year: int) -> list[Person]:
        """Retrieve all people alive in a given year."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")

        cursor = self.db.conn.cursor()
        sql = """
            SELECT * FROM Person
            WHERE birth_year <= ? 
            AND (death_year IS NULL OR death_year >= ?)
            ORDER BY birth_year
        """
        cursor.execute(sql, (year, year))
        rows = cursor.fetchall()
        
        return [self._row_to_person(row) for row in rows]
    
    # ------------------------------------------------------------------
    # Update Operations
    # ------------------------------------------------------------------
    
    def update(self, person: Person) -> None:
        """Update existing person in database."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        if person.id is None:
            raise ValueError("Cannot update person without ID.")
        
        cursor = self.db.conn.cursor()
        
        sql = """
            UPDATE Person SET
                first_name = ?, middle_name = ?, last_name = ?,
                maiden_name = ?, nickname = ?,
                gender = ?, birth_year = ?, birth_month = ?, birth_day = ?,
                death_year = ?, death_month = ?, death_day = ?,
                arrival_year = ?, arrival_month = ?, arrival_day = ?,
                moved_out_year = ?, moved_out_month = ?, moved_out_day = ?,
                father_id = ?, mother_id = ?, family_id = ?,
                dynasty_id = ?, is_founder = ?, education = ?, notes = ?
            WHERE id = ?
        """
        
        values = (
            person.first_name, person.middle_name, person.last_name,
            person.maiden_name, person.nickname,
            person.gender, person.birth_year, person.birth_month, person.birth_day,
            person.death_year, person.death_month, person.death_day,
            person.arrival_year, person.arrival_month, person.arrival_day,
            person.moved_out_year, person.moved_out_month, person.moved_out_day,
            person.father_id, person.mother_id, person.family_id,
            person.dynasty_id, 1 if person.is_founder else 0, person.education,
            person.notes,
            person.id
        )
        
        cursor.execute(sql, values)
        self.db.mark_dirty()
    
    # ------------------------------------------------------------------
    # Delete Operations
    # ------------------------------------------------------------------
    
    def delete(self, person_id: int) -> None:
        """Delete person from database by ID."""
        if self.db.conn is None:
            raise RuntimeError("Database connection not established.")
        
        cursor = self.db.conn.cursor()
        cursor.execute("DELETE FROM Person WHERE id = ?", (person_id,))
        self.db.mark_dirty()



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MODELS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ models\__init__.py (0 code lines)


>> âœ… models\event.py (32 code lines)
"""Data model for Event entities."""

from dataclasses import dataclass


@dataclass
class Event:
    """Represents a life event for a person."""
    
    # Database identity
    id: int | None = None
    
    # Associated person
    person_id: int | None = None
    
    # Event details
    event_type: str = ""  # "Birth", "Marriage", "Death", "Job", "Move", etc.
    event_title: str = ""  # "Became Blacksmith", "Moved to Town", etc.
    
    # Start date (flexible precision)
    start_year: int | None = None
    start_month: int | None = None
    start_day: int | None = None
    
    # End date (for ongoing events like jobs)
    end_year: int | None = None
    end_month: int | None = None
    end_day: int | None = None
    
    # Notes
    notes: str = ""
    
    @property
    def is_ongoing(self) -> bool:
        """Check if the event is currently ongoing (no end date)."""
        return self.end_year is None
    
    @property
    def start_date_string(self) -> str:
        """Format start date as readable string."""
        if not self.start_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.start_month and self.start_day:
            # Full date
            return f"{month_names[self.start_month]} {self.start_day}, {self.start_year}"
        elif self.start_month:
            # Year and month
            return f"{month_names[self.start_month]} {self.start_year}"
        else:
            # Year only
            return str(self.start_year)
    
    @property
    def end_date_string(self) -> str:
        """Format end date as readable string."""
        if not self.end_year:
            return "Ongoing" if self.start_year else ""
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.end_month and self.end_day:
            # Full date
            return f"{month_names[self.end_month]} {self.end_day}, {self.end_year}"
        elif self.end_month:
            # Year and month
            return f"{month_names[self.end_month]} {self.end_year}"
        else:
            # Year only
            return str(self.end_year)
    
    @property
    def duration_years(self) -> int | None:
        """Calculate event duration in years (None if ongoing or no dates)."""
        if not self.start_year:
            return None
        
        if self.end_year:
            return self.end_year - self.start_year
        
        return None  # Ongoing, no duration yet
    
    @property
    def date_range_string(self) -> str:
        """Get formatted date range for display."""
        if self.is_ongoing:
            return f"{self.start_date_string} - Present"
        elif self.end_year:
            return f"{self.start_date_string} - {self.end_date_string}"
        else:
            return self.start_date_string

>> ðŸ“‹ models\family.py (12 code lines)
"""Data model for Family dynasties."""

from dataclasses import dataclass


@dataclass
class Family:
    """Represents a family dynasty grouping."""
    
    # Database identity
    id: int | None = None
    
    # Family identification
    surname: str = ""
    
    # Move-in date (when family arrived in settlement)
    move_in_year: int | None = None
    move_in_month: int | None = None
    move_in_day: int | None = None
    
    # Visual representation
    coat_of_arms_path: str = ""  # Path to coat of arms image
    family_color: str = ""  # Hex color for UI display
    
    # Status
    is_extinct: bool = False  # True if no living members
    
    # Notes
    notes: str = ""
    
    @property
    def move_in_date_string(self) -> str:
        """Format move-in date as readable string."""
        if not self.move_in_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.move_in_month and self.move_in_day:
            # Full date
            return f"{month_names[self.move_in_month]} {self.move_in_day}, {self.move_in_year}"
        elif self.move_in_month:
            # Year and month
            return f"{month_names[self.move_in_month]} {self.move_in_year}"
        else:
            # Year only
            return str(self.move_in_year)
    
    @property
    def display_name(self) -> str:
        """Get family display name."""
        return f"{self.surname} Family" if self.surname else "Unknown Family"
    
    # Note: member_count, founding_date, end_date, longest_lived_member
    # require database queries, so they'll be methods in FamilyRepository

>> ðŸ“‹ models\major_event.py (15 code lines)
"""Data model for MajorEvent entities."""


class MajorEvent:
    """Represents a major historical event affecting multiple families."""

    def __init__(
        self,
        event_id: int,
        event_name: str,
        event_type: str,
        start_year: int,
        start_month: int | None = None,
        start_day: int | None = None,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
        description: str | None = None,
        color: str | None = None,
    ) -> None:
        """Initialize a major historical event."""
        self.id = event_id
        self.event_name = event_name
        self.event_type = event_type
        self.start_year = start_year
        self.start_month = start_month
        self.start_day = start_day
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.description = description
        self.color = color

    @property
    def is_ongoing(self) -> bool:
        """Check if the event is ongoing."""
        return self.end_year is None

    # TODO: Add duration property
    # TODO: Add start_date_string property
    # TODO: Add end_date_string property


>> âœ… models\marriage.py (62 code lines)
"""Data model for Marriage relationships."""

from dataclasses import dataclass


@dataclass
class Marriage:
    """Represents a marriage relationship between two people."""
    
    # Database identity
    id: int | None = None
    
    # Spouses (person IDs)
    spouse1_id: int | None = None
    spouse2_id: int | None = None
    
    # Marriage date (flexible precision)
    marriage_year: int | None = None
    marriage_month: int | None = None
    marriage_day: int | None = None
    
    # Dissolution/End date (flexible precision)
    dissolution_year: int | None = None
    dissolution_month: int | None = None
    dissolution_day: int | None = None
    
    # Dissolution details
    dissolution_reason: str = ""  # "Death", "Divorce", "Annulment", etc.
    
    # Marriage type (for different cultures/eras)
    marriage_type: str = "spouse"  # "spouse", "partner", "common-law", etc.
    
    # Notes
    notes: str = ""
    
    @property
    def is_active(self) -> bool:
        """Check if the marriage is currently active (not dissolved)."""
        return self.dissolution_year is None
    
    @property
    def marriage_date_string(self) -> str:
        """Format marriage date as readable string."""
        if not self.marriage_year:
            return "Unknown"
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.marriage_month and self.marriage_day:
            # Full date: "January 15, 1675"
            return f"{month_names[self.marriage_month]} {self.marriage_day}, {self.marriage_year}"
        elif self.marriage_month:
            # Year and month: "January 1675"
            return f"{month_names[self.marriage_month]} {self.marriage_year}"
        else:
            # Year only
            return str(self.marriage_year)
    
    @property
    def dissolution_date_string(self) -> str:
        """Format dissolution date as readable string."""
        if not self.dissolution_year:
            return ""
        
        month_names = ["", "January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        
        if self.dissolution_month and self.dissolution_day:
            # Full date
            return f"{month_names[self.dissolution_month]} {self.dissolution_day}, {self.dissolution_year}"
        elif self.dissolution_month:
            # Year and month
            return f"{month_names[self.dissolution_month]} {self.dissolution_year}"
        else:
            # Year only
            return str(self.dissolution_year)
    
    @property
    def duration_string(self) -> str:
        """Calculate marriage duration as readable string with years, months, days."""
        if not self.marriage_year:
            return "Unknown duration"
        
        # If still active (no dissolution date), can't calculate
        if self.is_active or not self.dissolution_year:
            return "Ongoing"
        
        # Calculate duration
        start_year = self.marriage_year
        start_month = self.marriage_month or 1  # Default to January if unknown
        start_day = self.marriage_day or 1  # Default to 1st if unknown
        
        end_year = self.dissolution_year  # Now guaranteed to be int, not None
        end_month = self.dissolution_month or 1
        end_day = self.dissolution_day or 1
        
        # Calculate differences
        years = end_year - start_year
        months = end_month - start_month
        days = end_day - start_day
        
        # Adjust for negative days
        if days < 0:
            months -= 1
            # Days in previous month (approximate as 30)
            days += 30
        
        # Adjust for negative months
        if months < 0:
            years -= 1
            months += 12
        
        # Build string
        parts = []
        if years > 0:
            parts.append(f"{years} year{'s' if years != 1 else ''}")
        if months > 0:
            parts.append(f"{months} month{'s' if months != 1 else ''}")
        if days > 0 and self.marriage_day and self.dissolution_day:
            # Only show days if both dates have day precision
            parts.append(f"{days} day{'s' if days != 1 else ''}")
        
        if not parts:
            return "Less than 1 month"
        
        return ", ".join(parts)

    @property
    def duration_years(self) -> int | None:
        """Calculate marriage duration in years only (for sorting/filtering)."""
        if not self.marriage_year or self.is_active or not self.dissolution_year:
            return None
        
        return self.dissolution_year - self.marriage_year
    
    @property
    def status_string(self) -> str:
        """Get marriage status as readable string."""
        if self.is_active:
            return "Active"
        
        if self.dissolution_reason:
            return f"Ended ({self.dissolution_reason})"
        
        return "Ended"

>> âœ… models\person.py (50 code lines)
"""Data model for Person entities."""

from __future__ import annotations
from dataclasses import dataclass


@dataclass
class Person:
    """Represents a person in a dynasty with flexible date precision."""
    
    # Database identity
    id: int | None = None  # None until saved to database
    dynasty_id: int = 1
    family_id: int | None = None
    
    # Name fields (full structure for flexibility)
    first_name: str = ""
    middle_name: str = ""
    last_name: str = ""
    maiden_name: str = ""
    nickname: str = ""
    
    # Biological information
    gender: str = "Unknown"  # "Male", "Female", "Unknown", "Other"
    
    # Birth date (year should be provided, month/day optional)
    birth_year: int | None = None
    birth_month: int | None = None
    birth_day: int | None = None
    
    # Death date (all optional - None if alive)
    death_year: int | None = None
    death_month: int | None = None
    death_day: int | None = None
    
    # Arrival/departure dates (tracking when joined/left settlement)
    arrival_year: int | None = None
    arrival_month: int | None = None
    arrival_day: int | None = None
    moved_out_year: int | None = None
    moved_out_month: int | None = None
    moved_out_day: int | None = None
    
    # Relationships (parent IDs link to database)
    father_id: int | None = None
    mother_id: int | None = None
    
    # Game-specific fields
    is_founder: bool = False
    education: int = 0  # 0-5 scale from Ostriv
    
    # User notes
    notes: str = ""
    
    # ------------------------------------------------------------------
    # Computed Properties
    # ------------------------------------------------------------------
    
    @property
    def full_name(self) -> str:
        """Get full name with optional middle name and nickname."""
        parts = [self.first_name]
        
        if self.middle_name:
            parts.append(self.middle_name)
        
        parts.append(self.last_name)

        name = " ".join(parts)
        
        if self.nickname:
            name += f' "{self.nickname}"'

        return name
    
    @property
    def display_name(self) -> str:
        """Get display name (first + last, no middle or nickname)."""
        return f"{self.first_name} {self.last_name}"
    
    @property
    def is_deceased(self) -> bool:
        """Check if person is deceased."""
        return self.death_year is not None
    
    def get_age(self, current_year: int) -> int | None:
        """
        Calculate age at a given year.
        
        Returns None if birth year unknown or if person died before current year.
        """
        if self.birth_year is None:
            return None
        
        # If person died, use death year as upper bound
        if self.death_year is not None and current_year > self.death_year:
            return None
        
        return current_year - self.birth_year
    
    def is_alive_in_year(self, year: int) -> bool:
        """Check if person was alive in a given year."""
        # Must have been born by that year
        if self.birth_year is None or year < self.birth_year:
            return False
        
        # If no death year, assume still alive
        if self.death_year is None:
            return True
        
        # Check if year is before death
        return year <= self.death_year
    
    def get_age_at_death(self) -> int | None:
        """Calculate age at death, or None if not deceased or birth year unknown."""
        if not self.is_deceased or self.birth_year is None or self.death_year is None:
            return None
        
        return self.death_year - self.birth_year
    
    def get_birth_date_string(self) -> str:
        """Format birth date as string with available precision (European format)."""
        if self.birth_year is None:
            return "Unknown"
        
        if self.birth_day and self.birth_month:
            return f"{self.birth_day:02d}/{self.birth_month:02d}/{self.birth_year}"
        
        if self.birth_month:
            return f"{self.birth_month:02d}/{self.birth_year}"
        
        return str(self.birth_year)
    
    def get_death_date_string(self) -> str:
        """Format death date as string with available precision (European format)."""
        if self.death_year is None:
            return "Alive"
        
        if self.death_day and self.death_month:
            return f"{self.death_day:02d}/{self.death_month:02d}/{self.death_year}"
        
        if self.death_month:
            return f"{self.death_month:02d}/{self.death_year}"
        
        return str(self.death_year)
    
    def get_lifespan_string(self) -> str:
        """Get lifespan as formatted string (e.g., '1420-1475' or '1450-')."""
        birth = str(self.birth_year) if self.birth_year else "?"
        death = str(self.death_year) if self.death_year else ""
        return f"{birth}-{death}"

>> ðŸ“‹ models\portrait.py (14 code lines)
"""Data model for Portrait entities."""


class Portrait:
    """Represents a portrait image for a person."""

    def __init__(
        self,
        portrait_id: int,
        person_id: int,
        image_path: str,
        valid_from_year: int | None = None,
        valid_from_month: int | None = None,
        valid_from_day: int | None = None,
        valid_to_year: int | None = None,
        valid_to_month: int | None = None,
        valid_to_day: int | None = None,
        is_primary: bool = False,
        display_order: int = 0,
    ) -> None:
        """Initialize a portrait."""
        self.id = portrait_id
        self.person_id = person_id
        self.image_path = image_path
        self.valid_from_year = valid_from_year
        self.valid_from_month = valid_from_month
        self.valid_from_day = valid_from_day
        self.valid_to_year = valid_to_year
        self.valid_to_month = valid_to_month
        self.valid_to_day = valid_to_day
        self.is_primary = is_primary
        self.display_order = display_order

    # TODO: Add valid_from_date_string property
    # TODO: Add valid_to_date_string property
    # TODO: Add is_valid_for_date method



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ actions\__init__.py (7 code lines)
from .file_actions import FileActions
from .edit_actions import EditActions
from .view_actions import ViewActions
from .tools_actions import ToolsActions
from .help_actions import HelpActions
from .settings_actions import SettingsActions

__all__ = ['FileActions', 'EditActions', 'ViewActions', 'ToolsActions', 'HelpActions', 'SettingsActions']

>> âœ… actions\edit_actions.py (25 code lines)
from PySide6.QtWidgets import QDialog
from PySide6.QtGui import QAction

from dialogs.add_person_dialog import AddPersonDialog
from commands.genealogy_commands import AddPersonCommand
        

class EditActions:
    """Handles edit menu actions (Undo, Redo, Add/Remove operations)."""
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize edit actions handler."""
        self.parent = parent
        
        # Store references to the menu actions so we can update their text
        # These will be set by MainWindow after it creates the menu
        self.undo_action: QAction | None = None
        self.redo_action: QAction | None = None
    
    def update_undo_redo_actions(self) -> None:
        """Update Undo/Redo menu items with current action descriptions."""
        if self.undo_action is None or self.redo_action is None:
            return 
        
        undo_manager = self.parent.undo_manager
        
        # Update Undo action
        if undo_manager.can_undo():
            next_undo = undo_manager.peek_undo()
            if next_undo:
                self.undo_action.setText(f"Undo {next_undo.description()}")
                self.undo_action.setEnabled(True)
        else:
            self.undo_action.setText("Undo")
            self.undo_action.setEnabled(False)
        
        # Update Redo action
        if undo_manager.can_redo():
            next_redo = undo_manager.peek_redo()
            if next_redo:
                self.redo_action.setText(f"Redo {next_redo.description()}")
                self.redo_action.setEnabled(True)
        else:
            self.redo_action.setText("Redo")
            self.redo_action.setEnabled(False)
    
    def undo(self) -> None:
        """Undo the last action."""
        if self.parent.undo_manager.undo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after undo
    
    def redo(self) -> None:
        """Redo the last undone action."""
        if self.parent.undo_manager.redo():
            self.parent.db.mark_dirty()
            self.parent.refresh_ui()
            self.update_undo_redo_actions()  # Update menu after redo
    
    def add_person(self) -> None:
        """Open dialog to add a new person to the database."""

        dialog = AddPersonDialog(self.parent)
        result = dialog.exec()
        
        if result == 1:  # QDialog.accepted
            person = dialog.get_person()
            if person:
                command = AddPersonCommand(self.parent.db, person)
                self.parent.undo_manager.execute(command)
                self.parent.refresh_ui()
                self.update_undo_redo_actions()  # Update menu after adding person
    
    def remove_person(self) -> None:
        """Remove the selected person from the database."""
        pass  # TODO: Implement with confirmation dialog
    
    def add_new_family(self) -> None:
        """Create a new family branch in the dynasty."""
        pass  # TODO: Implement family creation

>> âœ… actions\file_actions.py (75 code lines)
from PySide6.QtWidgets import QFileDialog, QMessageBox


class FileActions:
    """Handles file menu actions (New, Open, Save, Exit)."""
    
    FILE_FILTER = "Dynasty Files (*.dyn)"
    
    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize file actions handler."""
        self.parent = parent
    
    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------
    
    def _ensure_db(self) -> bool:
        """Check if a database is currently open."""
        if not hasattr(self.parent, 'db') or not self.parent.db.is_open:
            self._show_error("Error", "No database is currently open.")
            return False
        return True
    
    def _get_save_path(self, title: str, default_name: str = "") -> str | None:
        """Show a save file dialog and return the chosen path."""
        default_path = ""
        if default_name:
            default_path = default_name
        elif self.parent.db.database_directory:
            default_path = self.parent.db.database_directory
        
        path, _ = QFileDialog.getSaveFileName(
            self.parent,
            title,
            default_path,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _get_open_path(self, title: str) -> str | None:
        """Show an open file dialog and return the chosen path."""
        default_dir = ""
        if self.parent.db.is_open and self.parent.db.database_directory:
            default_dir = self.parent.db.database_directory
        
        path, _ = QFileDialog.getOpenFileName(
            self.parent,
            title,
            default_dir,
            self.FILE_FILTER
        )
        return path if path else None
    
    def _show_error(self, title: str, message: str) -> None:
        """Display an error message dialog."""
        QMessageBox.critical(self.parent, title, message)

    def _refresh_all_views(self) -> None:
        """Refresh all active views with new database data."""
        if self.parent.data_table_view:
            self.parent.data_table_view.refresh_data()    
    
    # ------------------------------------------------------------------
    # File Operations
    # ------------------------------------------------------------------
    
    def new_dynasty(self) -> None:
        """Create a new untitled dynasty database."""
        if self.parent.db.is_dirty:
            reply = QMessageBox.question(
                self.parent,
                "Unsaved Changes",
                "You have unsaved changes. Do you want to save before creating a new dynasty?",
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            
            if reply == QMessageBox.StandardButton.Save:
                if not self.save():
                    return
            elif reply == QMessageBox.StandardButton.Cancel:
                return

        self.parent.db.close()

        self.parent._create_untitled_database()

        self.parent.refresh_ui()
        self._refresh_all_views()
        
        self.parent._show_family_trees()
    
    def open_dynasty(self) -> None:
        """Prompt user to open an existing dynasty database file."""
        path = self._get_open_path("Open Dynasty File")
        if not path:
            return
        
        try:
            self.parent.db.open_database(path)
            self.parent.refresh_ui()
            self._refresh_all_views()
            self.parent.settings_manager.add_recent_file(path)
            self.parent._update_recent_files_menu()
        except FileNotFoundError:
            self._show_error(
                "File Not Found",
                f"The file '{path}' does not exist."
            )
        except Exception as e:
            self._show_error(
                "Error Opening Database",
                f"Failed to open dynasty file:\n{str(e)}"
            )
        
    def save(self) -> bool:
        """Save current database, falling back to save_as if no path set."""
        if not self._ensure_db():
            return False
        
        if not self.parent.db.has_file_path:
            return self.save_as()
        
        try:
            result = self.parent.db.save_database()
            if result:
                self.parent.refresh_ui()
                # Add to recent files after successful save
                if self.parent.db.file_path:
                    self.parent.settings_manager.add_recent_file(self.parent.db.file_path)
                    self.parent._update_recent_files_menu()
            return result
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False

    def save_as(self) -> bool:
        """Prompt user to save database to a new file."""
        if not self._ensure_db():
            return False
        
        default_name = self.parent.db.database_name or ""
        path = self._get_save_path("Save Dynasty File As", default_name)
        if not path:
            return False
        
        try:
            self.parent.db.save_database(path)
            self.parent.refresh_ui()
            self.parent.settings_manager.add_recent_file(path)
            self.parent._update_recent_files_menu()
            return True
        except Exception as e:
            self._show_error(
                "Error Saving Database",
                f"Failed to save dynasty file:\n{str(e)}"
            )
            return False
    
    def exit_app(self) -> None:
        """Prompt to save unsaved changes before closing application."""
        db = self.parent.db
        
        if db.is_open and db.is_dirty:
            msg = QMessageBox(self.parent)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Do you want to save before exiting?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            choice = msg.exec()
            
            if choice == QMessageBox.StandardButton.Save:
                if not self.save():
                    return
            elif choice == QMessageBox.StandardButton.Cancel:
                return
        
        self.parent.close()


>> ðŸ“‹ actions\help_actions.py (3 code lines)
class HelpActions:
    """Handles help menu actions for application information."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize help actions handler."""
        self.parent = parent

    def about(self) -> None:
        """Display the about dialog with application information."""
        pass  # TODO: Implement about dialog


>> ðŸ“‹ actions\settings_actions.py (8 code lines)
class SettingsActions:
    """Handles settings menu actions for various configuration options."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize settings actions handler."""
        self.parent = parent

    def settings(self) -> None:
        """Open settings dialog to modify application settings."""
        pass  # TODO: Implement settings dialog interaction

    def general(self) -> None:
        """Open general settings tab."""
        pass  # TODO: Implement general settings tab

    def shortcuts(self) -> None:
        """Open shortcuts settings tab."""
        pass  # TODO: Implement shortcuts settings tab

    def display(self) -> None:
        """Open display settings tab."""
        pass  # TODO: Implement display settings tab

    def appearance(self) -> None:
        """Open appearance settings tab."""
        pass  # TODO: Implement appearance settings tab

    def formats(self) -> None:
        """Open formats settings tab."""
        pass  # TODO: Implement formats settings tab

>> ðŸ“‹ actions\tools_actions.py (6 code lines)
class ToolsActions:
    """Handles tools menu actions for validation and scene utilities."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize tools actions handler."""
        self.parent = parent

    def rebuild_scene(self) -> None:
        """Rebuild the current visualization scene from scratch."""
        pass  # TODO: Implement scene rebuild

    def recompute_generations(self) -> None:
        """Recalculate generation levels for all persons."""
        pass  # TODO: Implement generation computation

    def validate_marriages(self) -> None:
        """Check for inconsistencies in marriage records."""
        pass  # TODO: Implement marriage validation

    def validate_parentage(self) -> None:
        """Check for inconsistencies in parent-child relationships."""
        pass  # TODO: Implement parentage validation


>> ðŸ“‹ actions\view_actions.py (6 code lines)
class ViewActions:
    """Handles view menu actions for switching between visualizations."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize view actions handler."""
        self.parent = parent

    def family_trees(self) -> None:
        """Switch to family trees visualization view."""
        pass  # TODO: Implement family trees view

    def timeline(self) -> None:
        """Switch to timeline visualization view."""
        pass  # TODO: Implement timeline view

    def dynasty(self) -> None:
        """Switch to dynasty visualization view."""
        pass  # TODO: Implement dynasty view

    def data_table(self) -> None:
        """Switch to data table view."""
        pass  # TODO: Implement data table view



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\base_command.py (9 code lines)
import re

class BaseCommand:
    """Base class for all undoable commands."""
    
    def __init__(self):
        self._executed = False  
    
    def description(self) -> str:
        """Return human-readable description for UI display."""
        class_name = self.__class__.__name__
        if class_name.endswith("Command"):
            class_name = class_name[:-7]

        spaced = re.sub(r'([a-z])([A-Z])', r'\1 \2', class_name)
        
        return spaced
    
    def run(self) -> None:
        """Execute the command."""
        raise NotImplementedError("Subclasses must implement run()")
    
    def undo(self) -> None:
        """Reverse the command's effects."""
        raise NotImplementedError("Subclasses must implement undo()")


>> âœ… commands\genealogy_commands\__init__.py (26 code lines)
from .add_event import AddEventCommand
from .add_marriage import CreateMarriageCommand
from .add_person import AddPersonCommand
from .assign_parent import AssignParentCommand
from .create_child import CreateChildCommand
from .delete_event import DeleteEventCommand
from .edit_event import EditEventCommand
from .edit_marriage import EditMarriageCommand
from .edit_person import EditPersonCommand
from .end_marriage import EndMarriageCommand
from .delete_person import DeletePersonCommand
from .unassign_parent import UnassignParentCommand

__all__ = [
    "AddEventCommand",
    "CreateMarriageCommand",
    "AddPersonCommand",
    "AssignParentCommand",
    "CreateChildCommand",
    "DeleteEventCommand",
    "EditEventCommand",
    "EditMarriageCommand",
    "EditPersonCommand",
    "EndMarriageCommand",
    "DeletePersonCommand",
    "UnassignParentCommand"
]

>> ðŸ“‹ commands\genealogy_commands\add_event.py (3 code lines)
"""Command for adding an event to a person."""

from commands.base_command import BaseCommand


class AddEventCommand(BaseCommand):
    """Add a life event to a person."""

    def __init__(self, event_data: dict) -> None:
        """Initialize the add event command."""
        self.event_data = event_data
        self.event_id: int | None = None

    def run(self) -> None:
        """Insert the event into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated event_id for undo
        pass

    def undo(self) -> None:
        """Remove the event from the database."""
        # TODO: Implement database DELETE using stored event_id
        pass


>> ðŸ“‹ commands\genealogy_commands\add_marriage.py (3 code lines)
"""Command for creating a marriage between two people."""

from commands.base_command import BaseCommand


class CreateMarriageCommand(BaseCommand):
    """Create a marriage relationship between two people."""

    def __init__(self, marriage_data: dict) -> None:
        """Initialize the create marriage command."""
        self.marriage_data = marriage_data
        self.marriage_id: int | None = None

    def run(self) -> None:
        """Insert the marriage into the database."""
        # TODO: Implement database INSERT
        # TODO: Store generated marriage_id for undo
        # TODO: Handle surname changes if configured
        pass

    def undo(self) -> None:
        """Remove the marriage from the database."""
        # TODO: Implement database DELETE
        # TODO: Revert surname changes if applicable
        pass


>> ðŸ“‹ commands\genealogy_commands\add_person.py (8 code lines)
"""Command for adding a new person to the database."""

from __future__ import annotations
from typing import TYPE_CHECKING

from models.person import Person
from commands.base_command import BaseCommand
from database.person_repository import PersonRepository

if TYPE_CHECKING:
    from database.db_manager import DatabaseManager


class AddPersonCommand(BaseCommand):
    """Add a new person to the dynasty database with undo support."""

    def __init__(self, db_manager: DatabaseManager, person: Person) -> None:
        """Initialize the add person command."""
        self.person = person
        self.person_id: int | None = None
        self.repo = PersonRepository(db_manager)

    def run(self) -> None:
        """Insert the person into the database and store the assigned ID."""
        if self.person_id is None:
            self.person_id = self.repo.insert(self.person)
            self.person.id = self.person_id

        else:
            self.person.id = self.person_id
            self.repo.insert_with_id(self.person)

    def undo(self) -> None:
        """Remove the person from the database."""
        if self.person_id is not None:
            self.repo.delete(self.person_id)

>> ðŸ“‹ commands\genealogy_commands\assign_parent.py (9 code lines)
"""Command for assigning a parent to a person."""

from commands.base_command import BaseCommand


class AssignParentCommand(BaseCommand):
    """Set or change a person's father or mother."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the assign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_id = parent_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Assign the parent relationship in database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Update father_id or mother_id based on parent_type
        pass

    def undo(self) -> None:
        """Restore original parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\genealogy_commands\create_child.py (11 code lines)
"""Command for creating a child with automatic parent assignment."""

from commands.base_command import BaseCommand


class CreateChildCommand(BaseCommand):
    """Create a new person as child of specified parents."""

    def __init__(
        self,
        database_connection,
        first_name: str,
        last_name: str,
        father_id: int | None = None,
        mother_id: int | None = None,
        **kwargs,
    ) -> None:
        """Initialize the create child command."""
        self.db = database_connection
        self.first_name = first_name
        self.last_name = last_name
        self.father_id = father_id
        self.mother_id = mother_id
        self.additional_data = kwargs
        self.created_person_id: int | None = None
        # TODO: Store created person ID for undo

    def run(self) -> None:
        """Create new person with parent relationships."""
        # TODO: Insert new person into database
        # TODO: Set father_id and mother_id
        # TODO: Store created_person_id
        pass

    def undo(self) -> None:
        """Delete the created child."""
        # TODO: Delete person record using created_person_id
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_event.py (3 code lines)
"""Command for deleting an event from the database."""

from commands.base_command import BaseCommand


class DeleteEventCommand(BaseCommand):
    """Remove an event from the database."""

    def __init__(self, database_connection, event_id: int) -> None:
        """Initialize the delete event command."""
        self.db = database_connection
        self.event_id = event_id
        self.deleted_data: dict = {}
        # TODO: Store complete event data for undo

    def run(self) -> None:
        """Delete the event from database."""
        # TODO: Fetch and save complete event data to deleted_data
        # TODO: Delete event record from database
        pass

    def undo(self) -> None:
        """Restore the deleted event."""
        # TODO: Re-insert event record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_marriage.py (3 code lines)
"""Command for deleting a marriage from the database."""

from commands.base_command import BaseCommand


class DeleteMarriageCommand(BaseCommand):
    """Remove a marriage relationship from the database."""

    def __init__(self, database_connection, marriage_id: int) -> None:
        """Initialize the delete marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.deleted_data: dict = {}
        # TODO: Store complete marriage data for undo

    def run(self) -> None:
        """Delete the marriage from database."""
        # TODO: Fetch and save complete marriage data to deleted_data
        # TODO: Delete marriage record from database
        pass

    def undo(self) -> None:
        """Restore the deleted marriage."""
        # TODO: Re-insert marriage record from deleted_data
        pass


>> ðŸ“‹ commands\genealogy_commands\delete_person.py (3 code lines)
"""Command for removing a person from the database."""

from commands.base_command import BaseCommand


class DeletePersonCommand(BaseCommand):
    """Delete a person from the dynasty database."""

    def __init__(self, person_id: int) -> None:
        """Initialize the delete person command."""
        self.person_id = person_id
        self.person_data: dict | None = None

    def run(self) -> None:
        """Remove the person from the database."""
        # TODO: Fetch and store all person data for undo
        # TODO: Implement database DELETE
        # TODO: Handle cascade effects (orphaned children, etc.)
        pass

    def undo(self) -> None:
        """Restore the deleted person."""
        # TODO: Implement database INSERT with stored person_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_event.py (3 code lines)
"""Command for editing an existing event."""

from commands.base_command import BaseCommand


class EditEventCommand(BaseCommand):
    """Edit details of an existing event."""

    def __init__(self, database_connection, event_id: int, **kwargs) -> None:
        """Initialize the edit event command."""
        self.db = database_connection
        self.event_id = event_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original event data for undo

    def run(self) -> None:
        """Update event details in database."""
        # TODO: Save current state to old_data
        # TODO: Update event record with new_data
        pass

    def undo(self) -> None:
        """Restore original event details."""
        # TODO: Restore event record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_marriage.py (3 code lines)
"""Command for editing an existing marriage."""

from commands.base_command import BaseCommand


class EditMarriageCommand(BaseCommand):
    """Edit details of an existing marriage relationship."""

    def __init__(self, database_connection, marriage_id: int, **kwargs) -> None:
        """Initialize the edit marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.new_data = kwargs
        self.old_data: dict = {}
        # TODO: Store original marriage data for undo

    def run(self) -> None:
        """Update marriage details in database."""
        # TODO: Save current state to old_data
        # TODO: Update marriage record with new_data
        pass

    def undo(self) -> None:
        """Restore original marriage details."""
        # TODO: Restore marriage record from old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\edit_person.py (3 code lines)
"""Command for editing an existing person."""

from commands.base_command import BaseCommand


class EditPersonCommand(BaseCommand):
    """Edit an existing person in the database."""

    def __init__(self, person_id: int, new_data: dict) -> None:
        """Initialize the edit person command."""
        self.person_id = person_id
        self.new_data = new_data
        self.old_data: dict | None = None

    def run(self) -> None:
        """Update the person in the database."""
        # TODO: Fetch and store old data for undo
        # TODO: Implement database UPDATE
        pass

    def undo(self) -> None:
        """Restore the person's original data."""
        # TODO: Implement database UPDATE with old_data
        pass


>> ðŸ“‹ commands\genealogy_commands\end_marriage.py (10 code lines)
"""Command for ending a marriage with divorce or death."""

from commands.base_command import BaseCommand


class EndMarriageCommand(BaseCommand):
    """Mark a marriage as ended with a specific date."""

    def __init__(
        self,
        database_connection,
        marriage_id: int,
        end_year: int | None = None,
        end_month: int | None = None,
        end_day: int | None = None,
    ) -> None:
        """Initialize the end marriage command."""
        self.db = database_connection
        self.marriage_id = marriage_id
        self.end_year = end_year
        self.end_month = end_month
        self.end_day = end_day
        self.old_end_date: tuple[int | None, int | None, int | None] = (None, None, None)
        # TODO: Store original end date for undo

    def run(self) -> None:
        """Set the marriage end date in database."""
        # TODO: Save current end date to old_end_date
        # TODO: Update marriage end_year, end_month, end_day
        pass

    def undo(self) -> None:
        """Restore original marriage end date."""
        # TODO: Restore end date from old_end_date
        pass


>> ðŸ“‹ commands\genealogy_commands\unassign_parent.py (8 code lines)
"""Command for removing a parent assignment from a person."""

from commands.base_command import BaseCommand


class UnassignParentCommand(BaseCommand):
    """Remove a person's father or mother relationship."""

    def __init__(
        self,
        database_connection,
        person_id: int,
        parent_type: str,  # "father" or "mother"
    ) -> None:
        """Initialize the unassign parent command."""
        self.db = database_connection
        self.person_id = person_id
        self.parent_type = parent_type
        self.old_parent_id: int | None = None
        # TODO: Store original parent ID for undo

    def run(self) -> None:
        """Remove the parent relationship from database."""
        # TODO: Save current parent ID to old_parent_id
        # TODO: Set father_id or mother_id to NULL based on parent_type
        pass

    def undo(self) -> None:
        """Restore the parent relationship."""
        # TODO: Restore parent ID from old_parent_id
        pass


>> ðŸ“‹ commands\GUI_commands\__init__.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\change_skin.py (3 code lines)
"""Command for changing the application color scheme."""

from commands.base_command import BaseCommand


class ChangeSkinCommand(BaseCommand):
    """Switch between different UI color schemes."""

    def __init__(self, new_skin: str, old_skin: str) -> None:
        """Initialize the change skin command."""
        self.new_skin = new_skin
        self.old_skin = old_skin
        # TODO: Add reference to skin manager

    def run(self) -> None:
        """Apply the new color scheme."""
        # TODO: Load new skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass

    def undo(self) -> None:
        """Restore previous color scheme."""
        # TODO: Load old skin from SkinManager
        # TODO: Update all UI elements
        # TODO: Save preference to Settings table
        pass


>> ðŸ“‹ commands\GUI_commands\change_view.py (3 code lines)
"""Command for switching between different visualization views."""

from commands.base_command import BaseCommand


class ChangeViewCommand(BaseCommand):
    """Switch between tree, timeline, table, and stats views."""

    def __init__(self, new_view: str, old_view: str) -> None:
        """Initialize the change view command."""
        self.new_view = new_view  # "tree", "timeline", "table", "stats"
        self.old_view = old_view
        # TODO: Add reference to main window

    def run(self) -> None:
        """Switch to the new visualization view."""
        # TODO: Hide current view widget
        # TODO: Show new view widget
        # TODO: Update menu checkmarks
        pass

    def undo(self) -> None:
        """Switch back to the previous view."""
        # TODO: Hide current view widget
        # TODO: Show old view widget
        # TODO: Update menu checkmarks
        pass


>> ðŸ“‹ commands\GUI_commands\move_node.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\move_person.py (10 code lines)
"""Command for moving a person box in the tree view."""

from commands.base_command import BaseCommand


class MovePersonCommand(BaseCommand):
    """Move a person's visual position in the tree canvas."""

    def __init__(
        self,
        person_id: int,
        new_x: float,
        new_y: float,
        old_x: float,
        old_y: float,
    ) -> None:
        """Initialize the move person command."""
        self.person_id = person_id
        self.new_x = new_x
        self.new_y = new_y
        self.old_x = old_x
        self.old_y = old_y
        # TODO: Add reference to canvas/scene for visual updates

    def run(self) -> None:
        """Move person box to new position."""
        # TODO: Update PersonPosition table in database
        # TODO: Update visual position on canvas
        pass

    def undo(self) -> None:
        """Restore person box to original position."""
        # TODO: Update PersonPosition table with old coordinates
        # TODO: Update visual position on canvas
        pass


>> ðŸ“‹ commands\GUI_commands\preference_changes.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\rebuild_scene.py (3 code lines)
"""Command for rebuilding the entire visualization scene."""

from commands.base_command import BaseCommand


class RebuildSceneCommand(BaseCommand):
    """Rebuild the current view from database state."""

    def __init__(self, database_connection, view_type: str) -> None:
        """Initialize the rebuild scene command."""
        self.db = database_connection
        self.view_type = view_type  # "tree", "timeline", "table", "stats"
        # TODO: Store current scene state for undo

    def run(self) -> None:
        """Clear and rebuild the visualization scene."""
        # TODO: Clear current scene/view
        # TODO: Reload all data from database
        # TODO: Recreate all visual elements
        pass

    def undo(self) -> None:
        """Restore previous scene state."""
        # TODO: Restore from saved scene state
        pass


>> ðŸ“‹ commands\GUI_commands\recompute_generation.py (0 code lines)


>> ðŸ“‹ commands\GUI_commands\recompute_generations.py (3 code lines)
"""Command for recalculating generation levels for all people."""

from commands.base_command import BaseCommand


class RecomputeGenerationsCommand(BaseCommand):
    """Recalculate generation numbers for entire family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the recompute generations command."""
        self.db = database_connection
        self.old_generations: dict[int, int] = {}
        # TODO: Store original generation assignments for undo

    def run(self) -> None:
        """Calculate and update generation levels."""
        # TODO: Use GenerationCalculator to compute levels
        # TODO: Update Person table with new generation values
        # TODO: Update tree view layout
        pass

    def undo(self) -> None:
        """Restore original generation assignments."""
        # TODO: Restore generation values from old_generations
        # TODO: Update tree view layout
        pass


>> ðŸ“‹ commands\GUI_commands\timeline_scroll.py (0 code lines)


>> ðŸ“‹ commands\undo_redo_manager.py (19 code lines)
from __future__ import annotations

from commands.base_command import BaseCommand


class UndoRedoManager:
    """Manages undo and redo stacks for command pattern operations."""
    
    def __init__(self) -> None:
        """Initialize the undo/redo manager with empty stacks."""
        self.undo_stack: list[BaseCommand] = []
        self.redo_stack: list[BaseCommand] = []
    
    def execute(self, command: BaseCommand) -> None:  
        """Execute a command and add it to the undo stack."""
        command.run()
        self.undo_stack.append(command)
        self.redo_stack.clear()
    
    def undo(self) -> bool:
        """Undo the last executed command."""
        if not self.undo_stack:
            return False
        cmd = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
        return True
    
    def redo(self) -> bool:
        """Redo the last undone command."""
        if not self.redo_stack:
            return False
        cmd = self.redo_stack.pop()
        cmd.run()
        self.undo_stack.append(cmd)
        return True
    
    def can_undo(self) -> bool:
        """Check if there are commands available to undo."""
        return len(self.undo_stack) > 0
    
    def can_redo(self) -> bool:
        """Check if there are commands available to redo."""
        return len(self.redo_stack) > 0
    
    def peek_undo(self) -> BaseCommand | None:
        """Get the next command that would be undone without executing it."""
        if self.can_undo():
            return self.undo_stack[-1]
        return None
    
    def peek_redo(self) -> BaseCommand | None:
        """Get the next command that would be redone without executing it."""
        if self.can_redo():
            return self.redo_stack[-1]
        return None

>> ðŸ“‹ commands\view_changes.py (0 code lines)



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIALOGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ dialogs\__init__.py (0 code lines)
"""Dialog implementations for user interactions."""

from .add_person_dialog import AddPersonDialog
from .end_marriage_dialog import EndMarriageDialog
from .create_marriage_dialog import CreateMarriageDialog
from .create_child_dialog import CreateChildDialog
from .create_event_dialog import CreateEventDialog
from .edit_event_dialog import EditEventDialog

__all__ = [
    'AddPersonDialog',
    'EndMarriageDialog',
    'CreateMarriageDialog',
    'CreateChildDialog',
    'CreateEventDialog',
    'EditEventDialog'
]

>> ðŸ“‹ dialogs\about_dialog.py (1 code lines)
"""About dialog showing application information."""

from PySide6.QtWidgets import QDialog


class AboutDialog(QDialog):
    """Dialog displaying application information and credits."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the about dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add application name, version, credits
        # TODO: Add license information
        # TODO: Add GitHub link
        pass


>> âœ… dialogs\add_person_dialog.py (71 code lines)
"""Dialog for adding a new person to the database."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLineEdit, QComboBox, QTextEdit,
    QPushButton, QLabel, QDialogButtonBox, QCheckBox, QWidget
)
from PySide6.QtCore import Qt

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from models.person import Person
from widgets.date_picker import DatePicker


class AddPersonDialog(QDialog):
    """Dialog for adding a new person with essential information."""
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        
        self.setWindowTitle("Add New Person")
        self.setMinimumWidth(500)
        
        self._person: Person | None = None
        
        self._setup_ui()
        self._connect_signals()
    
    # ------------------------------------------------------------------
    # UI Setup
    # ------------------------------------------------------------------
    
    def _setup_ui(self) -> None:
        """Create and arrange all dialog widgets."""
        self.main_layout = QVBoxLayout(self)  # Store as instance variable
        
        # Special character toolbar
        self.main_layout.addLayout(self._create_special_char_toolbar())
        
        # Add separator line
        separator = QLabel()
        separator.setFrameShape(QLabel.Shape.HLine)
        separator.setFrameShadow(QLabel.Shadow.Sunken)
        self.main_layout.addWidget(separator)
        
        # Form fields
        self.main_layout.addLayout(self._create_form_layout())
        
        # OK/Cancel buttons
        self.main_layout.addWidget(self._create_button_box())
    
    def _create_special_char_toolbar(self) -> QHBoxLayout:
        """Create toolbar with special character buttons."""
        toolbar = QHBoxLayout()
        
        # Label
        label = QLabel("Special Characters:")
        toolbar.addWidget(label)
        
        # Character buttons
        special_chars = ['Ã¡', 'Ã½', 'Ã³', 'Ã©', 'Ã­']
        
        for char in special_chars:
            btn = QPushButton(char)
            btn.setMaximumWidth(40)
            btn.setToolTip(f"Insert '{char}' at cursor")
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.clicked.connect(lambda checked, c=char: self._insert_special_char(c))
            toolbar.addWidget(btn)
        
        toolbar.addStretch()
        
        return toolbar
    
    def _create_form_layout(self) -> QFormLayout:
        """Create the main form with input fields."""
        form = QFormLayout()
        
        # First Name (required)
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        form.addRow("First Name: *", self.first_name_input)
        
        # Middle Name (optional)
        self.middle_name_input = QLineEdit()
        self.middle_name_input.setPlaceholderText("Optional")
        form.addRow("Middle Name:", self.middle_name_input)
        
        # Last Name (required)
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        form.addRow("Last Name: *", self.last_name_input)
        
        # Gender (optional)
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        form.addRow("Gender:", self.gender_input)
        
        # --- Date Section ---
        
        # Born in Town checkbox
        self.born_in_town_check = QCheckBox("Born in Town")
        self.born_in_town_check.setChecked(False)  # Default: arrived from elsewhere
        form.addRow("", self.born_in_town_check)
        
        # Birth Date picker FIRST (stays visible always)
        self.birth_date_picker = DatePicker()
        form.addRow("Birth Date: *", self.birth_date_picker)
        
        # Arrival Date picker SECOND (disappears when born in town)
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_picker = DatePicker()
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
        
        # Notes (optional)
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this person...")
        self.notes_input.setMaximumHeight(80)
        form.addRow("Notes:", self.notes_input)
        
        return form
    
    def _create_button_box(self) -> QDialogButtonBox:
        """Create OK and Cancel buttons."""
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        
        return button_box
    
    # ------------------------------------------------------------------
    # Signal Handlers
    # ------------------------------------------------------------------
    
    def _connect_signals(self) -> None:
        """Connect widget signals to handlers."""
        # When "Born in Town" changes, show/hide arrival date
        self.born_in_town_check.stateChanged.connect(self._update_date_visibility)
        
        # Set initial visibility
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show or hide arrival date based on 'Born in Town' checkbox."""
        is_born_in_town = self.born_in_town_check.isChecked()
        
        # Hide/show arrival date row
        self.arrival_date_label.setVisible(not is_born_in_town)
        self.arrival_date_picker.setVisible(not is_born_in_town)
        
        # Adjust birth date precision hint
        if is_born_in_town:
            # Born in town: we know the precise month
            self.birth_date_picker.unknown_check.setChecked(False)
        else:
            # Arrived: might only know birth year
            self.birth_date_picker.unknown_check.setChecked(True)
        
        # Force layout to recalculate and resize dialog
        self.main_layout.invalidate()  # Use stored reference
        self.main_layout.activate()
        
        # Resize dialog to fit new content
        self.resize(self.minimumSizeHint())

    def _insert_special_char(self, char: str) -> None:
        """Insert a special character at the cursor position."""
        focused = self.focusWidget()
        
        if isinstance(focused, QLineEdit):
            focused.insert(char)
            focused.setFocus()
    
    def _handle_accept(self) -> None:
        """Validate inputs and create Person object before accepting."""
        if not self._validate_inputs():
            return
        
        birth_year, birth_month = self.birth_date_picker.get_date()
        
        arrival_year = None
        arrival_month = None
        if not self.born_in_town_check.isChecked():
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        
        self._person = Person(
            first_name=self.first_name_input.text().strip(),
            middle_name=self.middle_name_input.text().strip(),
            last_name=self.last_name_input.text().strip(),
            birth_year=birth_year,
            birth_month=birth_month,
            arrival_year=arrival_year,
            arrival_month=arrival_month,
            gender=self.gender_input.currentText(),
            notes=self.notes_input.toPlainText().strip()
        )
        
        # Save to database
        person_id = self.person_repo.insert(self._person)
        self._person.id = person_id
        
        self.accept()
    
    # ------------------------------------------------------------------
    # Validation
    # ------------------------------------------------------------------
    
    def _validate_inputs(self) -> bool:
        """Validate required fields and show error if invalid."""
        # First name required
        if not self.first_name_input.text().strip():
            self._show_error("First name is required.")
            self.first_name_input.setFocus()
            return False
        
        # Last name required
        if not self.last_name_input.text().strip():
            self._show_error("Last name is required.")
            self.last_name_input.setFocus()
            return False
        
        # Birth year required (always has a value from DatePicker)
        birth_year, _ = self.birth_date_picker.get_date()
        if birth_year < 1500 or birth_year > 2000:
            self._show_error("Birth year must be between 1500 and 2000.")
            return False
        
        return True
    
    def _show_error(self, message: str) -> None:
        """Display an error message to the user."""
        from PySide6.QtWidgets import QMessageBox
        
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Validation Error")
        msg.setText(message)
        msg.exec()
    
    # ------------------------------------------------------------------
    # Public Methods
    # ------------------------------------------------------------------
    
    def get_person(self) -> Person | None:
        """Return the created Person object."""
        return self._person

>> âœ… dialogs\create_child_dialog.py (66 code lines)
"""Dialog for creating a new child."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit,
    QComboBox, QLabel, QDialogButtonBox, QWidget, QMessageBox, 
    QCheckBox, QFrame
)
from PySide6.QtCore import QSignalBlocker, Qt

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from models.person import Person
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateChildDialog(QDialog):
    """Dialog for creating a new child with pre-filled parents."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        parent1: Person,
        parent2_id: int | None = None,
        parent_widget: QWidget | None = None
    ) -> None:
        super().__init__(parent_widget)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        self.parent1 = parent1
        self.parent2_id = parent2_id
        
        self.created_person: Person | None = None
        
        self.setWindowTitle("Create Child")
        self.setMinimumWidth(550)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        LABEL_WIDTH = 85  # Consistent label width for alignment
        
        # Parents header
        parents_header = QLabel("<b>Parents:</b>")
        layout.addWidget(parents_header)
        
        # Parent 1 (indented)
        parent1_layout = QHBoxLayout()
        parent1_layout.addSpacing(20)
        parent1_label_text = QLabel("Parent 1:")
        parent1_label_text.setMinimumWidth(LABEL_WIDTH)
        parent1_layout.addWidget(parent1_label_text)
        parent1_name = QLabel(f"<b>{self.parent1.display_name}</b>")
        parent1_layout.addWidget(parent1_name)
        parent1_layout.addStretch()
        layout.addLayout(parent1_layout)
        
        # Parent 2 (indented)
        parent2_layout = QHBoxLayout()
        parent2_layout.addSpacing(20)
        parent2_label_text = QLabel("Parent 2:")
        parent2_label_text.setMinimumWidth(LABEL_WIDTH)
        parent2_layout.addWidget(parent2_label_text)
        self.parent2_selector = PersonSelector(self.db_manager)
        if self.parent2_id:
            with QSignalBlocker(self.parent2_selector):
                self.parent2_selector.set_person(self.parent2_id)
        parent2_layout.addWidget(self.parent2_selector)
        layout.addLayout(parent2_layout)
        
        # Divider line
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        layout.addWidget(line)
        
        # Child Information header
        child_header = QLabel("<b>Child Information:</b>")
        layout.addWidget(child_header)
        
        # First Name (indented)
        first_name_layout = QHBoxLayout()
        first_name_layout.addSpacing(20)
        first_name_label = QLabel("First Name: *")
        first_name_label.setMinimumWidth(LABEL_WIDTH)
        first_name_layout.addWidget(first_name_label)
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        first_name_layout.addWidget(self.first_name_input)
        layout.addLayout(first_name_layout)
        
        # Last Name (indented)
        last_name_layout = QHBoxLayout()
        last_name_layout.addSpacing(20)
        last_name_label = QLabel("Last Name: *")
        last_name_label.setMinimumWidth(LABEL_WIDTH)
        last_name_layout.addWidget(last_name_label)
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        self.last_name_input.setText(self.parent1.last_name)
        last_name_layout.addWidget(self.last_name_input)
        layout.addLayout(last_name_layout)
        
        # Gender (indented)
        gender_layout = QHBoxLayout()
        gender_layout.addSpacing(20)
        gender_label = QLabel("Gender:")
        gender_label.setMinimumWidth(LABEL_WIDTH)
        gender_layout.addWidget(gender_label)
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        self.gender_input.setMinimumWidth(120)
        gender_layout.addWidget(self.gender_input)
        gender_layout.addStretch()
        layout.addLayout(gender_layout)
        
        # Birth Date (indented)
        birth_date_layout = QHBoxLayout()
        birth_date_layout.addSpacing(20)
        birth_date_label = QLabel("Birth Date:")
        birth_date_label.setMinimumWidth(LABEL_WIDTH)
        birth_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        birth_date_layout.addWidget(birth_date_label)
        self.birth_date_picker = DatePicker()
        self.birth_date_picker.set_date(1721, 1)
        birth_date_layout.addWidget(self.birth_date_picker)
        birth_date_layout.addStretch()
        layout.addLayout(birth_date_layout)
        
        # Immigrant checkbox (indented to align with field labels)
        immigrant_layout = QHBoxLayout()
        immigrant_layout.addSpacing(20)
        self.immigrant_check = QCheckBox("Immigrant")
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        immigrant_layout.addWidget(self.immigrant_check)
        immigrant_layout.addStretch()
        layout.addLayout(immigrant_layout)
        
        # Arrival Date (indented)
        arrival_date_layout = QHBoxLayout()
        arrival_date_layout.addSpacing(20)
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_label.setMinimumWidth(LABEL_WIDTH)
        self.arrival_date_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        arrival_date_layout.addWidget(self.arrival_date_label)
        self.arrival_date_picker = DatePicker()
        self.arrival_date_picker.set_date(1721, 1)
        arrival_date_layout.addWidget(self.arrival_date_picker)
        arrival_date_layout.addStretch()
        layout.addLayout(arrival_date_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        self._update_immigrant_state()
    
    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_state()
    
    def _update_immigrant_state(self) -> None:
        """Update visibility based on immigrant status."""
        is_immigrant = self.immigrant_check.isChecked()
        
        self.birth_date_picker.unknown_check.setVisible(False)
        self.birth_date_picker.month_spin.setEnabled(not is_immigrant)
        
        if is_immigrant:
            self.birth_date_picker.unknown_check.setChecked(True)
        else:
            self.birth_date_picker.unknown_check.setChecked(False)
        
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)
        self.arrival_date_picker.unknown_check.setVisible(False)
    
    def _handle_accept(self) -> None:
        """Validate and create child."""
        first_name = self.first_name_input.text().strip()
        last_name = self.last_name_input.text().strip()
        
        if not first_name:
            QMessageBox.warning(self, "Validation Error", "First name is required.")
            return
        
        if not last_name:
            QMessageBox.warning(self, "Validation Error", "Last name is required.")
            return
        
        gender = self.gender_input.currentText()
        
        if self.immigrant_check.isChecked():
            birth_year, _ = self.birth_date_picker.get_date()
            birth_month = None
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        else:
            birth_year, birth_month = self.birth_date_picker.get_date()
            arrival_year, arrival_month = None, None
        
        father_id = None
        mother_id = None
        parent2_id = self.parent2_selector.get_person_id()
        
        if self.parent1.gender == "Male":
            father_id = self.parent1.id
            if parent2_id:
                mother_id = parent2_id
        elif self.parent1.gender == "Female":
            mother_id = self.parent1.id
            if parent2_id:
                father_id = parent2_id
        else:
            father_id = self.parent1.id
            mother_id = parent2_id
        
        new_person = Person(
            first_name=first_name,
            last_name=last_name,
            gender=gender,
            birth_year=birth_year,
            birth_month=birth_month,
            arrival_year=arrival_year,
            arrival_month=arrival_month,
            father_id=father_id,
            mother_id=mother_id,
            dynasty_id=self.parent1.dynasty_id
        )
        
        person_id = self.person_repo.insert(new_person)
        new_person.id = person_id
        
        self.created_person = new_person
        
        self.accept()
    
    def get_created_person(self) -> Person | None:
        """Returns the created child Person."""
        return self.created_person

>> âœ… dialogs\create_event_dialog.py (50 code lines)
"""Dialog for creating a new event."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QComboBox,
    QLabel, QDialogButtonBox, QWidget, QMessageBox, QTextEdit, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

from database.db_manager import DatabaseManager
from models.person import Person
from models.event import Event
from widgets.date_picker import DatePicker


class CreateEventDialog(QDialog):
    """Dialog for creating a new life event."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person = person
        self.created_event: Event | None = None
        
        self.setWindowTitle(f"Create Event for {person.display_name}")
        self.setMinimumWidth(550)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        LABEL_WIDTH = 100
        
        # Event Type
        type_layout = QHBoxLayout()
        type_label = QLabel("Event Type: *")
        type_label.setMinimumWidth(LABEL_WIDTH)
        type_layout.addWidget(type_label)
        
        self.event_type_input = QComboBox()
        self.event_type_input.addItems([
            "Birth", "Death", "Marriage", "Divorce",
            "Job", "Education", "Move", "Military",
            "Immigration", "Other"
        ])
        self.event_type_input.setEditable(True)
        type_layout.addWidget(self.event_type_input)
        layout.addLayout(type_layout)
        
        # Event Title
        title_layout = QHBoxLayout()
        title_label = QLabel("Event Title: *")
        title_label.setMinimumWidth(LABEL_WIDTH)
        title_layout.addWidget(title_label)
        
        self.event_title_input = QLineEdit()
        self.event_title_input.setPlaceholderText("E.g., 'Became Blacksmith', 'Moved to Town'")
        title_layout.addWidget(self.event_title_input)
        layout.addLayout(title_layout)
        
        # Start Date
        start_date_layout = QHBoxLayout()
        start_date_label = QLabel("Start Date:")
        start_date_label.setMinimumWidth(LABEL_WIDTH)
        start_date_layout.addWidget(start_date_label)
        
        self.start_date_picker = DatePicker()
        self.start_date_picker.set_date(1721, 1)
        start_date_layout.addWidget(self.start_date_picker)
        start_date_layout.addStretch()
        layout.addLayout(start_date_layout)
        
        # Ongoing checkbox
        ongoing_layout = QHBoxLayout()
        ongoing_layout.addSpacing(LABEL_WIDTH + 10)
        
        self.ongoing_check = QCheckBox("Ongoing Event")
        self.ongoing_check.setChecked(False)
        self.ongoing_check.stateChanged.connect(self._on_ongoing_toggled)
        ongoing_layout.addWidget(self.ongoing_check)
        ongoing_layout.addStretch()
        layout.addLayout(ongoing_layout)
        
        # End Date
        end_date_layout = QHBoxLayout()
        self.end_date_label = QLabel("End Date:")
        self.end_date_label.setMinimumWidth(LABEL_WIDTH)
        end_date_layout.addWidget(self.end_date_label)
        
        self.end_date_picker = DatePicker()
        self.end_date_picker.set_date(1721, 1)
        end_date_layout.addWidget(self.end_date_picker)
        end_date_layout.addStretch()
        layout.addLayout(end_date_layout)
        
        # Notes
        notes_layout = QVBoxLayout()
        notes_label = QLabel("Notes:")
        notes_layout.addWidget(notes_label)
        
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this event...")
        self.notes_input.setMaximumHeight(100)
        notes_layout.addWidget(self.notes_input)
        layout.addLayout(notes_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        self._update_ongoing_state()
    
    def _on_ongoing_toggled(self) -> None:
        """Handle ongoing checkbox toggle."""
        self._update_ongoing_state()
    
    def _update_ongoing_state(self) -> None:
        """Show/hide end date based on ongoing status."""
        is_ongoing = self.ongoing_check.isChecked()
        self.end_date_label.setVisible(not is_ongoing)
        self.end_date_picker.setVisible(not is_ongoing)
    
    def _handle_accept(self) -> None:
        """Validate and create event."""
        event_type = self.event_type_input.currentText().strip()
        event_title = self.event_title_input.text().strip()
        
        if not event_type:
            QMessageBox.warning(self, "Validation Error", "Event type is required.")
            return
        
        if not event_title:
            QMessageBox.warning(self, "Validation Error", "Event title is required.")
            return
        
        start_year, start_month = self.start_date_picker.get_date()
        
        if self.ongoing_check.isChecked():
            end_year, end_month = None, None
        else:
            end_year, end_month = self.end_date_picker.get_date()
            
            # Validate end date after start date
            if start_year and end_year:
                if end_year < start_year:
                    QMessageBox.warning(self, "Invalid Date", "End date cannot be before start date.")
                    return
                elif end_year == start_year and start_month and end_month:
                    if end_month < start_month:
                        QMessageBox.warning(self, "Invalid Date", "End date cannot be before start date.")
                        return
        
        notes = self.notes_input.toPlainText().strip()
        
        self.created_event = Event(
            person_id=self.person.id,
            event_type=event_type,
            event_title=event_title,
            start_year=start_year,
            start_month=start_month,
            end_year=end_year,
            end_month=end_month,
            notes=notes
        )
        
        self.accept()
    
    def get_created_event(self) -> Event | None:
        """Returns the created event."""
        return self.created_event

>> âœ… dialogs\create_marriage_dialog.py (36 code lines)
"""Dialog for creating a new marriage."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QCheckBox,
    QDialogButtonBox, QWidget, QMessageBox
)

from database.db_manager import DatabaseManager
from models.person import Person
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker


class CreateMarriageDialog(QDialog):
    """Dialog for creating a new marriage relationship."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person = person
        self.spouse_id: int | None = None
        self.marriage_year: int | None = None
        self.marriage_month: int | None = None
        
        self.setWindowTitle("Create Marriage")
        self.setMinimumWidth(450)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        # Person 1
        person1_layout = QHBoxLayout()
        person1_layout.addWidget(QLabel("Person 1:"))
        person1_label = QLabel(f"<b>{self.person.display_name}</b>")
        person1_layout.addWidget(person1_label)
        person1_layout.addStretch()
        layout.addLayout(person1_layout)
        
        # Person 2
        person2_layout = QHBoxLayout()
        person2_layout.addWidget(QLabel("Person 2:"))
        self.spouse_selector = PersonSelector(self.db_manager)
        person2_layout.addWidget(self.spouse_selector)
        layout.addLayout(person2_layout)
        
        # Date Unknown checkbox
        date_unknown_layout = QHBoxLayout()
        date_unknown_layout.addSpacing(85)  # Align with fields above
        self.date_unknown_check = QCheckBox("Date Unknown")
        self.date_unknown_check.setChecked(True)
        self.date_unknown_check.stateChanged.connect(self._on_date_unknown_toggled)
        date_unknown_layout.addWidget(self.date_unknown_check)
        date_unknown_layout.addStretch()
        layout.addLayout(date_unknown_layout)
        
        # Marriage date
        marriage_date_layout = QHBoxLayout()
        self.marriage_date_label = QLabel("Marriage Date:")
        marriage_date_layout.addWidget(self.marriage_date_label)
        self.marriage_date = DatePicker()
        self.marriage_date.set_date(1721, 1)
        self.marriage_date.unknown_check.setVisible(False)
        marriage_date_layout.addWidget(self.marriage_date)
        marriage_date_layout.addStretch()
        layout.addLayout(marriage_date_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        self._update_date_visibility()
    
    def _on_date_unknown_toggled(self) -> None:
        """Handle date unknown checkbox toggle."""
        self._update_date_visibility()
    
    def _update_date_visibility(self) -> None:
        """Show/hide marriage date based on checkbox."""
        date_known = not self.date_unknown_check.isChecked()
        self.marriage_date_label.setVisible(date_known)
        self.marriage_date.setVisible(date_known)
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        spouse_id = self.spouse_selector.get_person_id()
        
        if not spouse_id:
            QMessageBox.warning(self, "Validation Error", "Please select a spouse.")
            return
        
        if spouse_id == self.person.id:
            QMessageBox.warning(self, "Validation Error", "A person cannot marry themselves.")
            return
        
        # Only get date if Date Unknown is NOT checked
        if self.date_unknown_check.isChecked():
            # Explicitly set to None - date is unknown
            self.spouse_id = spouse_id
            self.marriage_year = None
            self.marriage_month = None
        else:
            # Get date from picker
            year, month = self.marriage_date.get_date()
            self.spouse_id = spouse_id
            self.marriage_year = year
            self.marriage_month = month
        
        self.accept()
    
    def get_marriage_data(self) -> tuple[int | None, int | None, int | None]:
        """Returns (spouse_id, year, month)."""
        return (self.spouse_id, self.marriage_year, self.marriage_month)

>> âœ… dialogs\edit_event_dialog.py (45 code lines)
"""Dialog for editing an existing event."""

from dataclasses import replace

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QComboBox,
    QLabel, QDialogButtonBox, QWidget, QMessageBox, QTextEdit, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

from database.db_manager import DatabaseManager
from models.event import Event
from widgets.date_picker import DatePicker


class EditEventDialog(QDialog):
    """Dialog for editing an existing life event."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        life_event: Event,
        parent: QWidget | None = None
    ) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.life_event = life_event
        self.edited_event: Event | None = None
        
        self.setWindowTitle(f"Edit Event: {life_event.event_title}")
        self.setMinimumWidth(550)
        
        self._setup_ui()
        self._load_event()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        LABEL_WIDTH = 100
        
        # Event Type
        type_layout = QHBoxLayout()
        type_label = QLabel("Event Type: *")
        type_label.setMinimumWidth(LABEL_WIDTH)
        type_layout.addWidget(type_label)
        
        self.event_type_input = QComboBox()
        self.event_type_input.addItems([
            "Birth", "Death", "Marriage", "Divorce",
            "Job", "Education", "Move", "Military",
            "Immigration", "Other"
        ])
        self.event_type_input.setEditable(True)
        type_layout.addWidget(self.event_type_input)
        layout.addLayout(type_layout)
        
        # Event Title
        title_layout = QHBoxLayout()
        title_label = QLabel("Event Title: *")
        title_label.setMinimumWidth(LABEL_WIDTH)
        title_layout.addWidget(title_label)
        
        self.event_title_input = QLineEdit()
        self.event_title_input.setPlaceholderText("E.g., 'Became Blacksmith', 'Moved to Town'")
        title_layout.addWidget(self.event_title_input)
        layout.addLayout(title_layout)
        
        # Start Date
        start_date_layout = QHBoxLayout()
        start_date_label = QLabel("Start Date:")
        start_date_label.setMinimumWidth(LABEL_WIDTH)
        start_date_layout.addWidget(start_date_label)
        
        self.start_date_picker = DatePicker()
        start_date_layout.addWidget(self.start_date_picker)
        start_date_layout.addStretch()
        layout.addLayout(start_date_layout)
        
        # Ongoing checkbox
        ongoing_layout = QHBoxLayout()
        ongoing_layout.addSpacing(LABEL_WIDTH + 10)
        
        self.ongoing_check = QCheckBox("Ongoing Event")
        self.ongoing_check.stateChanged.connect(self._on_ongoing_toggled)
        ongoing_layout.addWidget(self.ongoing_check)
        ongoing_layout.addStretch()
        layout.addLayout(ongoing_layout)
        
        # End Date
        end_date_layout = QHBoxLayout()
        self.end_date_label = QLabel("End Date:")
        self.end_date_label.setMinimumWidth(LABEL_WIDTH)
        end_date_layout.addWidget(self.end_date_label)
        
        self.end_date_picker = DatePicker()
        end_date_layout.addWidget(self.end_date_picker)
        end_date_layout.addStretch()
        layout.addLayout(end_date_layout)
        
        # Notes
        notes_layout = QVBoxLayout()
        notes_label = QLabel("Notes:")
        notes_layout.addWidget(notes_label)
        
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this event...")
        self.notes_input.setMaximumHeight(100)
        notes_layout.addWidget(self.notes_input)
        layout.addLayout(notes_layout)
        
        layout.addStretch()
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok |
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def _load_event(self) -> None:
        """Load event data into form fields."""
        blockers = [
            QSignalBlocker(self.event_type_input),
            QSignalBlocker(self.event_title_input),
            QSignalBlocker(self.start_date_picker),
            QSignalBlocker(self.ongoing_check),
            QSignalBlocker(self.end_date_picker),
            QSignalBlocker(self.notes_input),
        ]
        
        # Event Type
        index = self.event_type_input.findText(self.life_event.event_type)
        if index >= 0:
            self.event_type_input.setCurrentIndex(index)
        else:
            self.event_type_input.setCurrentText(self.life_event.event_type)
        
        # Event Title
        self.event_title_input.setText(self.life_event.event_title)
        
        # Start Date
        if self.life_event.start_year:
            self.start_date_picker.set_date(self.life_event.start_year, self.life_event.start_month)
        
        # Ongoing / End Date
        if self.life_event.is_ongoing:
            self.ongoing_check.setChecked(True)
        else:
            self.ongoing_check.setChecked(False)
            if self.life_event.end_year:
                self.end_date_picker.set_date(self.life_event.end_year, self.life_event.end_month)
        
        # Notes
        self.notes_input.setPlainText(self.life_event.notes)
        
        self._update_ongoing_state()
    
    def _on_ongoing_toggled(self) -> None:
        """Handle ongoing checkbox toggle."""
        self._update_ongoing_state()
    
    def _update_ongoing_state(self) -> None:
        """Show/hide end date based on ongoing status."""
        is_ongoing = self.ongoing_check.isChecked()
        self.end_date_label.setVisible(not is_ongoing)
        self.end_date_picker.setVisible(not is_ongoing)
    
    def _handle_accept(self) -> None:
        """Validate and save event."""
        event_type = self.event_type_input.currentText().strip()
        event_title = self.event_title_input.text().strip()
        
        if not event_type:
            QMessageBox.warning(self, "Validation Error", "Event type is required.")
            return
        
        if not event_title:
            QMessageBox.warning(self, "Validation Error", "Event title is required.")
            return
        
        start_year, start_month = self.start_date_picker.get_date()
        
        if self.ongoing_check.isChecked():
            end_year, end_month = None, None
        else:
            end_year, end_month = self.end_date_picker.get_date()
            
            # Validate end date after start date
            if start_year and end_year:
                if end_year < start_year:
                    QMessageBox.warning(self, "Invalid Date", "End date cannot be before start date.")
                    return
                elif end_year == start_year and start_month and end_month:
                    if end_month < start_month:
                        QMessageBox.warning(self, "Invalid Date", "End date cannot be before start date.")
                        return
        
        notes = self.notes_input.toPlainText().strip()
        
        # Create edited event
        self.edited_event = replace(
            self.life_event,
            event_type=event_type,
            event_title=event_title,
            start_year=start_year,
            start_month=start_month,
            end_year=end_year,
            end_month=end_month,
            notes=notes
        )
        
        self.accept()
    
    def get_edited_event(self) -> Event | None:
        """Returns the edited event."""
        return self.edited_event

>> âœ… dialogs\edit_person_dialog.py (43 code lines)
"""Dialog for editing a person with tabbed sections."""

from dataclasses import replace

from PySide6.QtWidgets import (
    QDialog, QHBoxLayout, QVBoxLayout, QListWidget,
    QStackedWidget, QDialogButtonBox, QWidget, QMessageBox
)

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from models.person import Person
from dialogs.edit_person_panels.general_panel import GeneralPanel
from dialogs.edit_person_panels.relationships_panel import RelationshipsPanel
from dialogs.edit_person_panels.event_panel import EventsPanel


class EditPersonDialog(QDialog):
    """Tabbed dialog for comprehensive person editing."""
    
    def __init__(
        self,
        db_manager: DatabaseManager,
        person: Person,
        parent: QWidget | None = None
    ) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person = person
        self.has_unsaved_changes = False
        self.edited_person: Person | None = None
        
        self.setWindowTitle(f"Edit Person: {person.display_name}")
        self.setMinimumSize(700, 500)
        
        self._setup_ui()
        self._load_data()
    
    def _setup_ui(self) -> None:
        """Create the main dialog layout with sidebar and panels."""
        main_layout = QVBoxLayout(self)
        content_layout = QHBoxLayout()
        
        # Left sidebar
        self.panel_list = QListWidget()
        self.panel_list.setMaximumWidth(150)
        self.panel_list.addItem("General")
        self.panel_list.addItem("Relationships")
        self.panel_list.addItem("Events")
        self.panel_list.currentRowChanged.connect(self._on_panel_changed)
        
        # Right side - stacked panels
        self.panel_stack = QStackedWidget()
        
        self.general_panel_widget = GeneralPanel(self)
        self.relationships_panel_widget = RelationshipsPanel(self.db_manager, self)
        self.events_panel_widget = EventsPanel(self.db_manager, self)
        
        self.panel_stack.addWidget(self.general_panel_widget)
        self.panel_stack.addWidget(self.relationships_panel_widget)
        self.panel_stack.addWidget(self.events_panel_widget)
        
        content_layout.addWidget(self.panel_list)
        content_layout.addWidget(self.panel_stack, stretch=1)
        main_layout.addLayout(content_layout)
        
        # Bottom buttons
        button_box = QDialogButtonBox()
        
        self.apply_button = button_box.addButton(
            "Apply",
            QDialogButtonBox.ButtonRole.ApplyRole
        )
        self.apply_button.clicked.connect(self._handle_apply)
        
        self.ok_button = button_box.addButton(QDialogButtonBox.StandardButton.Ok)
        self.ok_button.clicked.connect(self._handle_ok)
        
        self.cancel_button = button_box.addButton(QDialogButtonBox.StandardButton.Cancel)
        self.cancel_button.clicked.connect(self.reject)
        
        main_layout.addWidget(button_box)
        
        self.panel_list.setCurrentRow(0)
    
    def _on_panel_changed(self, index: int) -> None:
        """Handle panel selection change."""
        self.panel_stack.setCurrentIndex(index)
    
    def _load_data(self) -> None:
        """Load person data into all panels."""
        self.general_panel_widget.load_person(self.person)
        self.relationships_panel_widget.load_person(self.person)
        self.events_panel_widget.load_person(self.person)
    
    def _handle_apply(self) -> None:
        """Save changes but keep dialog open."""
        if self._save_changes():
            self.has_unsaved_changes = False
    
    def _handle_ok(self) -> None:
        """Save changes and close dialog with confirmation."""
        if self._save_changes():
            self.has_unsaved_changes = False
            
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Information)
            msg.setWindowTitle("Changes Saved")
            msg.setText("Your edits have been saved successfully.")
            msg.exec()
            
            self.accept()
    
    def _save_changes(self) -> bool:
        """Collect and validate data from all panels, then save."""
        is_valid, error_msg = self.general_panel_widget.validate()
        if not is_valid:
            QMessageBox.warning(self, "Validation Error", error_msg)
            return False
        
        is_valid, error_msg = self.relationships_panel_widget.validate()
        if not is_valid:
            QMessageBox.warning(self, "Validation Error", error_msg)
            self.panel_list.setCurrentRow(1)
            return False
        
        person_data = self.general_panel_widget.get_person_data()
        relationship_data = self.relationships_panel_widget.get_relationship_data()
        person_data.update(relationship_data)
        
        self.edited_person = replace(self.person, **person_data)
        
        person_repo = PersonRepository(self.db_manager)
        person_repo.update(self.edited_person)
        
        self.relationships_panel_widget.save_marriages()
        self.events_panel_widget.save_events()
        
        self.person = self.edited_person
        
        return True
    
    def reject(self) -> None:
        """Handle Cancel button - warn if unsaved changes."""
        if self.has_unsaved_changes:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Warning)
            msg.setWindowTitle("Unsaved Changes")
            msg.setText("You have unsaved changes. Discard them?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel
            )
            
            if msg.exec() == QMessageBox.StandardButton.Discard:
                super().reject()
        else:
            super().reject()
    
    def mark_dirty(self) -> None:
        """Mark the dialog as having unsaved changes."""
        self.has_unsaved_changes = True
    
    def get_edited_person(self) -> Person | None:
        """Get the edited person data after dialog is accepted."""
        return self.edited_person

>> ðŸ“‹ dialogs\edit_person_panels\__init__.py (2 code lines)
from .general_panel import GeneralPanel

__all__ = ['GeneralPanel', ]

>> âœ… dialogs\edit_person_panels\event_panel.py (77 code lines)
"""Events panel for Edit Person dialog."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QScrollArea, QGroupBox,
    QPushButton, QLabel, QFrame, QHBoxLayout, QMessageBox
)
from PySide6.QtCore import QSignalBlocker

from database.db_manager import DatabaseManager
from database.event_repository import EventRepository
from models.person import Person
from models.event import Event


class EventsPanel(QWidget):
    """Panel for viewing and managing person's life events."""
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.event_repo = EventRepository(db_manager)
        self.current_person: Person | None = None
        
        self.event_widgets: list[tuple[Event, QFrame]] = []
        self.new_events: list[Event] = []
        self.deleted_event_ids: list[int] = []
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create the events timeline layout."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container = QWidget()
        layout = QVBoxLayout(container)
        
        # Events timeline section
        events_group = QGroupBox("Life Events Timeline")
        events_layout = QVBoxLayout(events_group)
        
        self.events_container = QVBoxLayout()
        events_layout.addLayout(self.events_container)
        
        # Add event button
        add_btn = QPushButton("+ Add Event")
        add_btn.clicked.connect(self._add_event)
        events_layout.addWidget(add_btn)
        
        layout.addWidget(events_group)
        layout.addStretch()
        
        scroll.setWidget(container)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll)
    
    def _create_event_widget(self, event: Event) -> QFrame:
        """Create a widget displaying an event in timeline format."""
        frame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        frame.setFrameShadow(QFrame.Shadow.Raised)
        main_layout = QVBoxLayout(frame)
        
        # Header: event type and title
        header_layout = QHBoxLayout()
        
        # Event type badge
        type_label = QLabel(f"[{event.event_type}]")
        type_label.setStyleSheet("font-weight: bold; color: #2196F3;")
        header_layout.addWidget(type_label)
        
        # Event title
        title_label = QLabel(event.event_title)
        title_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        header_layout.addWidget(title_label)
        
        header_layout.addStretch()
        
        # Ongoing badge
        if event.is_ongoing:
            ongoing_label = QLabel("â— Ongoing")
            ongoing_label.setStyleSheet("color: green; font-weight: bold;")
            header_layout.addWidget(ongoing_label)
        
        main_layout.addLayout(header_layout)
        
        # Date range
        date_label = QLabel(event.date_range_string)
        date_label.setStyleSheet("color: gray; font-style: italic;")
        main_layout.addWidget(date_label)
        
        # Notes (if present)
        if event.notes:
            notes_label = QLabel(event.notes)
            notes_label.setWordWrap(True)
            notes_label.setStyleSheet("margin-top: 5px; padding: 5px; background-color: #f5f5f5;")
            main_layout.addWidget(notes_label)
        
        # Action buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        edit_btn = QPushButton("Edit")
        edit_btn.clicked.connect(lambda: self._edit_event(event))
        button_layout.addWidget(edit_btn)
        
        delete_btn = QPushButton("Delete")
        delete_btn.clicked.connect(lambda: self._delete_event(event))
        button_layout.addWidget(delete_btn)
        
        main_layout.addLayout(button_layout)
        
        return frame
    
    def _add_event(self) -> None:
        """Open dialog to add a new event."""
        if not self.current_person:
            return
        
        from dialogs.create_event_dialog import CreateEventDialog
        dialog = CreateEventDialog(self.db_manager, self.current_person, self)
        
        if dialog.exec():
            created_event = dialog.get_created_event()
            if created_event:
                self.new_events.append(created_event)
                self._load_events()
                self._on_field_changed()
    
    def _edit_event(self, event: Event) -> None:
        """Open dialog to edit an event."""
        from dialogs.edit_event_dialog import EditEventDialog
        dialog = EditEventDialog(self.db_manager, event, self)
        
        if dialog.exec():
            edited_event = dialog.get_edited_event()
            if edited_event:
                # Update the event in place
                event.event_type = edited_event.event_type
                event.event_title = edited_event.event_title
                event.start_year = edited_event.start_year
                event.start_month = edited_event.start_month
                event.end_year = edited_event.end_year
                event.end_month = edited_event.end_month
                event.notes = edited_event.notes
                
                self._load_events()
                self._on_field_changed()

    def _delete_event(self, event: Event) -> None:
        """Delete an event after confirmation."""
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Delete Event")
        msg.setText(f"Are you sure you want to delete this event?\n\n{event.event_title}")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            if event.id:
                self.deleted_event_ids.append(event.id)
            if event in self.new_events:
                self.new_events.remove(event)
            
            self.event_widgets = [(e, w) for e, w in self.event_widgets if e != event]
            self._load_events()
            self._on_field_changed()
    
    def load_person(self, person: Person) -> None:
        """Load person's events."""
        self.current_person = person
        
        self.new_events.clear()
        self.deleted_event_ids.clear()
        
        self._load_events()
    
    def _load_events(self) -> None:
        """Load and display events in timeline order."""
        while self.events_container.count():
            item = self.events_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        self.event_widgets.clear()
        
        if not self.current_person or not self.current_person.id:
            placeholder = QLabel("No events recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.events_container.addWidget(placeholder)
            return
        
        # Get events from database
        events = self.event_repo.get_by_person(self.current_person.id)
        
        # Filter out deleted ones
        events = [e for e in events if e.id not in self.deleted_event_ids]
        
        # Add new events
        all_events = events + self.new_events
        
        # Sort chronologically
        all_events.sort(key=lambda e: (
            (9999, 12, 31) if e.start_year is None else 
            (e.start_year, e.start_month or 0, e.start_day or 0)
        ))
        
        if all_events:
            for event in all_events:
                widget = self._create_event_widget(event)
                self.events_container.addWidget(widget)
                self.event_widgets.append((event, widget))
        else:
            placeholder = QLabel("No events recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.events_container.addWidget(placeholder)
    
    def save_events(self) -> None:
        """Save all event changes to database."""
        for event_id in self.deleted_event_ids:
            self.event_repo.delete(event_id)
        
        for event in self.new_events:
            self.event_repo.insert(event)
        
        self.new_events.clear()
        self.deleted_event_ids.clear()
    
    def validate(self) -> tuple[bool, str]:
        """Validate event data."""
        return (True, "")
    
    def _on_field_changed(self) -> None:
        """Mark dialog as dirty when any field changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None

>> âœ… dialogs\edit_person_panels\general_panel.py (79 code lines)
"""General information panel for Edit Person dialog."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QLineEdit,
    QComboBox, QTextEdit, QLabel, QScrollArea, QCheckBox
)
from PySide6.QtCore import QSignalBlocker

from models.person import Person
from widgets.date_picker import DatePicker


class GeneralPanel(QWidget):
    """Panel for editing general person information."""
    
    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create all form fields."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container = QWidget()
        form = QFormLayout(container)
        
        # Name fields
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Required")
        self.first_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("First Name: *", self.first_name_input)
        
        self.middle_name_input = QLineEdit()
        self.middle_name_input.setPlaceholderText("Optional")
        self.middle_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Middle Name:", self.middle_name_input)
        
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Required")
        self.last_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Last Name: *", self.last_name_input)
        
        self.maiden_name_input = QLineEdit()
        self.maiden_name_input.setPlaceholderText("Optional")
        self.maiden_name_input.textChanged.connect(self._on_field_changed)
        form.addRow("Maiden Name:", self.maiden_name_input)
        
        self.nickname_input = QLineEdit()
        self.nickname_input.setPlaceholderText("Optional")
        self.nickname_input.textChanged.connect(self._on_field_changed)
        form.addRow("Nickname:", self.nickname_input)
        
        # Gender
        self.gender_input = QComboBox()
        self.gender_input.addItems(["Unknown", "Male", "Female", "Other"])
        self.gender_input.currentIndexChanged.connect(self._on_field_changed)
        form.addRow("Gender:", self.gender_input)
        
        # Birth Date
        self.birth_date_picker = DatePicker()
        self.birth_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow("Birth Date:", self.birth_date_picker)
        
        # Death Date with checkbox BELOW
        self.death_date_label = QLabel("Death Date:")
        self.death_date_picker = DatePicker()
        self.death_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.death_date_label, self.death_date_picker)
        
        self.died_check = QCheckBox("Died?")
        self.died_check.setChecked(False)
        self.died_check.stateChanged.connect(self._on_died_toggled)
        self.died_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.died_check)
        
        # Arrival Date with checkbox BELOW
        self.arrival_date_label = QLabel("Arrival Date:")
        self.arrival_date_picker = DatePicker()
        self.arrival_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.arrival_date_label, self.arrival_date_picker)
        
        self.immigrant_check = QCheckBox("Immigrant?")
        self.immigrant_check.setChecked(False)
        self.immigrant_check.stateChanged.connect(self._on_immigrant_toggled)
        self.immigrant_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.immigrant_check)
        
        # Moved Out Date with checkbox BELOW
        self.moved_out_date_label = QLabel("Moved Out Date:")
        self.moved_out_date_picker = DatePicker()
        self.moved_out_date_picker.dateChanged.connect(self._on_field_changed)
        form.addRow(self.moved_out_date_label, self.moved_out_date_picker)
        
        self.moved_out_check = QCheckBox("Moved Out?")
        self.moved_out_check.setChecked(False)
        self.moved_out_check.stateChanged.connect(self._on_moved_out_toggled)
        self.moved_out_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.moved_out_check)
        
        # Game-specific fields
        self.dynasty_id_input = QLineEdit()
        self.dynasty_id_input.setText("1")
        self.dynasty_id_input.textChanged.connect(self._on_field_changed)
        form.addRow("Dynasty ID:", self.dynasty_id_input)
        
        self.is_founder_check = QCheckBox("Is Dynasty Founder")
        self.is_founder_check.stateChanged.connect(self._on_field_changed)
        form.addRow("", self.is_founder_check)
        
        self.education_input = QComboBox()
        self.education_input.addItems([
            "0 - Uneducated", "1 - Basic", "2 - Elementary",
            "3 - Advanced", "4 - Expert", "5 - Master"
        ])
        self.education_input.currentIndexChanged.connect(self._on_field_changed)
        form.addRow("Education:", self.education_input)
        
        # Notes
        self.notes_input = QTextEdit()
        self.notes_input.setPlaceholderText("Optional notes about this person...")
        self.notes_input.setMaximumHeight(120)
        self.notes_input.textChanged.connect(self._on_field_changed)
        form.addRow("Notes:", self.notes_input)
        
        scroll.setWidget(container)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(scroll)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()

    def _on_immigrant_toggled(self) -> None:
        """Handle immigrant checkbox toggle."""
        self._update_immigrant_visibility()

    def _update_immigrant_visibility(self) -> None:
        """Show/hide arrival date based on checkbox."""
        is_immigrant = self.immigrant_check.isChecked()
        self.arrival_date_label.setVisible(is_immigrant)
        self.arrival_date_picker.setVisible(is_immigrant)

    def _on_died_toggled(self) -> None:
        """Handle died checkbox toggle."""
        self._update_died_visibility()

    def _update_died_visibility(self) -> None:
        """Show/hide death date based on checkbox."""
        has_died = self.died_check.isChecked()
        self.death_date_label.setVisible(has_died)
        self.death_date_picker.setVisible(has_died)

    def _on_moved_out_toggled(self) -> None:
        """Handle moved out checkbox toggle."""
        self._update_moved_out_visibility()
    
    def _update_moved_out_visibility(self) -> None:
        """Show/hide moved out date based on checkbox."""
        is_moved_out = self.moved_out_check.isChecked()
        self.moved_out_date_label.setVisible(is_moved_out)
        self.moved_out_date_picker.setVisible(is_moved_out)
    
    def _on_field_changed(self) -> None:
        """Mark dialog as dirty when any field changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    def load_person(self, person: Person) -> None:
        """Load person data into form fields."""
        blockers = [
            QSignalBlocker(self.first_name_input),
            QSignalBlocker(self.middle_name_input),
            QSignalBlocker(self.last_name_input),
            QSignalBlocker(self.maiden_name_input),
            QSignalBlocker(self.nickname_input),
            QSignalBlocker(self.gender_input),
            QSignalBlocker(self.birth_date_picker),
            QSignalBlocker(self.died_check),
            QSignalBlocker(self.death_date_picker),
            QSignalBlocker(self.immigrant_check),
            QSignalBlocker(self.arrival_date_picker),
            QSignalBlocker(self.moved_out_check),
            QSignalBlocker(self.moved_out_date_picker),
            QSignalBlocker(self.dynasty_id_input),
            QSignalBlocker(self.is_founder_check),
            QSignalBlocker(self.education_input),
            QSignalBlocker(self.notes_input),
        ]
        
        # Names
        self.first_name_input.setText(person.first_name or "")
        self.middle_name_input.setText(person.middle_name or "")
        self.last_name_input.setText(person.last_name or "")
        self.maiden_name_input.setText(person.maiden_name or "")
        self.nickname_input.setText(person.nickname or "")
        
        # Gender
        if person.gender:
            index = self.gender_input.findText(person.gender)
            if index >= 0:
                self.gender_input.setCurrentIndex(index)
        
        # Dates
        if person.birth_year:
            self.birth_date_picker.set_date(person.birth_year, person.birth_month)
        
        if person.death_year:
            self.died_check.setChecked(True)
            self.death_date_picker.set_date(person.death_year, person.death_month)
        else:
            self.died_check.setChecked(False)
        
        if person.arrival_year:
            self.immigrant_check.setChecked(True)
            self.arrival_date_picker.set_date(person.arrival_year, person.arrival_month)
            self.arrival_date_picker.unknown_check.setVisible(False)
        else:
            self.immigrant_check.setChecked(False)
        
        if person.moved_out_year:
            self.moved_out_check.setChecked(True)
            self.moved_out_date_picker.set_date(person.moved_out_year, person.moved_out_month)
        else:
            self.moved_out_check.setChecked(False)
        
        self._update_died_visibility()
        self._update_immigrant_visibility()
        self._update_moved_out_visibility()
        
        # Game fields
        self.dynasty_id_input.setText(str(person.dynasty_id))
        self.is_founder_check.setChecked(person.is_founder)
        self.education_input.setCurrentIndex(person.education)
        
        # Notes
        self.notes_input.setPlainText(person.notes or "")
    
    def get_person_data(self) -> dict:
        """Extract form data as dictionary."""
        birth_year, birth_month = self.birth_date_picker.get_date()
        
        if self.died_check.isChecked():
            death_year, death_month = self.death_date_picker.get_date()
        else:
            death_year, death_month = None, None
        
        if self.immigrant_check.isChecked():
            arrival_year, arrival_month = self.arrival_date_picker.get_date()
        else:
            arrival_year, arrival_month = None, None
        
        if self.moved_out_check.isChecked():
            moved_out_year, moved_out_month = self.moved_out_date_picker.get_date()
        else:
            moved_out_year, moved_out_month = None, None
        
        education_text = self.education_input.currentText()
        education_level = int(education_text.split(" ")[0])
        
        return {
            'first_name': self.first_name_input.text().strip(),
            'middle_name': self.middle_name_input.text().strip(),
            'last_name': self.last_name_input.text().strip(),
            'maiden_name': self.maiden_name_input.text().strip(),
            'nickname': self.nickname_input.text().strip(),
            'gender': self.gender_input.currentText(),
            'birth_year': birth_year,
            'birth_month': birth_month,
            'death_year': death_year,
            'death_month': death_month,
            'arrival_year': arrival_year,
            'arrival_month': arrival_month,
            'moved_out_year': moved_out_year,
            'moved_out_month': moved_out_month,
            'dynasty_id': int(self.dynasty_id_input.text() or "1"),
            'is_founder': self.is_founder_check.isChecked(),
            'education': education_level,
            'notes': self.notes_input.toPlainText().strip()
        }

    def validate(self) -> tuple[bool, str]:
        """Validate form data."""
        if not self.first_name_input.text().strip():
            return (False, "First name is required.")
        
        if not self.last_name_input.text().strip():
            return (False, "Last name is required.")
        
        try:
            dynasty_id = int(self.dynasty_id_input.text())
            if dynasty_id < 1:
                return (False, "Dynasty ID must be a positive number.")
        except ValueError:
            return (False, "Dynasty ID must be a valid number.")
        
        return (True, "")

>> âœ… dialogs\edit_person_panels\relationships_panel.py (239 code lines)
"""Relationships panel for Edit Person dialog."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, 
    QLabel, QScrollArea, QCheckBox,
    QGroupBox, QPushButton, QHBoxLayout, 
    QFrame, QMessageBox, QComboBox
)
from PySide6.QtCore import QSignalBlocker

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from database.marriage_repository import MarriageRepository
from models.person import Person
from models.marriage import Marriage
from widgets.person_selector import PersonSelector
from widgets.date_picker import DatePicker
from dialogs.end_marriage_dialog import EndMarriageDialog


class RelationshipsPanel(QWidget):
    """Panel for editing person relationships."""
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        self.marriage_repo = MarriageRepository(db_manager)
        self.current_person: Person | None = None
        
        self.marriage_widgets: list[tuple[Marriage, QFrame]] = []
        self.new_marriages: list[Marriage] = []
        self.deleted_marriage_ids: list[int] = []
        self.modified_marriages: dict[int, Marriage] = {}
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create all relationship sections."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        
        container = QWidget()
        layout = QVBoxLayout(container)
        
        layout.addWidget(self._create_parents_section())
        layout.addWidget(self._create_marriages_section())
        layout.addWidget(self._create_children_section())
        layout.addStretch()
        
        scroll.setWidget(container)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll)
    
    def _create_parents_section(self) -> QGroupBox:
        """Create parents section with father/mother selectors."""
        group = QGroupBox("Parents")
        layout = QVBoxLayout(group)
        form = QFormLayout()
        
        # Father selector
        self.father_selector = PersonSelector(self.db_manager)
        self.father_selector.set_filter(gender="Male")
        self.father_selector.personSelected.connect(self._on_field_changed)
        self.father_selector.selectionCleared.connect(self._on_field_changed)
        self.father_selector.personSelected.connect(lambda: self._load_siblings())
        
        father_row = QHBoxLayout()
        father_row.addWidget(self.father_selector)
        self.father_jump_btn = QPushButton("View Person")
        self.father_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.father_selector.get_person_id())
        )
        father_row.addWidget(self.father_jump_btn)
        form.addRow("Father:", father_row)
        
        # Mother selector
        self.mother_selector = PersonSelector(self.db_manager)
        self.mother_selector.set_filter(gender="Female")
        self.mother_selector.personSelected.connect(self._on_field_changed)
        self.mother_selector.selectionCleared.connect(self._on_field_changed)
        self.mother_selector.personSelected.connect(lambda: self._load_siblings())
        
        mother_row = QHBoxLayout()
        mother_row.addWidget(self.mother_selector)
        self.mother_jump_btn = QPushButton("View Person")
        self.mother_jump_btn.clicked.connect(
            lambda: self._jump_to_person(self.mother_selector.get_person_id())
        )
        mother_row.addWidget(self.mother_jump_btn)
        form.addRow("Mother:", mother_row)
        
        layout.addLayout(form)
        
        layout.addWidget(QLabel("<b>Siblings:</b>"))
        self.siblings_container = QVBoxLayout()
        layout.addLayout(self.siblings_container)
        
        return group
    
    def _create_marriages_section(self) -> QGroupBox:
        """Create marriages section with inline editing."""
        group = QGroupBox("Marriages")
        layout = QVBoxLayout(group)
        
        self.marriages_container = QVBoxLayout()
        layout.addLayout(self.marriages_container)
        
        add_btn = QPushButton("+ Add New Marriage")
        add_btn.clicked.connect(self._add_marriage)
        layout.addWidget(add_btn)
        
        return group
    
    def _create_children_section(self) -> QGroupBox:
        """Create children section."""
        group = QGroupBox("Children")
        layout = QVBoxLayout(group)
        
        self.children_container = QVBoxLayout()
        layout.addLayout(self.children_container)
        
        add_btn = QPushButton("+ Add Child")
        add_btn.clicked.connect(self._add_child)
        layout.addWidget(add_btn)
        
        return group
    
    def _create_marriage_widget(self, marriage: Marriage) -> QFrame:
        """Create inline editable widget for a marriage."""
        frame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        frame.setFrameShadow(QFrame.Shadow.Raised)
        main_layout = QVBoxLayout(frame)
        
        # Status header
        header_layout = QHBoxLayout()
        status_indicator = QLabel("âœ“ Active" if marriage.is_active else "â—‹ Ended")
        status_indicator.setStyleSheet(
            f"font-weight: bold; color: {'green' if marriage.is_active else 'gray'}"
        )
        header_layout.addWidget(status_indicator)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)
        
        # Spouse row
        spouse_layout = QHBoxLayout()
        spouse_layout.addWidget(QLabel("Spouse:"))
        
        spouse_selector = PersonSelector(self.db_manager)
        with QSignalBlocker(spouse_selector):
            if self.current_person and self.current_person.id:
                spouse_id = self.marriage_repo.get_spouse_id(marriage, self.current_person.id)
            else:
                spouse_id = None
            
            if spouse_id:
                spouse_selector.set_person(spouse_id)
        
        spouse_selector.personSelected.connect(self._on_field_changed)
        spouse_layout.addWidget(spouse_selector)
        
        spouse_jump_btn = QPushButton("View Person")
        spouse_jump_btn.setEnabled(spouse_id is not None)
        spouse_jump_btn.clicked.connect(lambda: self._jump_to_person(spouse_selector.get_person_id()))
        spouse_selector.personSelected.connect(lambda: spouse_jump_btn.setEnabled(True))
        spouse_selector.selectionCleared.connect(lambda: spouse_jump_btn.setEnabled(False))
        spouse_layout.addWidget(spouse_jump_btn)
        
        main_layout.addLayout(spouse_layout)
        
        # Date Unknown checkbox (stays in place)
        date_unknown_layout = QHBoxLayout()
        date_unknown_layout.addSpacing(60)  # Indent to align with fields above
        
        date_unknown_check = QCheckBox("Date Unknown")
        date_unknown_check.setChecked(marriage.marriage_year is None)
        date_unknown_layout.addWidget(date_unknown_check)
        date_unknown_layout.addStretch()
        
        main_layout.addLayout(date_unknown_layout)
        
        # Marriage date row (appears/disappears below)
        marriage_date_layout = QHBoxLayout()
        marriage_date_label = QLabel("Married:")
        marriage_date_layout.addWidget(marriage_date_label)
        
        marriage_date = DatePicker()
        with QSignalBlocker(marriage_date):
            if marriage.marriage_year:
                marriage_date.set_date(marriage.marriage_year, marriage.marriage_month or 1)
            else:
                marriage_date.set_date(1721, 1)
        
        marriage_date.unknown_check.setVisible(False)
        marriage_date.dateChanged.connect(self._on_field_changed)
        marriage_date_layout.addWidget(marriage_date)
        marriage_date_layout.addStretch()
        
        main_layout.addLayout(marriage_date_layout)
        
        # Initially hide/show based on whether date is known
        date_known = marriage.marriage_year is not None
        marriage_date_label.setVisible(date_known)
        marriage_date.setVisible(date_known)
        
        # Connect checkbox to toggle visibility
        def toggle_date_visibility():
            date_is_known = not date_unknown_check.isChecked()
            marriage_date_label.setVisible(date_is_known)
            marriage_date.setVisible(date_is_known)
            self._on_field_changed()
        
        date_unknown_check.stateChanged.connect(toggle_date_visibility)
        
        # End date and reason (if ended)
        if not marriage.is_active:
            end_date_layout = QHBoxLayout()
            end_date_layout.addWidget(QLabel("Ended:"))
            
            end_date = DatePicker()
            with QSignalBlocker(end_date):
                if marriage.dissolution_year:
                    end_date.set_date(marriage.dissolution_year, marriage.dissolution_month)
            
            end_date.dateChanged.connect(self._on_field_changed)
            end_date_layout.addWidget(end_date)
            end_date_layout.addStretch()
            main_layout.addLayout(end_date_layout)
            
            reason_layout = QHBoxLayout()
            reason_layout.addWidget(QLabel("Reason:"))
            
            reason_combo = QComboBox()
            with QSignalBlocker(reason_combo):
                reason_combo.addItems(["Death", "Divorce", "Annulment", "Other", "Unknown"])
                if marriage.dissolution_reason:
                    index = reason_combo.findText(marriage.dissolution_reason)
                    if index >= 0:
                        reason_combo.setCurrentIndex(index)
            
            reason_combo.currentIndexChanged.connect(self._on_field_changed)
            reason_layout.addWidget(reason_combo)
            reason_layout.addStretch()
            main_layout.addLayout(reason_layout)
        
        # Action buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        if marriage.is_active:
            end_btn = QPushButton("End Marriage")
            end_btn.clicked.connect(lambda: self._end_marriage(marriage))
            button_layout.addWidget(end_btn)
        else:
            reactivate_btn = QPushButton("Reactivate")
            reactivate_btn.clicked.connect(lambda: self._reactivate_marriage(marriage))
            button_layout.addWidget(reactivate_btn)
        
        delete_btn = QPushButton("Delete")
        delete_btn.clicked.connect(lambda: self._delete_marriage(marriage))
        button_layout.addWidget(delete_btn)
        
        main_layout.addLayout(button_layout)
        
        # Store widget references
        frame.spouse_selector = spouse_selector  # type: ignore[attr-defined]
        frame.date_unknown_check = date_unknown_check  # type: ignore[attr-defined]
        frame.marriage_date = marriage_date  # type: ignore[attr-defined]
        if not marriage.is_active:
            frame.end_date = end_date  # type: ignore[attr-defined]
            frame.reason_combo = reason_combo  # type: ignore[attr-defined]
        
        return frame
    
    def _create_person_widget(self, person: Person, show_remove: bool = False) -> QFrame:
        """Create widget displaying a person with jump button."""
        frame = QFrame()
        frame.setFrameShape(QFrame.Shape.StyledPanel)
        layout = QHBoxLayout(frame)
        
        birth_info = f"b. {person.birth_year}" if person.birth_year else "birth unknown"
        info_label = QLabel(f"{person.display_name} ({birth_info})")
        layout.addWidget(info_label)
        layout.addStretch()
        
        jump_btn = QPushButton("View Person")
        jump_btn.clicked.connect(lambda: self._jump_to_person(person.id))
        layout.addWidget(jump_btn)
        
        if show_remove:
            remove_btn = QPushButton("Remove")
            remove_btn.clicked.connect(lambda: self._remove_child(person))
            layout.addWidget(remove_btn)
        
        return frame
    
    def _on_field_changed(self) -> None:
        """Mark dialog as dirty when any field changes."""
        dialog = self._find_parent_dialog()
        if dialog:
            dialog.mark_dirty()
    
    def _find_parent_dialog(self):
        """Find the parent EditPersonDialog."""
        parent = self.parent()
        while parent:
            from dialogs.edit_person_dialog import EditPersonDialog
            if isinstance(parent, EditPersonDialog):
                return parent
            parent = parent.parent()
        return None
    
    def _jump_to_person(self, person_id: int | None) -> None:
        """Jump to editing a different person."""
        if person_id is None:
            return
        
        dialog = self._find_parent_dialog()
        if not dialog:
            return
        
        person = self.person_repo.get_by_id(person_id)
        if not person:
            return
        
        if dialog.has_unsaved_changes:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Question)
            msg.setWindowTitle("Save Changes?")
            msg.setText("Save changes before jumping to another person?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Save |
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel
            )
            
            result = msg.exec()
            if result == QMessageBox.StandardButton.Cancel:
                return
            elif result == QMessageBox.StandardButton.Save:
                if not dialog._save_changes():
                    return
        
        dialog.person = person
        dialog.setWindowTitle(f"Edit Person: {person.display_name}")
        dialog._load_data()
        dialog.has_unsaved_changes = False
        dialog.panel_list.setCurrentRow(1)
    
    def _add_marriage(self) -> None:
        """Add a new marriage using dialog."""
        if not self.current_person or not self.current_person.id:
            return
        
        active_marriages = [m for m, _ in self.marriage_widgets if m.is_active]
        
        # Validate active marriages have spouses
        for marriage, widget in self.marriage_widgets:
            if marriage.is_active:
                spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                if not spouse_selector.get_person_id():
                    QMessageBox.warning(
                        self,
                        "Incomplete Marriage",
                        "Please select a spouse for the current marriage before adding a new one."
                    )
                    return
        
        if active_marriages:
            msg = QMessageBox(self)
            msg.setIcon(QMessageBox.Icon.Question)
            msg.setWindowTitle("End Current Marriage?")
            msg.setText("This person has an active marriage. End it before creating a new one?")
            msg.setStandardButtons(
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if msg.exec() == QMessageBox.StandardButton.Yes:
                marriage = active_marriages[0]
                from dialogs.end_marriage_dialog import EndMarriageDialog
                end_dialog = EndMarriageDialog(marriage, self)
                
                if end_dialog.exec():
                    year, month, reason = end_dialog.get_dissolution_data()
                    marriage.dissolution_year = year
                    marriage.dissolution_month = month
                    marriage.dissolution_reason = reason
                    
                    if marriage.id:
                        self.modified_marriages[marriage.id] = marriage
                    
                    self._on_field_changed()
                else:
                    return
        
        # Open create marriage dialog
        from dialogs.create_marriage_dialog import CreateMarriageDialog
        dialog = CreateMarriageDialog(self.db_manager, self.current_person, self)
        
        if dialog.exec():
            spouse_id, year, month = dialog.get_marriage_data()
            
            # Create new marriage with data from dialog
            new_marriage = Marriage(
                spouse1_id=self.current_person.id,
                spouse2_id=spouse_id,
                marriage_year=year,
                marriage_month=month
            )
            
            self.new_marriages.append(new_marriage)
            self._load_marriages()
            self._on_field_changed()

    def _end_marriage(self, marriage: Marriage) -> None:
        """End a marriage with dialog."""
        dialog = EndMarriageDialog(marriage, self)
        
        if dialog.exec():
            year, month, reason = dialog.get_dissolution_data()
            
            # Validate end date after marriage date
            if marriage.marriage_year:
                if year and year < marriage.marriage_year:
                    QMessageBox.warning(self, "Invalid Date", "Marriage cannot end before it started.")
                    return
                elif year == marriage.marriage_year and marriage.marriage_month and month:
                    if month < marriage.marriage_month:
                        QMessageBox.warning(self, "Invalid Date", "Marriage cannot end before it started.")
                        return
            
            marriage.dissolution_year = year
            marriage.dissolution_month = month
            marriage.dissolution_reason = reason
            
            if marriage.id:
                self.modified_marriages[marriage.id] = marriage
            
            self._load_marriages()
            self._on_field_changed()
    
    def _reactivate_marriage(self, marriage: Marriage) -> None:
        """Reactivate an ended marriage."""
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Question)
        msg.setWindowTitle("Reactivate Marriage?")
        msg.setText("Remove the end date and reactivate this marriage? This will remove any empty active marriages.")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            # Delete empty active marriages
            for m, widget in list(self.marriage_widgets):
                if m != marriage and m.is_active:
                    spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                    spouse_id = spouse_selector.get_person_id()
                    
                    if not spouse_id:
                        if m.id:
                            self.deleted_marriage_ids.append(m.id)
                        if m in self.new_marriages:
                            self.new_marriages.remove(m)
            
            marriage.dissolution_year = None
            marriage.dissolution_month = None
            marriage.dissolution_day = None
            marriage.dissolution_reason = ""
            
            if marriage.id:
                self.modified_marriages[marriage.id] = marriage
            
            self._load_marriages()
            self._on_field_changed()
    
    def _delete_marriage(self, marriage: Marriage) -> None:
        """Delete a marriage after confirmation."""
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Delete Marriage")
        msg.setText("Are you sure you want to delete this marriage?")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            if marriage.id:
                self.deleted_marriage_ids.append(marriage.id)
            if marriage in self.new_marriages:
                self.new_marriages.remove(marriage)
            
            self.marriage_widgets = [(m, w) for m, w in self.marriage_widgets if m != marriage]
            self._load_marriages()
            self._on_field_changed()
    
    def _add_child(self) -> None:
        """Open dialog to create a new child."""
        if not self.current_person or not self.current_person.id:
            return
        
        # Find oldest active marriage spouse
        active_marriages = self.marriage_repo.get_active_marriages(self.current_person.id)
        parent2_id = None
        
        if active_marriages:
            # Sort by marriage date (oldest first)
            active_marriages.sort(key=lambda m: (
                (9999, 12) if m.marriage_year is None else (m.marriage_year, m.marriage_month or 0)
            ))
            
            oldest_marriage = active_marriages[0]
            parent2_id = self.marriage_repo.get_spouse_id(oldest_marriage, self.current_person.id)
        
        # Open create child dialog
        from dialogs.create_child_dialog import CreateChildDialog
        dialog = CreateChildDialog(self.db_manager, self.current_person, parent2_id, self)
        
        if dialog.exec():
            created_person = dialog.get_created_person()
            if created_person:
                # Reload children to show new child
                self._load_children()
                self._on_field_changed()
        
    def load_person(self, person: Person) -> None:
        """Load person relationship data."""
        self.current_person = person
        
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
        
        blockers = [
            QSignalBlocker(self.father_selector),
            QSignalBlocker(self.mother_selector),
        ]
        
        if person.father_id:
            self.father_selector.set_person(person.father_id)
            self.father_jump_btn.setEnabled(True)
        else:
            self.father_selector.clear()
            self.father_jump_btn.setEnabled(False)
        
        if person.mother_id:
            self.mother_selector.set_person(person.mother_id)
            self.mother_jump_btn.setEnabled(True)
        else:
            self.mother_selector.clear()
            self.mother_jump_btn.setEnabled(False)
        
        self._load_siblings()
        self._load_marriages()
        self._load_children()
    
    def _load_siblings(self) -> None:
        """Load and display siblings."""
        while self.siblings_container.count():
            item = self.siblings_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        if not self.current_person:
            return
        
        siblings = []
        
        father_id = self.father_selector.get_person_id()
        if father_id:
            father_children = self.person_repo.get_children(father_id)
            siblings.extend([p for p in father_children if p.id != self.current_person.id])
        
        mother_id = self.mother_selector.get_person_id()
        if mother_id:
            mother_children = self.person_repo.get_children(mother_id)
            for child in mother_children:
                if child.id != self.current_person.id and child not in siblings:
                    siblings.append(child)
        
        if siblings:
            for sibling in siblings:
                sibling_widget = self._create_person_widget(sibling)
                self.siblings_container.addWidget(sibling_widget)
        else:
            placeholder = QLabel("No siblings found")
            placeholder.setStyleSheet("color: gray; font-style: italic;")
            self.siblings_container.addWidget(placeholder)
    
    def _load_marriages(self) -> None:
        """Load and display marriages."""
        while self.marriages_container.count():
            item = self.marriages_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        self.marriage_widgets.clear()
        
        if not self.current_person or not self.current_person.id:
            placeholder = QLabel("No marriages recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.marriages_container.addWidget(placeholder)
            return
        
        marriages = self.marriage_repo.get_by_person(self.current_person.id)
        marriages = [m for m in marriages if m.id not in self.deleted_marriage_ids]
        
        # Apply modifications
        for i, m in enumerate(marriages):
            if m.id and m.id in self.modified_marriages:
                marriages[i] = self.modified_marriages[m.id]
        
        all_marriages = marriages + self.new_marriages
        
        # Sort by date (oldest first)
        all_marriages.sort(key=lambda m: (
            (9999, 12) if m.marriage_year is None else (m.marriage_year, m.marriage_month or 0)
        ))
        
        if all_marriages:
            for marriage in all_marriages:
                widget = self._create_marriage_widget(marriage)
                self.marriages_container.addWidget(widget)
                self.marriage_widgets.append((marriage, widget))
        else:
            placeholder = QLabel("No marriages recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.marriages_container.addWidget(placeholder)
    
    def _load_children(self) -> None:
        """Load and display children."""
        while self.children_container.count():
            item = self.children_container.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        if not self.current_person or not self.current_person.id:
            return
        
        children = self.person_repo.get_children(self.current_person.id)
        
        if children:
            for child in children:
                child_widget = self._create_person_widget(child, show_remove=True)
                self.children_container.addWidget(child_widget)
        else:
            placeholder = QLabel("No children recorded")
            placeholder.setStyleSheet("color: gray; font-style: italic; padding: 10px;")
            self.children_container.addWidget(placeholder)

    def _remove_child(self, child: Person) -> None:
        """Remove parent-child relationship."""
        if not self.current_person:
            return
        
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Remove Child")
        msg.setText(f"Remove {child.display_name} as a child of {self.current_person.display_name}?")
        msg.setInformativeText("This will clear the parent relationship but not delete the person.")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            # Determine which parent to clear
            if child.father_id == self.current_person.id:
                child.father_id = None
            if child.mother_id == self.current_person.id:
                child.mother_id = None
            
            # Update in database
            self.person_repo.update(child)
            
            # Reload children
            self._load_children()
            self._on_field_changed()

    def get_relationship_data(self) -> dict:
        """Extract relationship data."""
        return {
            'father_id': self.father_selector.get_person_id(),
            'mother_id': self.mother_selector.get_person_id(),
        }
    
    def save_marriages(self) -> None:
        """Save all marriage changes to database."""
        # Delete marriages
        for marriage_id in self.deleted_marriage_ids:
            self.marriage_repo.delete(marriage_id)
        
        # Insert new marriages
        for marriage in self.new_marriages:
            for m, widget in self.marriage_widgets:
                if m == marriage:
                    spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                    spouse_id = spouse_selector.get_person_id()
                    if spouse_id:
                        marriage.spouse2_id = spouse_id
                    
                    date_unknown_check = widget.date_unknown_check  # type: ignore[attr-defined]
                    if date_unknown_check.isChecked():
                        marriage.marriage_year = None
                        marriage.marriage_month = None
                    else:
                        marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
                        year, month = marriage_date_picker.get_date()
                        marriage.marriage_year = year
                        marriage.marriage_month = month
                    
                    break
            
            self.marriage_repo.insert(marriage)
        
        # Update ALL existing marriages (not just ones in modified_marriages)
        for marriage, widget in self.marriage_widgets:
            # Skip new marriages (already inserted above)
            if marriage in self.new_marriages:
                continue
            
            # Update existing marriage
            if marriage.id:
                spouse_selector = widget.spouse_selector  # type: ignore[attr-defined]
                spouse_id = spouse_selector.get_person_id()
                
                if self.current_person and self.current_person.id:
                    if marriage.spouse1_id == self.current_person.id:
                        marriage.spouse2_id = spouse_id
                    else:
                        marriage.spouse1_id = spouse_id
                
                date_unknown_check = widget.date_unknown_check  # type: ignore[attr-defined]
                if date_unknown_check.isChecked():
                    marriage.marriage_year = None
                    marriage.marriage_month = None
                else:
                    marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
                    year, month = marriage_date_picker.get_date()
                    marriage.marriage_year = year
                    marriage.marriage_month = month
                
                self.marriage_repo.update(marriage)
        
        # Clear tracking
        self.new_marriages.clear()
        self.deleted_marriage_ids.clear()
        self.modified_marriages.clear()
    
    def validate(self) -> tuple[bool, str]:
        """Validate relationship data."""
        if not self.current_person:
            return (True, "")
        
        if self.father_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own father.")
        if self.mother_selector.get_person_id() == self.current_person.id:
            return (False, "A person cannot be their own mother.")
        
        for marriage, widget in self.marriage_widgets:
            marriage_date_picker = widget.marriage_date  # type: ignore[attr-defined]
            marriage_year, marriage_month = marriage_date_picker.get_date()
            
            if not marriage.is_active:
                if marriage.dissolution_year and marriage_year:
                    if marriage.dissolution_year < marriage_year:
                        return (False, "Marriage end date cannot be before start date.")
                    elif marriage.dissolution_year == marriage_year and marriage.dissolution_month and marriage_month:
                        if marriage.dissolution_month < marriage_month:
                            return (False, "Marriage end date cannot be before start date.")
        
        return (True, "")

>> âœ… dialogs\end_marriage_dialog.py (35 code lines)
"""Dialog for ending a marriage."""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QComboBox,
    QDialogButtonBox, QWidget, QMessageBox
)

from widgets.date_picker import DatePicker
from models.marriage import Marriage


class EndMarriageDialog(QDialog):
    """Dialog for ending a marriage with date and reason."""
    
    def __init__(self, marriage: Marriage, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        
        self.marriage = marriage
        self.dissolution_year: int | None = None
        self.dissolution_month: int | None = None
        self.dissolution_reason: str = ""
        
        self.setWindowTitle("End Marriage")
        self.setMinimumWidth(400)
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create dialog widgets."""
        layout = QVBoxLayout(self)
        
        form = QFormLayout()
        
        # End date
        self.end_date = DatePicker()
        
        # Set minimum date to marriage start date
        if self.marriage.marriage_year:
            self.end_date.set_min_date(self.marriage.marriage_year, self.marriage.marriage_month)
            self.end_date.set_date(self.marriage.marriage_year, self.marriage.marriage_month)
        else:
            self.end_date.set_date(1721, None)
        
        form.addRow("End Date:", self.end_date)
        
        # Reason
        self.reason_combo = QComboBox()
        self.reason_combo.addItems(["Death", "Divorce", "Annulment", "Other", "Unknown"])
        form.addRow("Reason:", self.reason_combo)
        
        layout.addLayout(form)
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._handle_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def _handle_accept(self) -> None:
        """Validate and accept."""
        year, month = self.end_date.get_date()
        
        if not year:
            QMessageBox.warning(self, "Validation Error", "End date year is required.")
            return
        
        # Validate against marriage start date
        if self.marriage.marriage_year:
            if year < self.marriage.marriage_year:
                QMessageBox.warning(
                    self,
                    "Invalid Date",
                    "Marriage cannot end before it started."
                )
                return
            elif year == self.marriage.marriage_year and self.marriage.marriage_month and month:
                if month < self.marriage.marriage_month:
                    QMessageBox.warning(
                        self,
                        "Invalid Date",
                        "Marriage cannot end before it started."
                    )
                    return
        
        self.dissolution_year = year
        self.dissolution_month = month
        self.dissolution_reason = self.reason_combo.currentText()
        
        self.accept()
    
    def get_dissolution_data(self) -> tuple[int | None, int | None, str]:
        """Returns (year, month, reason)."""
        return (self.dissolution_year, self.dissolution_month, self.dissolution_reason)

>> ðŸ“‹ dialogs\import_csv_dialog.py (1 code lines)
"""Dialog for importing genealogy data from CSV files."""

from PySide6.QtWidgets import QDialog


class ImportCSVDialog(QDialog):
    """Dialog for CSV import configuration and mapping."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the CSV import dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI
        # TODO: Add file picker for CSV selection
        # TODO: Add column mapping controls
        # TODO: Add preview table
        # TODO: Add import mode selection (replace/merge)
        # TODO: Add progress bar
        # TODO: Connect to CSVImporter utility
        pass


>> ðŸ“‹ dialogs\settings_dialog.py (1 code lines)
"""Dialog for application preferences and settings."""

from PySide6.QtWidgets import QDialog


class PreferencesDialog(QDialog):
    """Dialog for configuring application settings."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the preferences dialog."""
        super().__init__(parent)
        # TODO: Implement dialog UI with tabs
        # TODO: Add appearance settings (skin selection)
        # TODO: Add default view selection
        # TODO: Add date format preferences
        # TODO: Add auto-save settings
        # TODO: Load current settings from database
        # TODO: Save settings on OK button
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VIEWS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ views\__init__.py (2 code lines)
from .data_table_view import DataTableView

__all__ = ['DataTableView']

>> âœ… views\data_table_view.py (51 code lines)
"""Data table view for displaying all people."""

import unicodedata

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QHeaderView, QMenu, QMessageBox, QLineEdit, QLabel
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QAction

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from models.person import Person


class DataTableView(QWidget):
    """Widget displaying all people in a sortable, filterable table."""
    
    person_edited = Signal()
    
    def __init__(self, db_manager: DatabaseManager, parent=None) -> None:
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)
        self.people: list[Person] = []
        self.person_display_numbers: dict[int, int] = {}  # Maps person.id -> display number
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Create the table and controls."""
        layout = QVBoxLayout(self)
        
        toolbar = QHBoxLayout()
        
        toolbar.addWidget(QLabel("Search:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Filter by name...")
        self.search_input.textChanged.connect(self._filter_table)
        self.search_input.setMaximumWidth(300)
        toolbar.addWidget(self.search_input)
        
        toolbar.addStretch()
        
        add_btn = QPushButton("+ Add Person")
        add_btn.clicked.connect(self._add_person)
        toolbar.addWidget(add_btn)
        
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.refresh_data)
        toolbar.addWidget(refresh_btn)
        
        layout.addLayout(toolbar)
        
        self.table = QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels([
            "#", "Name", "Gender", "Birth Year", "Death Year"
        ])
        
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSortingEnabled(True)
        self.table.setAlternatingRowColors(True)
        
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        
        self.table.doubleClicked.connect(self._on_row_double_clicked)
        self.table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._show_context_menu)
        
        layout.addWidget(self.table)
    
    def refresh_data(self) -> None:
        """Load all people from database and assign persistent display numbers."""
        self.people = self.person_repo.get_all()
        
        # Sort by ID for consistent numbering
        self.people.sort(key=lambda p: p.id or 0)
        
        # Assign persistent display numbers
        self.person_display_numbers.clear()
        for index, person in enumerate(self.people, start=1):
            if person.id:
                self.person_display_numbers[person.id] = index
        
        self._populate_table(self.people)
    
    def _populate_table(self, people: list[Person]) -> None:
        """Fill table with person data."""
        self.table.setSortingEnabled(False)
        self.table.setRowCount(0)
        
        for person in people:
            row = self.table.rowCount()
            self.table.insertRow(row)
            
            # Display number (persistent, doesn't change with sorting)
            display_num = self.person_display_numbers.get(person.id or 0, 0)
            display_num_item = QTableWidgetItem(f"{display_num:06d}")
            display_num_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            display_num_item.setData(Qt.ItemDataRole.UserRole, person.id)
            # Store as integer for proper sorting
            display_num_item.setData(Qt.ItemDataRole.UserRole + 1, display_num)
            self.table.setItem(row, 0, display_num_item)
            
            # Name
            name_item = QTableWidgetItem(person.display_name)
            self.table.setItem(row, 1, name_item)
            
            # Gender
            gender_item = QTableWidgetItem(person.gender or "Unknown")
            gender_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 2, gender_item)
            
            # Birth Year
            birth_item = QTableWidgetItem(str(person.birth_year) if person.birth_year else "")
            birth_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 3, birth_item)
            
            # Death Year
            death_item = QTableWidgetItem(str(person.death_year) if person.death_year else "")
            death_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 4, death_item)
        
        self.table.setSortingEnabled(True)
    
    @staticmethod
    def _normalize_text(text: str) -> str:
        """Normalize Unicode text for accent-insensitive comparison."""
        return unicodedata.normalize('NFD', text).encode('ascii', 'ignore').decode('utf-8')
    
    def _filter_table(self) -> None:
        """Filter table based on search text (accent-insensitive)."""
        search_text = self.search_input.text().lower()
        
        if not search_text:
            self._populate_table(self.people)
            return
        
        # Normalize search text for comparison
        normalized_search = self._normalize_text(search_text)
        
        filtered = [
            p for p in self.people 
            if normalized_search in self._normalize_text(p.display_name.lower())
        ]
        self._populate_table(filtered)
    
    def _get_selected_person(self) -> Person | None:
        """Get the person from the selected row."""
        selected_rows = self.table.selectedIndexes()
        if not selected_rows:
            return None
        
        row = selected_rows[0].row()
        display_num_item = self.table.item(row, 0)
        if not display_num_item:
            return None
        
        person_id = display_num_item.data(Qt.ItemDataRole.UserRole)
        return self.person_repo.get_by_id(person_id)
    
    def _on_row_double_clicked(self) -> None:
        """Handle double-click on a row."""
        self._edit_selected_person()
    
    def _show_context_menu(self, position) -> None:
        """Show right-click context menu."""
        if not self._get_selected_person():
            return
        
        menu = QMenu(self)
        
        edit_action = QAction("Edit Person", self)
        edit_action.triggered.connect(self._edit_selected_person)
        menu.addAction(edit_action)
        
        menu.addSeparator()
        
        delete_action = QAction("Delete Person", self)
        delete_action.triggered.connect(self._delete_selected_person)
        menu.addAction(delete_action)
        
        menu.exec(self.table.viewport().mapToGlobal(position))
    
    def _add_person(self) -> None:
        """Open Add Person dialog."""
        from dialogs.add_person_dialog import AddPersonDialog
        
        dialog = AddPersonDialog(self.db_manager)
        if dialog.exec():
            self.refresh_data()
            self.person_edited.emit()
    
    def _edit_selected_person(self) -> None:
        """Open Edit Person dialog for selected row."""
        person = self._get_selected_person()
        if not person:
            QMessageBox.warning(self, "No Selection", "Please select a person to edit.")
            return
        
        from dialogs.edit_person_dialog import EditPersonDialog
        
        dialog = EditPersonDialog(self.db_manager, person)
        if dialog.exec():
            self.refresh_data()
            self.person_edited.emit()
    
    def _delete_selected_person(self) -> None:
        """Delete the selected person after confirmation."""
        person = self._get_selected_person()
        if not person:
            QMessageBox.warning(self, "No Selection", "Please select a person to delete.")
            return
        
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle("Delete Person")
        msg.setText(f"Delete {person.display_name}?")
        msg.setInformativeText("This will also delete all their marriages, events, and relationships.")
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if msg.exec() == QMessageBox.StandardButton.Yes:
            if person.id:
                self.person_repo.delete(person.id)
                self.refresh_data()  # This reassigns numbers 1,2,3... to remaining people
                self.person_edited.emit()

>> ðŸ“‹ views\dynasty_view.py (0 code lines)


>> ðŸ“‹ views\stats_view\charts.py (2 code lines)
"""Chart widgets for statistical visualizations."""

from PySide6.QtWidgets import QWidget


class Charts(QWidget):
    """Container for various statistical charts and graphs."""

    def __init__(self, database_connection) -> None:
        """Initialize the charts widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add population over time chart
        # TODO: Add birth/death rate chart
        # TODO: Add age distribution histogram
        # TODO: Add family size comparison chart
        # TODO: Use matplotlib or QtCharts for rendering
        # TODO: Add export chart buttons
        pass

    def refresh_charts(self) -> None:
        """Reload data and redraw all charts."""
        # TODO: Reload statistics from database
        # TODO: Regenerate all chart data
        # TODO: Redraw all visualizations
        pass


>> ðŸ“‹ views\stats_view\comparison_widget.py (2 code lines)
"""Widget for comparing statistics between families or people."""

from PySide6.QtWidgets import QWidget


class ComparisonWidget(QWidget):
    """Side-by-side comparison of selected entities."""

    def __init__(self, database_connection) -> None:
        """Initialize the comparison widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Add selectors for entities to compare
        # TODO: Display side-by-side statistics
        # TODO: Show comparison charts
        # TODO: Highlight differences
        # TODO: Support comparing families, people, or generations
        pass

    def set_comparison(self, entity1_id: int, entity2_id: int, entity_type: str) -> None:
        """Set which entities to compare."""
        # TODO: Load data for both entities
        # TODO: Calculate comparison metrics
        # TODO: Update display
        pass


>> ðŸ“‹ views\stats_view\family_dashboard.py (2 code lines)
"""Dashboard widget showing dynasty statistics."""

from PySide6.QtWidgets import QWidget


class FamilyDashboard(QWidget):
    """Dashboard displaying key statistics about the dynasty."""

    def __init__(self, database_connection) -> None:
        """Initialize the family dashboard widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Calculate total people count
        # TODO: Calculate total marriages count
        # TODO: Calculate average lifespan
        # TODO: Calculate generation count
        # TODO: Display statistics in grid layout
        # TODO: Add Charts widget for visualizations
        # TODO: Add refresh button
        pass

    def refresh_stats(self) -> None:
        """Recalculate and update all statistics."""
        # TODO: Reload data from database
        # TODO: Recalculate all metrics
        # TODO: Update display widgets
        pass


>> ðŸ“‹ views\table_view\event_table.py (2 code lines)
"""Table view for listing all events in the database."""

from PySide6.QtWidgets import QTableWidget


class EventTable(QTableWidget):
    """Sortable, filterable table of all events."""

    def __init__(self, database_connection) -> None:
        """Initialize the event table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Person, Event Type, Date, Description)
        # TODO: Load all events from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show event details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all events
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\family_table.py (2 code lines)
"""Table view for listing all families in the database."""

from PySide6.QtWidgets import QTableWidget


class FamilyTable(QTableWidget):
    """Sortable, filterable table of all families."""

    def __init__(self, database_connection) -> None:
        """Initialize the family table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Family Name, Member Count, Start Year, etc.)
        # TODO: Load all families from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add double-click handler to show family details
        # TODO: Add right-click menu (edit/view members)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all families
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\marriage_table.py (2 code lines)
"""Table view for listing all marriages in the database."""

from PySide6.QtWidgets import QTableWidget


class MarriageTable(QTableWidget):
    """Sortable, filterable table of all marriages."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Husband, Wife, Start Date, End Date, Type)
        # TODO: Load all marriages from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add clickable person names
        # TODO: Add double-click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all marriages
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\table_view\person_table.py (2 code lines)
"""Table view for listing all people in the database."""

from PySide6.QtWidgets import QTableWidget


class PersonTable(QTableWidget):
    """Sortable, filterable table of all people."""

    def __init__(self, database_connection) -> None:
        """Initialize the person table widget."""
        super().__init__()
        self.db = database_connection
        # TODO: Set column headers (Name, Gender, Birth, Death, etc.)
        # TODO: Load all people from database
        # TODO: Populate table rows
        # TODO: Enable sorting by column
        # TODO: Add row selection highlighting
        # TODO: Add double-click handler to show person details
        # TODO: Add right-click menu (edit/delete)
        pass

    def refresh_data(self) -> None:
        """Reload table data from database."""
        # TODO: Clear existing rows
        # TODO: Reload all people
        # TODO: Repopulate table
        pass


>> ðŸ“‹ views\timeline_view\event_marker.py (1 code lines)
"""Visual marker for person events on timeline."""

from PySide6.QtWidgets import QGraphicsWidget


class EventMarker(QGraphicsWidget):
    """Small marker showing an event on a person's timeline bar."""

    def __init__(self, event_id: int) -> None:
        """Initialize the event marker widget."""
        super().__init__()
        self.event_id = event_id
        # TODO: Load event data from database
        # TODO: Draw small icon/shape at event year
        # TODO: Use different colors for event types
        # TODO: Add tooltip showing event details
        # TODO: Add click handler for event editing
        pass


>> ðŸ“‹ views\timeline_view\family_bar.py (1 code lines)
"""Horizontal bar representing a family's timespan."""

from PySide6.QtWidgets import QGraphicsWidget


class FamilyBar(QGraphicsWidget):
    """Visual bar showing family existence over time."""

    def __init__(self, family_id: int) -> None:
        """Initialize the family bar widget."""
        super().__init__()
        self.family_id = family_id
        # TODO: Calculate family start year (earliest member birth)
        # TODO: Calculate family end year (latest member death or current)
        # TODO: Draw horizontal bar spanning timespan
        # TODO: Add family name label
        # TODO: Add click handler to show family details
        # TODO: Add PersonBar widgets for each family member
        pass


>> ðŸ“‹ views\timeline_view\major_event_marker.py (1 code lines)
"""Visual marker for major historical events."""

from PySide6.QtWidgets import QGraphicsWidget


class MajorEventMarker(QGraphicsWidget):
    """Vertical line showing major events across all families."""

    def __init__(self, major_event_id: int) -> None:
        """Initialize the major event marker widget."""
        super().__init__()
        self.major_event_id = major_event_id
        # TODO: Load major event data from database
        # TODO: Draw vertical line at event year
        # TODO: Add event name label
        # TODO: Use distinctive color/style
        # TODO: Add tooltip with event description
        # TODO: Add click handler for editing
        pass


>> ðŸ“‹ views\timeline_view\person_bar.py (1 code lines)
"""Horizontal bar representing a person's lifespan."""

from PySide6.QtWidgets import QGraphicsWidget


class PersonBar(QGraphicsWidget):
    """Visual bar showing person's life from birth to death."""

    def __init__(self, person_id: int) -> None:
        """Initialize the person bar widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load person data from database
        # TODO: Calculate x position from birth_year
        # TODO: Calculate width from birth_year to death_year (or current)
        # TODO: Draw horizontal bar with portrait thumbnail
        # TODO: Add name label
        # TODO: Add event markers along bar
        # TODO: Add click handler to show person details
        pass


>> ðŸ“‹ views\timeline_view\timeline_canvas.py (2 code lines)
"""Main canvas for the timeline visualization view."""

from PySide6.QtWidgets import QGraphicsView


class TimelineCanvas(QGraphicsView):
    """Scrollable canvas displaying families and events over time."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the timeline canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Add horizontal time axis (year scale)
        # TODO: Add vertical scrolling for families
        # TODO: Implement zoom for time scale
        # TODO: Add major event markers
        # TODO: Load all families and events from database
        pass

    def refresh_timeline(self) -> None:
        """Reload and redraw entire timeline from database."""
        # TODO: Clear scene
        # TODO: Reload all data
        # TODO: Recreate all visual elements
        pass


>> ðŸ“‹ views\timeline_view.py (0 code lines)


>> ðŸ“‹ views\tree_view\__init__.py (0 code lines)
"""Tree view components for family tree visualization."""

from .enhanced_tooltip_panel import EnhancedTooltipPanel
from .person_box import PersonBox
from .relationship_line import RelationshipLine

__all__ = [
    "EnhancedTooltipPanel",
    "PersonBox",
    "RelationshipLine",
]

>> âœ… views\tree_view\enhanced_tooltip_panel.py (376 code lines)
"""Enhanced tooltip panel for person details."""

from PySide6.QtWidgets import QGraphicsWidget
from PySide6.QtCore import Qt, QRectF, Signal, QTimer, QPoint
from PySide6.QtGui import QPainter, QColor, QPen, QBrush, QFont, QCursor
from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from models.person import Person
    from database.db_manager import DatabaseManager
    from views.tree_view.person_box import PersonBox


class EnhancedTooltipPanel(QGraphicsWidget):
    """Enhanced tooltip showing detailed person information."""
    
    closed: Signal = Signal()
    manually_moved: Signal = Signal()
    
    PANEL_WIDTH: int = 300
    PANEL_HEIGHT: int = 600
    PADDING: int = 15
    CORNER_RADIUS: int = 8
    
    LOCK_ICON_SIZE: int = 10
    LOCK_INDICATOR_SIZE: int = 20
    LOCK_START_DELAY: int = 1000
    HOVER_LOCK_DURATION: int = 3000
    
    SECTION_HEADER_SPACING: int = 20
    SECTION_BOTTOM_SPACING: int = 10
    SEPARATOR_BOTTOM_SPACING: int = 15
    LINE_SPACING: int = 16
    LINE_SPACING_SMALL: int = 14
    LINE_SPACING_TINY: int = 4
    
    INDENT_LEVEL_0: int = 0
    INDENT_LEVEL_1: int = 10
    INDENT_LEVEL_2: int = 20
    INDENT_LEVEL_3: int = 30
    
    LOCK_ICON_OFFSET_X: float = 6.5
    LOCK_ICON_OFFSET_Y: float = 4
    LOCK_INDICATOR_X_OFFSET: int = 63
    LOCK_INDICATOR_Y_OFFSET: int = 15
    LOCK_ICON_CLICKABLE_SIZE: int = 25

    
    CLOSE_BUTTON_X_OFFSET: int = 30
    CLOSE_BUTTON_Y_OFFSET: int = 10
    CLOSE_BUTTON_SIZE: int = 20
    CLOSE_BUTTON_LINE_LENGTH: int = 15
    
    HEADER_HEIGHT: int = 50
    HEADER_PARTIAL_HEIGHT: int = 25
    HEADER_TEXT_Y_OFFSET: int = 10
    HEADER_TEXT_HEIGHT: int = 30
    HEADER_RIGHT_MARGIN: int = 70
    
    INITIAL_CONTENT_Y: int = 70
    DESCENDANTS_MAX_Y_OFFSET: int = 150
    EVENTS_MAX_Y_OFFSET: int = 20
    
    GENERATION_HEADER_Y_OFFSET: int = 14
    GENERATION_HEADER_HEIGHT: int = 16
    GENERATION_GROUP_SPACING: int = 18
    
    PERSON_ENTRY_NAME_OFFSET: int = 14
    PERSON_ENTRY_DATE_OFFSET: int = 16
    PERSON_ENTRY_DATE_INDENT: int = 10
    PERSON_ENTRY_ARRIVAL_OFFSET: int = 12
    
    SIBLING_DISPLAY_COUNT: int = 3
    SIBLING_OVERFLOW_INDENT: int = 10
    
    EVENT_TYPE_INDENT: int = 10
    
    PIE_START_ANGLE: int = 90 * 16
    PIE_FULL_CIRCLE: int = 360 * 16
    
    HOVER_HIDE_DELAY: int = 100
    
    COLOR_BG: QColor = QColor(255, 255, 255)
    COLOR_BORDER: QColor = QColor(100, 100, 255)
    COLOR_HEADER_BG: QColor = QColor(240, 240, 255)
    COLOR_TEXT: QColor = QColor(33, 33, 33)
    COLOR_TEXT_LIGHT: QColor = QColor(100, 100, 100)
    COLOR_CLOSE_BUTTON: QColor = QColor(200, 0, 0)
    COLOR_CLOSE_BUTTON_IDLE: QColor = QColor(150, 150, 150)
    COLOR_SEPARATOR: QColor = QColor(220, 220, 220)
    COLOR_LOCK_FILL: QColor = QColor(100, 100, 255)
    COLOR_LOCK_INDICATOR: QColor = QColor(100, 100, 255, 100)
    COLOR_LOCK_ICON_INACTIVE: QColor = QColor(80, 80, 80)
    
    def __init__(
        self,
        person_id: int,
        db_manager: 'DatabaseManager',
        current_year: int
    ) -> None:
        super().__init__()
        
        self.person_id: int = person_id
        self.db: 'DatabaseManager' = db_manager
        self.current_year: int = current_year
        
        self.person: 'Person | None' = None
        self.events: list = []
        self.relationships: dict = {}
        
        self._load_person_data()
        self._load_events()
        self.relationships = self._load_relationships()
        
        self.setMinimumSize(self.PANEL_WIDTH, self.PANEL_HEIGHT)
        self.setMaximumSize(self.PANEL_WIDTH, self.PANEL_HEIGHT)
        
        self._close_button_hovered: bool = False
        self._is_being_dragged: bool = False
        self._drag_start_pos: QPoint | None = None
        self.is_hovered: bool = False
        self.is_locked: bool = False
        self.parent_person_box: 'PersonBox | None' = None
        
        self._collapsed_generations: dict[str, bool] = {
            'descendants': False,
            'children': True,
            'grandchildren': True,
            'great_grandchildren': True,
            'great_great_grandchildren': True
        }
        self._generation_click_rects: dict[str, QRectF] = {}
        
        self._font_icon_small: QFont = QFont("Segoe UI Emoji", self.LOCK_ICON_SIZE)
        
        self._lock_delay_timer: QTimer = QTimer()
        self._lock_delay_timer.setSingleShot(True)
        self._lock_delay_timer.timeout.connect(self._start_lock_timer)
        
        self._hover_timer: QTimer = QTimer()
        self._hover_timer.setSingleShot(True)
        self._hover_timer.timeout.connect(self._on_hover_lock)
        
        self._animation_timer: QTimer = QTimer()
        self._animation_timer.setInterval(50)
        self._animation_timer.timeout.connect(self.update)
        
        self.setAcceptHoverEvents(True)
        self.setFlags(
            QGraphicsWidget.GraphicsItemFlag.ItemIsMovable |
            QGraphicsWidget.GraphicsItemFlag.ItemIsSelectable
        )
    
    # ========================================
    # Data Loading
    # ========================================
    
    def _load_person_data(self) -> None:
        """Load person data from database."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT * FROM Person WHERE id = ?", (self.person_id,))
        row = cursor.fetchone()
        
        if not row:
            return
        
        person_dict: dict = dict(row)
        
        from models.person import Person
        
        self.person = Person(
            id=person_dict.get('id'),
            first_name=person_dict.get('first_name', ''),
            middle_name=person_dict.get('middle_name', ''),
            last_name=person_dict.get('last_name', ''),
            maiden_name=person_dict.get('maiden_name') or '',
            nickname=person_dict.get('nickname', ''),
            gender=person_dict.get('gender', 'Unknown'),
            birth_year=person_dict.get('birth_year'),
            birth_month=person_dict.get('birth_month'),
            birth_day=person_dict.get('birth_day'),
            death_year=person_dict.get('death_year'),
            death_month=person_dict.get('death_month'),
            death_day=person_dict.get('death_day'),
            arrival_year=person_dict.get('arrival_year'),
            arrival_month=person_dict.get('arrival_month'),
            arrival_day=person_dict.get('arrival_day'),
            moved_out_year=person_dict.get('moved_out_year'),
            moved_out_month=person_dict.get('moved_out_month'),
            moved_out_day=person_dict.get('moved_out_day'),
            father_id=person_dict.get('father_id'),
            mother_id=person_dict.get('mother_id'),
            family_id=person_dict.get('family_id'),
            dynasty_id=person_dict.get('dynasty_id', 1),
            is_founder=bool(person_dict.get('is_founder', 0)),
            education=person_dict.get('education', 0),
            notes=person_dict.get('notes', '')
        )
    
    def _load_events(self) -> None:
        """Load events for this person."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        cursor.execute("""
            SELECT * FROM Event 
            WHERE person_id = ?
            ORDER BY start_year, start_month, start_day
        """, (self.person_id,))
        
        self.events = cursor.fetchall()
    
    def _load_relationships(self) -> dict:
        """Load family relationships including full and half siblings."""
        if not self.db or not self.db.conn or not self.person:
            return {}
        
        cursor = self.db.conn.cursor()

        siblings: dict[str, list[str]] = {
            'brothers': [], 
            'sisters': [], 
            'other': [],
            'half_brothers': [],
            'half_sisters': [],
            'half_other': []
        }
        
        has_parents: bool = self.person.father_id is not None or self.person.mother_id is not None
        
        if has_parents:
            cursor.execute("""
                SELECT id, first_name, last_name, gender, father_id, mother_id
                FROM Person 
                WHERE (father_id = ? OR mother_id = ?)
                AND id != ?
            """, (self.person.father_id, self.person.mother_id, self.person_id))
            
            for row in cursor.fetchall():
                sibling: dict = dict(row)
                sibling_name: str = f"{sibling['first_name']} {sibling['last_name']}"
                
                shares_father: bool = sibling['father_id'] == self.person.father_id and self.person.father_id is not None
                shares_mother: bool = sibling['mother_id'] == self.person.mother_id and self.person.mother_id is not None
                is_full_sibling: bool = shares_father and shares_mother
                
                sibling_gender: str = sibling['gender']
                category_suffix: str = '' if is_full_sibling else 'half_'
                
                if sibling_gender == 'Male':
                    siblings[f'{category_suffix}brothers'].append(sibling_name)
                elif sibling_gender == 'Female':
                    siblings[f'{category_suffix}sisters'].append(sibling_name)
                else:
                    siblings[f'{category_suffix}other'].append(sibling_name)

        descendants: dict = self._load_all_descendants()
        
        return {
            'siblings': siblings,
            'descendants': descendants
        }

    def _load_all_descendants(self) -> dict[str, list[dict] | dict]:
        """Load all descendants with full details for collapsible list."""
        if not self.db or not self.db.conn:
            return {'all': [], 'by_generation': {}}
        
        cursor = self.db.conn.cursor()
        
        cursor.execute("""
            SELECT id, first_name, last_name, birth_year, death_year, gender, arrival_year, moved_out_year
            FROM Person 
            WHERE father_id = ? OR mother_id = ?
            ORDER BY birth_year
        """, (self.person_id, self.person_id))
        
        children: list[dict] = [dict(row) for row in cursor.fetchall()]
        all_descendants: list[dict] = []
        descendants_by_generation: dict[str, list[dict]] = {'children': children}
        
        for child in children:
            all_descendants.append(self._create_descendant_dict(child, 'child'))
        
        current_generation_ids: list[int] = [c['id'] for c in children]
        generation_names: list[str] = ['grandchildren', 'great_grandchildren', 'great_great_grandchildren']
        
        for generation_name in generation_names:
            if not current_generation_ids:
                break
            
            next_generation: list[dict] = self._fetch_generation(cursor, current_generation_ids)
            
            if next_generation:
                descendants_by_generation[generation_name] = next_generation
                
                for person in next_generation:
                    generation_label: str = generation_name.replace('_', ' ')
                    all_descendants.append(self._create_descendant_dict(person, generation_label))
                
                current_generation_ids = [p['id'] for p in next_generation]
            else:
                break
        
        return {
            'all': all_descendants,
            'by_generation': descendants_by_generation
        }

    def _fetch_generation(self, cursor, parent_ids: list[int]) -> list[dict]:
        """Fetch a generation of descendants given parent IDs."""
        placeholders: str = ','.join('?' * len(parent_ids))
        cursor.execute(f"""
            SELECT id, first_name, last_name, birth_year, death_year, gender, arrival_year, moved_out_year
            FROM Person 
            WHERE father_id IN ({placeholders}) OR mother_id IN ({placeholders})
            ORDER BY birth_year
        """, parent_ids + parent_ids)
        
        return [dict(row) for row in cursor.fetchall()]

    def _create_descendant_dict(self, person: dict, generation: str) -> dict:
        """Create standardized descendant dictionary."""
        return {
            'id': person['id'],
            'first_name': person['first_name'],
            'last_name': person['last_name'],
            'name': f"{person['first_name']} {person['last_name']}",
            'generation': generation,
            'gender': person.get('gender', 'Unknown'),
            'birth_year': person['birth_year'],
            'death_year': person['death_year'],
            'arrival_year': person.get('arrival_year'),
            'moved_out_year': person.get('moved_out_year')
        }
    
    # ========================================
    # Helper Methods
    # ========================================
    
    def _get_close_button_rect(self) -> QRectF:
        """Get close button clickable area."""
        close_x: float = self.PANEL_WIDTH - self.CLOSE_BUTTON_X_OFFSET
        close_y: float = self.CLOSE_BUTTON_Y_OFFSET
        return QRectF(close_x, close_y, self.CLOSE_BUTTON_SIZE, self.CLOSE_BUTTON_SIZE)
    
    def _get_lock_icon_rect(self) -> QRectF:
        """Get clickable area for lock icon."""
        indicator_x: float = self.PANEL_WIDTH - self.LOCK_INDICATOR_X_OFFSET
        indicator_y: float = self.LOCK_ICON_OFFSET_Y
        return QRectF(indicator_x - 5, indicator_y, self.LOCK_ICON_CLICKABLE_SIZE, 20)
    
    def _get_generation_header_rect(self, y: float, generation_key: str) -> QRectF:
        """Get clickable rectangle for generation header."""
        if generation_key == 'descendants':
            rect: QRectF = QRectF(
                self.PADDING + self.INDENT_LEVEL_1, 
                y - self.GENERATION_HEADER_Y_OFFSET, 
                self.PANEL_WIDTH - self.PADDING - self.INDENT_LEVEL_2, 
                self.GENERATION_HEADER_HEIGHT
        )
        else:
            rect: QRectF = QRectF(
                self.PADDING + self.INDENT_LEVEL_1, 
                y - self.GENERATION_HEADER_Y_OFFSET, 
                self.PANEL_WIDTH - self.PADDING - self.INDENT_LEVEL_2, 
                self.GENERATION_HEADER_HEIGHT
        )
        self._generation_click_rects[generation_key] = rect
        return rect
    
    def _get_generation_display_name(self, generation_key: str) -> str:
        """Get display name for generation with proper formatting."""
        generation_names: dict[str, str] = {
            'children': 'Children',
            'grandchildren': 'Grandchildren',
            'great_grandchildren': 'Great Grandchildren',
            'great_great_grandchildren': 'GÂ² Grandchildren'
        }
        
        if generation_key.startswith('great_'):
            great_count: int = generation_key.count('great_')
            if great_count > 2:
                return f"G^{great_count} Grandchildren"
        
        return generation_names.get(generation_key, generation_key.replace('_', ' ').title())
    
    def _get_gender_symbol(self, gender: str) -> str:
        """Get gender symbol for display."""
        return {"Male": "â™‚", "Female": "â™€"}.get(gender, "âš²")
    
    def _toggle_generation(self, generation_key: str) -> None:
        """Toggle collapse state for a generation and repaint."""
        current_state: bool = self._collapsed_generations.get(generation_key, True)
        self._collapsed_generations[generation_key] = not current_state
        self.update()
    
    def _start_lock_timer(self) -> None:
        """Start the hover lock timer."""
        if not self.is_locked:
            self._hover_timer.start(self.HOVER_LOCK_DURATION)
            self._animation_timer.start()
    
    def _on_hover_lock(self) -> None:
        """Called when lock timer completes."""
        self.is_locked = True
        self._animation_timer.stop()
        self.update()
    
    def _check_self_hide(self) -> None:
        """Hide tooltip if mouse isn't back in it and not locked."""
        mouse_not_in_tooltip: bool = not self.is_hovered
        tooltip_not_locked: bool = not self.is_locked
        
        should_hide: bool = mouse_not_in_tooltip and tooltip_not_locked
        
        if should_hide and self.scene():
            self.scene().removeItem(self)
            self.closed.emit()
    
    def _format_single_date(self, year: int | None, month: int | None, day: int | None) -> str:
        """Format a single date with month abbreviation."""
        if year is None:
            return "?"
        
        month_names: dict[int, str] = {
            1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr',
            5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug',
            9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'
        }
        
        if day and month:
            month_abbr: str = month_names.get(month, '')
            return f"{day} {month_abbr} {year}"
        elif month:
            month_abbr: str = month_names.get(month, '')
            return f"{month_abbr} {year}"
        else:
            return str(year)

    def _format_years(self, birth_year: int | None, death_year: int | None) -> str:
        """Format birth and death years for display."""
        birth_text: str = f"b. {birth_year}" if birth_year else "b. ?"
        
        if death_year:
            return f"({birth_text} - d. {death_year})"
        
        return f"({birth_text})"
    
    def _format_person_dates(self, person: dict) -> str:
        """Format all important dates for a person."""
        dates_parts: list[str] = []
        
        arrival_year: int | None = person.get('arrival_year')
        arrival_month: int | None = person.get('arrival_month')
        moved_out_year: int | None = person.get('moved_out_year')
        moved_out_month: int | None = person.get('moved_out_month')
        birth_year: int | None = person.get('birth_year')
        birth_month: int | None = person.get('birth_month')
        death_year: int | None = person.get('death_year')
        death_month: int | None = person.get('death_month')
        
        arrival_text: str = f"Arrival {arrival_month} {arrival_year}"
        if arrival_year and moved_out_year:
            dates_parts.append(f"{arrival_text} - Departure {moved_out_month} {moved_out_year}")
        elif arrival_year:
            dates_parts.append(f"{arrival_text}")

        birth_text: str = f"b. {birth_month} {birth_year}" if birth_month and birth_year else "b. ?"
        if death_year:
            dates_parts.append(f"{birth_text} - d. {death_month} {death_year}")
        else:
            dates_parts.append(birth_text)
        
        return " | ".join(dates_parts) if dates_parts else ""
    
    def _draw_section_header(self, painter: QPainter, y: float, section_font: QFont, text: str) -> float:
        """Draw a section header and return updated y position."""
        painter.setFont(section_font)
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING, int(y), text)
        return y + self.SECTION_HEADER_SPACING
    
    def _draw_separator_line(self, painter: QPainter, y: float) -> float:
        """Draw horizontal separator line and return updated y position."""
        painter.setPen(QPen(self.COLOR_SEPARATOR, 1))
        painter.drawLine(self.PADDING, int(y), self.PANEL_WIDTH - self.PADDING, int(y))
        return y + self.SEPARATOR_BOTTOM_SPACING
    
    # ========================================
    # Painting
    # ========================================
    
    def paint(self, painter: QPainter, option, widget=None) -> None:
        """Draw the tooltip panel."""
        if not self.person:
            return
        
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        painter.setPen(QPen(self.COLOR_BORDER, 2))
        painter.setBrush(QBrush(self.COLOR_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.PANEL_WIDTH, self.PANEL_HEIGHT),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )
        
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(self.COLOR_HEADER_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.PANEL_WIDTH, self.HEADER_HEIGHT),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )
        painter.drawRect(QRectF(0, self.HEADER_PARTIAL_HEIGHT, self.PANEL_WIDTH, self.HEADER_PARTIAL_HEIGHT))
        
        self._draw_lock_indicator(painter)
        self._draw_close_button(painter)
        self._draw_header(painter)
        self._draw_content(painter)
    
    def _draw_lock_indicator(self, painter: QPainter) -> None:
        """Draw lock indicator with countdown animation and clickable icon."""
        indicator_x: float = self.PANEL_WIDTH - self.LOCK_INDICATOR_X_OFFSET
        indicator_y: float = self.LOCK_INDICATOR_Y_OFFSET
        center_x: float = indicator_x + self.LOCK_INDICATOR_SIZE / 2
        center_y: float = indicator_y + self.LOCK_INDICATOR_SIZE / 2
        
        is_timer_active: bool = self._hover_timer.isActive()
        
        if is_timer_active:
            elapsed: int = self._hover_timer.interval() - self._hover_timer.remainingTime()
            fill_percent: float = min(1.0, elapsed / self.HOVER_LOCK_DURATION)
            
            painter.setPen(QPen(self.COLOR_LOCK_INDICATOR, 2))
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawEllipse(
                int(indicator_x), 
                int(indicator_y), 
                self.LOCK_INDICATOR_SIZE, 
                self.LOCK_INDICATOR_SIZE
            )
            
            if fill_percent > 0:
                painter.setBrush(QBrush(self.COLOR_LOCK_FILL))
                span_angle: int = int(-self.PIE_FULL_CIRCLE * fill_percent)
                painter.drawPie(
                    int(indicator_x), 
                    int(indicator_y), 
                    self.LOCK_INDICATOR_SIZE, 
                    self.LOCK_INDICATOR_SIZE,
                    self.PIE_START_ANGLE,
                    span_angle
                )
        
        painter.setFont(self._font_icon_small)
        
        if self.is_locked:
            painter.setPen(QPen(self.COLOR_LOCK_FILL))
            painter.drawText(
                int(center_x - self.LOCK_ICON_OFFSET_X), 
                int(center_y + self.LOCK_ICON_OFFSET_Y), 
                "ðŸ”’"
            )
        else:
            painter.setPen(QPen(self.COLOR_LOCK_ICON_INACTIVE))
            painter.drawText(
                int(center_x - self.LOCK_ICON_OFFSET_X), 
                int(center_y + self.LOCK_ICON_OFFSET_Y), 
                "ðŸ”“"
            )
    
    def _draw_close_button(self, painter: QPainter) -> None:
        """Draw close button."""
        close_x: float = self.PANEL_WIDTH - self.CLOSE_BUTTON_X_OFFSET
        close_y: float = self.CLOSE_BUTTON_Y_OFFSET
        button_color: QColor = self.COLOR_CLOSE_BUTTON if self._close_button_hovered else self.COLOR_CLOSE_BUTTON_IDLE
        
        painter.setPen(QPen(button_color, 2))
        painter.drawLine(
            int(close_x), 
            int(close_y), 
            int(close_x + self.CLOSE_BUTTON_LINE_LENGTH), 
            int(close_y + self.CLOSE_BUTTON_LINE_LENGTH)
        )
        painter.drawLine(
            int(close_x + self.CLOSE_BUTTON_LINE_LENGTH), 
            int(close_y), 
            int(close_x), 
            int(close_y + self.CLOSE_BUTTON_LINE_LENGTH)
        )
    
    def _draw_header(self, painter: QPainter) -> None:
        """Draw header with person name."""
        if not self.person:
            return
        
        painter.setPen(QPen(self.COLOR_TEXT))
        title_font: QFont = QFont("Segoe UI", 12, QFont.Weight.Bold)
        painter.setFont(title_font)
        painter.drawText(
            QRectF(
                self.PADDING, 
                self.HEADER_TEXT_Y_OFFSET, 
                self.PANEL_WIDTH - self.HEADER_RIGHT_MARGIN, 
                self.HEADER_TEXT_HEIGHT
            ), 
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, 
            self.person.full_name
        )
    
    def _draw_content(self, painter: QPainter) -> None:
        """Draw all content sections."""
        y: float = self.INITIAL_CONTENT_Y
        normal_font: QFont = QFont("Segoe UI", 9)
        section_font: QFont = QFont("Segoe UI", 10, QFont.Weight.Bold)
        
        section_methods: list[Callable] = [
            self._draw_statistics,
            self._draw_relationships,
            self._draw_descendants,
            self._draw_events
        ]
        
        for section_method in section_methods:
            y = section_method(painter, y, section_font, normal_font)
    
    def _draw_statistics(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw statistics section."""
        if not self.person:
            return y
        
        y = self._draw_section_header(painter, y, section_font, "Statistics")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        stats: list[str] = [
            f"Birth: {self._format_single_date(self.person.birth_year, self.person.birth_month, self.person.birth_day)}",
            f"Death: {self._format_single_date(self.person.death_year, self.person.death_month, self.person.death_day)}" if self.person.is_deceased else "Status: Living",
            f"Age: {self.person.get_age(self.current_year) or 'Unknown'}",
        ]
        
        for stat in stats:
            painter.drawText(self.PADDING, int(y), stat)
            y += self.LINE_SPACING
        
        return y + self.SECTION_BOTTOM_SPACING
    
    def _draw_relationships(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw relationships section."""
        y = self._draw_section_header(painter, y, section_font, "Relationships")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        siblings: dict[str, list[str]] = self.relationships.get('siblings', {})
        
        sibling_types: list[tuple[str, str]] = [
            ('brothers', 'Brothers'),
            ('half_brothers', 'Half-Brothers'),
            ('sisters', 'Sisters'),
            ('half_sisters', 'Half-Sisters'),
            ('other', 'Other Siblings'),
            ('half_other', 'Half-Siblings (Other)')
        ]
        
        for key, label in sibling_types:
            sibling_list: list[str] = siblings.get(key, [])
            if sibling_list:
                y = self._draw_sibling_group(painter, y, label, sibling_list)
        
        y += self.SECTION_BOTTOM_SPACING
        y = self._draw_separator_line(painter, y)
        return y

    def _draw_sibling_group(self, painter: QPainter, y: float, label: str, sibling_list: list[str]) -> float:
        """Draw a group of siblings with overflow handling."""
        displayed_names: str = ', '.join(sibling_list[:self.SIBLING_DISPLAY_COUNT])
        painter.drawText(self.PADDING, int(y), f"{label}: {displayed_names}")
        y += self.LINE_SPACING
        
        overflow_count: int = len(sibling_list) - self.SIBLING_DISPLAY_COUNT
        if overflow_count > 0:
            painter.drawText(
                self.PADDING + self.SIBLING_OVERFLOW_INDENT, 
                int(y), 
                f"...and {overflow_count} more"
            )
            y += self.LINE_SPACING
        
        return y
    
    def _draw_descendants(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw descendants section with collapsible generations."""
        descendants: dict = self.relationships.get('descendants', {})
        descendants_by_generation: dict = descendants.get('by_generation', {})
        all_descendants: list[dict] = descendants.get('all', [])
        
        if not all_descendants:
            return y
        
        is_collapsed: bool = self._collapsed_generations.get('descendants', False)
        arrow: str = "â–¶" if is_collapsed else "â–¼"
        
        painter.setFont(section_font)
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING, int(y), f"Descendants ({len(all_descendants)}) {arrow}")
        self._get_generation_header_rect(y, 'descendants')
        
        y += self.SECTION_HEADER_SPACING
        
        if is_collapsed:
            y += self.SECTION_BOTTOM_SPACING
            y = self._draw_separator_line(painter, y)
            return y

        descendants_section_max_y: float = self.PANEL_HEIGHT - self.DESCENDANTS_MAX_Y_OFFSET
        
        generation_order: list[str] = sorted(
            descendants_by_generation.keys(),
            key=lambda x: (x.count('great_'), x)
        )
        
        for generation_key in generation_order:
            generation_list: list[dict] = descendants_by_generation[generation_key]
            if not generation_list:
                continue
            
            if y > descendants_section_max_y:
                break
            
            y = self._draw_generation_group(painter, y, generation_key, generation_list, normal_font, descendants_section_max_y)
        
        y += self.SECTION_BOTTOM_SPACING
        y = self._draw_separator_line(painter, y)
        return y

    def _draw_generation_group(
        self, 
        painter: QPainter, 
        y: float, 
        generation_key: str, 
        generation_list: list[dict],
        normal_font: QFont,
        max_y: float
    ) -> float:
        """Draw a collapsible generation group."""
        is_collapsed: bool = self._collapsed_generations.get(generation_key, True)
        arrow: str = "â–¶" if is_collapsed else "â–¼"
        
        generation_name: str = self._get_generation_display_name(generation_key)
        
        self._get_generation_header_rect(y, generation_key)
        
        painter.setFont(QFont("Segoe UI", 9, QFont.Weight.Bold))
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(
            self.PADDING + self.INDENT_LEVEL_1, 
            int(y), 
            f"{arrow} {generation_name} ({len(generation_list)})"
        )
        y += self.GENERATION_GROUP_SPACING
        
        if is_collapsed:
            return y
        
        painter.setFont(normal_font)
        
        for person in generation_list:
            if y > max_y:
                remaining: int = len(generation_list) - generation_list.index(person)
                painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
                painter.drawText(self.PADDING + self.INDENT_LEVEL_2, int(y), f"...and {remaining} more")
                break
            
            y = self._draw_person_entry(painter, y, person)
        
        return y

    def _draw_person_entry(self, painter: QPainter, y: float, person: dict) -> float:
        """Draw a single person entry with name, gender, and dates on separate lines."""
        person_name: str = f"{person['first_name']} {person['last_name']}"
        gender_symbol: str = self._get_gender_symbol(person.get('gender', 'Unknown'))
        
        painter.setPen(QPen(self.COLOR_TEXT))
        painter.drawText(self.PADDING + self.INDENT_LEVEL_2, int(y), f"{person_name} {gender_symbol}")
        y += self.PERSON_ENTRY_NAME_OFFSET
        
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        painter.setFont(QFont("Segoe UI", 8))
        
        has_arrival: bool = person.get('arrival_year') is not None
        
        if has_arrival:
            arrival_text: str = self._format_single_date(
                person.get('arrival_year'),
                person.get('arrival_month'),
                person.get('arrival_day')
            )
            
            has_departure: bool = person.get('moved_out_year') is not None
            
            if has_departure:
                departure_text: str = self._format_single_date(
                    person.get('moved_out_year'),
                    person.get('moved_out_month'),
                    person.get('moved_out_day')
                )
                painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"Arr: {arrival_text} - Dep: {departure_text}")
            else:
                painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"Arrival: {arrival_text}")
            
            y += self.PERSON_ENTRY_ARRIVAL_OFFSET
        
        birth_text: str = self._format_single_date(
            person.get('birth_year'),
            person.get('birth_month'),
            person.get('birth_day')
        )
        
        has_death: bool = person.get('death_year') is not None
        
        if has_death:
            death_text: str = self._format_single_date(
                person.get('death_year'),
                person.get('death_month'),
                person.get('death_day')
            )
            painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"b. {birth_text} - d. {death_text}")
        else:
            painter.drawText(self.PADDING + self.INDENT_LEVEL_3, int(y), f"b. {birth_text}")
        
        painter.setFont(QFont("Segoe UI", 9))
        y += self.PERSON_ENTRY_DATE_OFFSET
        
        return y
    
    def _draw_events(self, painter: QPainter, y: float, section_font: QFont, normal_font: QFont) -> float:
        """Draw events timeline section."""
        y = self._draw_section_header(painter, y, section_font, f"Life Events ({len(self.events)})")
        
        painter.setFont(normal_font)
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        
        max_y: float = self.PANEL_HEIGHT - self.PADDING
        event_count: int = 0
        
        for event in self.events:
            if y > max_y - self.EVENTS_MAX_Y_OFFSET:
                remaining_events: int = len(self.events) - event_count
                painter.drawText(self.PADDING, int(y), f"...and {remaining_events} more")
                break
            
            event_dict: dict = dict(event)
            event_year: str = str(event_dict.get('start_year', '?'))
            event_title: str = event_dict.get('event_title', 'Unknown')
            event_type: str = event_dict.get('event_type', '')
            
            painter.drawText(self.PADDING, int(y), f"{event_year}: {event_title}")
            y += self.LINE_SPACING_SMALL
            
            if event_type:
                painter.drawText(self.PADDING + self.EVENT_TYPE_INDENT, int(y), f"({event_type})")
                y += self.LINE_SPACING_SMALL
            
            event_count += 1
            y += self.LINE_SPACING_TINY
        
        return y
    
    # ========================================
    # Qt Event Handlers
    # ========================================
    
    def boundingRect(self) -> QRectF:
        """Define widget bounds for Qt rendering system."""
        return QRectF(0, 0, self.PANEL_WIDTH, self.PANEL_HEIGHT)

    def hoverEnterEvent(self, event) -> None:
        """Track when mouse enters tooltip and start lock delay timer."""
        self.is_hovered = True
        self._lock_delay_timer.start(self.LOCK_START_DELAY)
        super().hoverEnterEvent(event)

    def hoverMoveEvent(self, event) -> None:
        """Track close button, lock icon, and generation header hover states."""
        mouse_position = event.pos()
        
        close_rect: QRectF = self._get_close_button_rect()
        self._close_button_hovered = close_rect.contains(mouse_position)
        
        lock_rect: QRectF = self._get_lock_icon_rect()
        lock_icon_hovered: bool = lock_rect.contains(mouse_position)
        
        hovering_header: bool = False
        for rect in self._generation_click_rects.values():
            if rect.contains(mouse_position):
                hovering_header = True
                break
        
        is_hovering_interactive_element: bool = self._close_button_hovered or hovering_header or lock_icon_hovered
        
        if is_hovering_interactive_element:
            self.setCursor(Qt.CursorShape.PointingHandCursor)
        else:
            self.setCursor(Qt.CursorShape.ArrowCursor)
        
        self.update()
        super().hoverMoveEvent(event)

    def hoverLeaveEvent(self, event) -> None:
        """Track when mouse leaves tooltip and potentially hide."""
        self.is_hovered = False
        self._lock_delay_timer.stop()
        self._hover_timer.stop()
        self._animation_timer.stop()
        
        if not self.is_locked:
            QTimer.singleShot(self.HOVER_HIDE_DELAY, self._check_self_hide)
        
        super().hoverLeaveEvent(event)

    def mousePressEvent(self, event) -> None:
        """Handle clicks on close button, lock icon, generation headers, or start drag."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if not is_left_click:
            super().mousePressEvent(event)
            return
        
        click_position = event.pos()
        
        close_rect: QRectF = self._get_close_button_rect()
        clicked_close_button: bool = close_rect.contains(click_position)
        
        if clicked_close_button:
            self.closed.emit()
            if self.scene():
                self.scene().removeItem(self)
            return
        
        lock_rect: QRectF = self._get_lock_icon_rect()
        clicked_lock_icon: bool = lock_rect.contains(click_position)
        
        if clicked_lock_icon:
            self.is_locked = not self.is_locked
            if self.is_locked:
                self._lock_delay_timer.stop()
                self._hover_timer.stop()
                self._animation_timer.stop()
            self.update()
            return
        
        for generation_key, rect in self._generation_click_rects.items():
            if rect.contains(click_position):
                self._toggle_generation(generation_key)
                return
        
        self._is_being_dragged = True
        self._drag_start_pos = click_position
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:
        """Handle dragging."""
        if self._is_being_dragged:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event) -> None:
        """Handle drag end and mark as manually moved."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if is_left_click and self._is_being_dragged:
            self.manually_moved.emit()
            self._is_being_dragged = False
        
        super().mouseReleaseEvent(event)

>> ðŸ“‹ views\tree_view\generation_band.py (2 code lines)
"""Horizontal band showing a generation level in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class GenerationBand(QGraphicsWidget):
    """Background band for highlighting a generation level."""

    def __init__(self, generation: int, y_position: float, height: float) -> None:
        """Initialize the generation band widget."""
        super().__init__()
        self.generation = generation
        self.y_position = y_position
        self.height = height
        # TODO: Draw horizontal background rectangle
        # TODO: Use alternating colors for visual separation
        # TODO: Add generation label on left side
        # TODO: Update position when tree layout changes
        pass

    def update_position(self, new_y: float, new_height: float) -> None:
        """Adjust band position and height."""
        # TODO: Update y_position and height
        # TODO: Redraw band
        pass


>> ðŸ“‹ views\tree_view\layout_engine.py (2 code lines)
"""Automatic layout engine for positioning people in the tree."""


class TreeLayoutEngine:
    """Calculate automatic positions for people in the family tree."""

    def __init__(self, database_connection) -> None:
        """Initialize the layout engine."""
        self.db = database_connection

    def calculate_positions(self) -> dict[int, tuple[float, float]]:
        """Calculate x,y positions for all people."""
        # TODO: Implement generational hierarchy algorithm
        # TODO: Group siblings together
        # TODO: Consider cohort positioning (move-in dates)
        # TODO: Return dict: person_id -> (x, y)
        pass


>> ðŸ“‹ views\tree_view\marriage_node.py (1 code lines)
"""Visual representation of a marriage in the tree view."""

from PySide6.QtWidgets import QGraphicsWidget


class MarriageNode(QGraphicsWidget):
    """Node connecting spouses in the family tree."""

    def __init__(self, marriage_id: int) -> None:
        """Initialize the marriage node widget."""
        super().__init__()
        self.marriage_id = marriage_id
        # TODO: Draw small connector shape (circle/diamond)
        # TODO: Display marriage date on hover
        # TODO: Connect to both spouse PersonBox widgets
        # TODO: Add click handler to show marriage details
        # TODO: Add right-click menu (edit/end/delete marriage)
        pass


>> âœ… views\tree_view\person_box.py (333 code lines)
"""Person box widget for the tree view."""

from PySide6.QtWidgets import QGraphicsWidget
from PySide6.QtCore import Qt, QRectF, QPointF, QTimer, Signal
from PySide6.QtGui import QPainter, QColor, QPen, QBrush, QFont, QPixmap, QPainterPath, QFontMetrics
from datetime import datetime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from models.person import Person
    from database.db_manager import DatabaseManager
    from views.tree_view.enhanced_tooltip_panel import EnhancedTooltipPanel


class PersonBox(QGraphicsWidget):
    """Visual representation of a person in the family tree."""
    
    person_double_clicked: Signal = Signal(int)
    person_selected: Signal = Signal(int)
    favorite_toggled: Signal = Signal(int, bool)
    
    BOX_MIN_WIDTH: int = 300
    BOX_MAX_WIDTH: int = 300
    BOX_HEIGHT: int = 130
    PHOTO_SIZE: int = 110
    BORDER_WIDTH: int = 3
    CORNER_RADIUS: int = 8
    TEXT_PADDING: int = 10
    
    TOOLTIP_WIDTH: int = 300
    TOOLTIP_HEIGHT: int = 600
    TOOLTIP_OFFSET_X: int = 10
    TOOLTIP_DELAY: int = 1000
    
    FAVORITE_STAR_SIZE: int = 20
    
    COLOR_LIVING: QColor = QColor(76, 175, 80)
    COLOR_DECEASED: QColor = QColor(158, 158, 158)
    COLOR_BG: QColor = QColor(255, 255, 255)
    COLOR_TEXT: QColor = QColor(33, 33, 33)
    COLOR_TEXT_LIGHT: QColor = QColor(120, 120, 120)
    COLOR_SEPARATOR: QColor = QColor(200, 200, 200)
    COLOR_FAVORITE_STAR: QColor = QColor(255, 215, 0)
    COLOR_FAVORITE_HOVER: QColor = QColor(200, 200, 200)
    
    def __init__(
        self, 
        person_id: int, 
        db_manager: 'DatabaseManager',
        current_year: int | None = None
    ) -> None:
        super().__init__()
        
        self.person_id: int = person_id
        self.db: 'DatabaseManager' = db_manager
        self.current_year: int = current_year if current_year is not None else datetime.now().year
        
        self.person: 'Person | None' = None
        self.portrait_pixmap: QPixmap | None = None
        self.is_favorite: bool = False
        
        self._font_name_bold: QFont = QFont("Segoe UI", 11, QFont.Weight.Bold)
        self._font_normal: QFont = QFont("Segoe UI", 9)
        self._font_icon: QFont = QFont("Segoe UI Emoji", 12)

        self._load_person_data()
        self._load_portrait()
        self._load_favorite_status()
        
        self.box_width: float = self._calculate_box_width()
        _, name_line2 = self._get_display_name_lines()
        self.box_height: float = self.BOX_HEIGHT + (18 if name_line2 else 0)
        
        self.setFlags(
            QGraphicsWidget.GraphicsItemFlag.ItemIsMovable |
            QGraphicsWidget.GraphicsItemFlag.ItemIsSelectable |
            QGraphicsWidget.GraphicsItemFlag.ItemSendsGeometryChanges
        )
        self.setAcceptHoverEvents(True)
        self.setMinimumSize(self.box_width, self.box_height)
        self.setMaximumSize(self.box_width, self.box_height)
        
        self._is_dragging: bool = False
        self._drag_start_pos: QPointF | None = None
        
        self._tooltip_delay_timer: QTimer = QTimer()
        self._tooltip_delay_timer.setSingleShot(True)
        self._tooltip_delay_timer.timeout.connect(self._show_enhanced_tooltip)
        
        self._is_hovered: bool = False
        self._is_name_hovered: bool = False
        self._is_star_hovered: bool = False
        self._tooltip_manually_positioned: bool = False
        self._tooltip_panel: 'EnhancedTooltipPanel | None' = None
    
    def _query_one(self, sql: str, params: tuple = ()) -> dict | None:
        """Execute query and return first row as dict."""
        if not self.db or not self.db.conn:
            return None
        cursor = self.db.conn.cursor()
        cursor.execute(sql, params)
        row = cursor.fetchone()
        return dict(row) if row else None
    
    def _load_person_data(self) -> None:
        """Load person data from database."""
        row: dict | None = self._query_one("SELECT * FROM Person WHERE id = ?", (self.person_id,))
        if not row:
            return
        
        from models.person import Person
        
        self.person = Person(
            id=row.get('id'),
            first_name=row.get('first_name', ''),
            middle_name=row.get('middle_name', ''),
            last_name=row.get('last_name', ''),
            maiden_name=row.get('maiden_name') or '',
            nickname=row.get('nickname', ''),
            gender=row.get('gender', 'Unknown'),
            birth_year=row.get('birth_year'),
            birth_month=row.get('birth_month'),
            birth_day=row.get('birth_day'),
            death_year=row.get('death_year'),
            death_month=row.get('death_month'),
            death_day=row.get('death_day'),
            arrival_year=row.get('arrival_year'),
            arrival_month=row.get('arrival_month'),
            arrival_day=row.get('arrival_day'),
            moved_out_year=row.get('moved_out_year'),
            moved_out_month=row.get('moved_out_month'),
            moved_out_day=row.get('moved_out_day'),
            father_id=row.get('father_id'),
            mother_id=row.get('mother_id'),
            family_id=row.get('family_id'),
            dynasty_id=row.get('dynasty_id', 1),
            is_founder=bool(row.get('is_founder', 0)),
            education=row.get('education', 0),
            notes=row.get('notes', '')
        )
    
    def _load_portrait(self) -> None:
        """Load portrait image from database if exists."""
        row: dict | None = self._query_one(
            "SELECT image_path FROM Portrait WHERE person_id = ? AND is_primary = 1 ORDER BY display_order LIMIT 1",
            (self.person_id,)
        )
        
        if row and row['image_path']:
            pixmap: QPixmap = QPixmap(row['image_path'])
            if not pixmap.isNull():
                self.portrait_pixmap = pixmap.scaled(
                    self.PHOTO_SIZE, 
                    self.PHOTO_SIZE, 
                    Qt.AspectRatioMode.KeepAspectRatio, 
                    Qt.TransformationMode.SmoothTransformation
                )
    
    def _load_favorite_status(self) -> None:
        """Load favorite status from database."""
        row: dict | None = self._query_one("SELECT is_favorite FROM Person WHERE id = ?", (self.person_id,))
        if row:
            self.is_favorite = bool(row['is_favorite'])
    
    # ========================================
    # Helper Methods
    # ========================================
    
    def _calculate_box_width(self) -> float:
        """Return fixed box width."""
        return self.BOX_MIN_WIDTH

    def _get_display_name_lines(self) -> tuple[str, str | None]:
        """Get name text, split across two lines if exceeds 32 characters."""
        if not self.person:
            return ("", None)
        
        full_name: str = f"{self.person.first_name} {self.person.last_name}"
        
        if len(full_name) <= 32:
            return (full_name, None)
        
        metrics: QFontMetrics = QFontMetrics(self._font_name_bold)
        gear_space: int = 30
        available_width: float = self.BOX_MIN_WIDTH - (self.PHOTO_SIZE + 15 + self.TEXT_PADDING) - gear_space
        
        first_name: str = self.person.first_name
        last_name: str = self.person.last_name
        
        if metrics.horizontalAdvance(first_name) <= available_width:
            return (first_name, last_name)
        
        for i in range(len(first_name), 0, -1):
            truncated: str = first_name[:i] + "..."
            if metrics.horizontalAdvance(truncated) <= available_width:
                return (truncated, last_name)
        
        return (first_name[:10] + "...", last_name)
    
    def _get_birth_display_text(self) -> str:
        """Get birth date display text with month if available."""
        if not self.person:
            return "?"
        return self.person.get_birth_date_string()
    
    def _get_death_display_text(self) -> str:
        """Get death date display text with month if available."""
        if not self.person:
            return ""
        
        if not self.person.is_deceased:
            return ""
        
        return self.person.get_death_date_string()

    def _is_sick(self) -> bool:
        """Check if person has any active illness events."""
        if not self.db or not self.db.conn:
            return False
        
        cursor = self.db.conn.cursor()
        cursor.execute(
            "SELECT COUNT(*) as count FROM Event WHERE person_id = ? AND event_type = 'Illness' AND (end_year IS NULL OR end_year >= ?)",
            (self.person_id, self.current_year)
        )
        row = cursor.fetchone()
        return row['count'] > 0 if row else False
    
    def _is_immigrant(self) -> bool:
        """Check if person immigrated."""
        if not self.person:
            return False
        has_arrival_date: bool = self.person.arrival_year is not None
        is_not_founder: bool = not self.person.is_founder
        return has_arrival_date and is_not_founder
    
    def _get_gender_symbol(self) -> str:
        """Get the gender symbol for display."""
        if not self.person:
            return "âš²"
        return {"Male": "â™‚", "Female": "â™€"}.get(self.person.gender, "âš²")
    
    def _get_age_text(self) -> str:
        """Generate age text like 'd. 64 (now 108)' or 'Age: 45'."""
        if not self.person or not self.person.birth_year:
            return ""
        
        is_deceased: bool = self.person.is_deceased
        has_death_year: bool = self.person.death_year is not None
        
        if is_deceased and has_death_year:
            age_at_death: int | None = self.person.get_age_at_death()
            if age_at_death is None:
                return "d. ?"
            would_be_age: int = self.current_year - self.person.birth_year
            return f"d. {age_at_death} (now {would_be_age})"
        
        current_age: int | None = self.person.get_age(self.current_year)
        return f"Age: {current_age}" if current_age else ""
    
    def _get_star_rect(self) -> QRectF:
        """Get clickable area for favorite star."""
        star_x: float = self.box_width - 55
        star_y: float = 10
        return QRectF(star_x, star_y, self.FAVORITE_STAR_SIZE, self.FAVORITE_STAR_SIZE)
    
    def _get_name_rect(self) -> QRectF:
        """Get hoverable area for tooltip trigger."""
        return QRectF(0, 0, self.box_width, self.box_height)
    
    def _is_mouse_near_tooltip(self, mouse_pos: QPointF) -> bool:
        """Check if mouse is in grace area between box and tooltip."""
        if not self._tooltip_panel:
            return False
        
        grace_width: int = 30
        grace_rect: QRectF = QRectF(
            self.box_width - grace_width,
            0,
            self.TOOLTIP_OFFSET_X + grace_width * 2,
            self.box_height
        )
        return grace_rect.contains(mouse_pos)
    
    def _stop_tooltip_timer(self) -> None:
        """Stop tooltip delay timer."""
        self._tooltip_delay_timer.stop()

    def _format_date_for_box(self, year: int | None, month: int | None) -> str:
        """Format date for PersonBox display with full month name."""
        if year is None:
            return "?"
        
        month_names: dict[int, str] = {
            1: 'January', 2: 'February', 3: 'March', 4: 'April',
            5: 'May', 6: 'June', 7: 'July', 8: 'August',
            9: 'September', 10: 'October', 11: 'November', 12: 'December'
        }
        
        if month:
            month_name: str = month_names.get(month, '')
            return f"{month_name} {year}"
        else:
            return str(year)
    
    # ========================================
    # Painting
    # ========================================
    
    def paint(self, painter: QPainter, option, widget=None) -> None:
        """Draw the person box with all visual elements."""
        if not self.person:
            return
        
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        border_color: QColor = self.COLOR_DECEASED if self.person.is_deceased else self.COLOR_LIVING
        painter.setPen(QPen(border_color, self.BORDER_WIDTH))
        painter.setBrush(QBrush(self.COLOR_BG))
        painter.drawRoundedRect(
            QRectF(0, 0, self.box_width, self.box_height), 
            self.CORNER_RADIUS, 
            self.CORNER_RADIUS
        )
        
        photo_rect: QRectF = QRectF(
            self.BORDER_WIDTH, 
            self.BORDER_WIDTH, 
            self.PHOTO_SIZE + 10, 
            self.box_height - 2 * self.BORDER_WIDTH
        )
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(QColor(245, 245, 245)))
        
        path: QPainterPath = QPainterPath()
        path.addRoundedRect(photo_rect, self.CORNER_RADIUS, self.CORNER_RADIUS)
        painter.setClipPath(path)
        painter.drawRect(photo_rect)
        painter.setClipping(False)
        
        if self.portrait_pixmap:
            x_offset: float = (self.PHOTO_SIZE + 10 - self.portrait_pixmap.width()) / 2 + self.BORDER_WIDTH
            y_offset: float = (self.box_height - self.portrait_pixmap.height()) / 2
            painter.drawPixmap(int(x_offset), int(y_offset), self.portrait_pixmap)
        else:
            self._draw_placeholder_portrait(painter, photo_rect)
        
        separator_x: float = self.PHOTO_SIZE + 15
        painter.setPen(QPen(self.COLOR_SEPARATOR, 1))
        painter.drawLine(
            int(separator_x), 
            int(self.BORDER_WIDTH + 5), 
            int(separator_x), 
            int(self.box_height - self.BORDER_WIDTH - 5)
        )
        
        self._draw_text_content(painter, separator_x + self.TEXT_PADDING)
        
        should_draw_star: bool = self._is_hovered or self.is_favorite
        if should_draw_star:
            self._draw_favorite_star(painter)
    
    def _draw_placeholder_portrait(self, painter: QPainter, photo_rect: QRectF) -> None:
        """Draw silhouette placeholder when no portrait exists."""
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(QColor(200, 200, 200)))
        
        center_x: float = photo_rect.center().x()
        center_y: float = photo_rect.top() + 30
        painter.drawEllipse(QPointF(center_x, center_y), 15, 15)
        
        body_width: float = 30
        body_height: float = 35
        body_x: float = center_x - body_width / 2
        body_y: float = center_y + 18
        painter.drawRoundedRect(QRectF(body_x, body_y, body_width, body_height), 5, 5)
        
        painter.setFont(QFont("Segoe UI", 7))
        painter.setPen(QPen(self.COLOR_TEXT_LIGHT))
        text_rect: QRectF = QRectF(photo_rect.left() + 5, photo_rect.top() + 85, photo_rect.width() - 10, 25)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, "Click to add\nportrait")
    
    def _draw_text_content(self, painter: QPainter, start_x: float) -> None:
        """Draw all text content on right side of box."""
        if not self.person:
            return
        
        icon_y: float = 25
        icon_x: float = start_x
        
        painter.setFont(self._font_icon)
        painter.setPen(QPen(self.COLOR_TEXT))
        
        icon_conditions: list[tuple[bool, str]] = [
            (self.person.is_founder, "ðŸƒ"),
            (self._is_immigrant(), "â†“"),
            (self.person.is_deceased, "ðŸ’€"),
            (self._is_sick(), "ðŸ¤’")
        ]
        
        for condition, icon in icon_conditions:
            if condition:
                painter.drawText(int(icon_x), int(icon_y), icon)
                icon_x += 20
        
        painter.drawText(int(self.box_width - 30), int(icon_y), "âš™")
        
        name_line1, name_line2 = self._get_display_name_lines()
        name_y: float = 50
        
        painter.setFont(self._font_name_bold)
        painter.drawText(int(start_x), int(name_y), name_line1)
        
        if name_line2:
            name_y += 18
            painter.drawText(int(start_x), int(name_y), name_line2)
        
        painter.setFont(self._font_normal)
        painter.setPen(QPen(QColor(100, 100, 100)))
        
        gender_y: float = name_y + 18
        gender_text: str = f"{self._get_gender_symbol()} {self.person.gender}"
        painter.drawText(int(start_x), int(gender_y), gender_text)
        
        current_y: float = gender_y + 16
        painter.setFont(QFont("Segoe UI", 9))
        painter.setPen(QPen(self.COLOR_TEXT))
        
        has_arrival: bool = self.person.arrival_year is not None
        
        if has_arrival:
            arrival_text: str = self._format_date_for_box(
                self.person.arrival_year,
                self.person.arrival_month
            )
            
            has_departure: bool = self.person.moved_out_year is not None
            
            if has_departure:
                departure_text: str = self._format_date_for_box(
                    self.person.moved_out_year,
                    self.person.moved_out_month
                )
                painter.drawText(int(start_x), int(current_y), f"A: {arrival_text} | D: {departure_text}")
            else:
                painter.drawText(int(start_x), int(current_y), f"A: {arrival_text}")
            
            current_y += 14

        birth_text: str = self._format_date_for_box(
            self.person.birth_year,
            self.person.birth_month
        )

        if self.person.is_deceased:
            death_text: str = self._format_date_for_box(
                self.person.death_year,
                self.person.death_month
            )
            life_dates: str = f"b. {birth_text} - d. {death_text}"
        else:
            life_dates: str = f"b. {birth_text} -"

        painter.drawText(int(start_x), int(current_y), life_dates)
        current_y += 14

        painter.setPen(QPen(QColor(100, 100, 100)))

        if self.person.is_deceased:
            age_at_death: int | None = self.person.get_age_at_death()
            if age_at_death is not None:
                painter.drawText(int(start_x), int(current_y), f"Died at {age_at_death} years old")
                current_y += 14
            
            if self.person.birth_year:
                years_since_birth: int = self.current_year - self.person.birth_year
                painter.drawText(int(start_x), int(current_y), f"Age: {years_since_birth}")
        else:
            current_age: int | None = self.person.get_age(self.current_year)
            if current_age is not None:
                painter.drawText(int(start_x), int(current_y), f"Age: {current_age}")
            
    def _draw_favorite_star(self, painter: QPainter) -> None:
        """Draw favorite star (filled if favorite, hollow if hovering)."""
        painter.setFont(QFont("Segoe UI Emoji", 16))
        
        star_x: float = self.box_width - 55
        star_y: float = 10
        
        if self.is_favorite:
            painter.setPen(QPen(self.COLOR_FAVORITE_STAR))
            painter.drawText(int(star_x), int(star_y + 15), "â˜…")
        elif self._is_star_hovered or self._is_hovered:
            painter.setPen(QPen(self.COLOR_FAVORITE_HOVER))
            painter.drawText(int(star_x), int(star_y + 15), "â˜†")
    
    # ========================================
    # Tooltip Management
    # ========================================
    
    def _show_enhanced_tooltip(self) -> None:
        """Show enhanced tooltip panel next to person box."""
        tooltip_already_exists: bool = self._tooltip_panel is not None
        no_scene_available: bool = not self.scene()
        
        if tooltip_already_exists or no_scene_available:
            return
        
        from views.tree_view.enhanced_tooltip_panel import EnhancedTooltipPanel
        
        self._tooltip_panel = EnhancedTooltipPanel(self.person_id, self.db, self.current_year)
        
        if not self._tooltip_panel:
            return
        
        self._tooltip_panel.parent_person_box = self
        self._tooltip_panel.manually_moved.connect(self._on_tooltip_manually_moved)
        self._tooltip_panel.closed.connect(self._on_tooltip_closed)
        
        tooltip_x: float = self.pos().x() + self.box_width + self.TOOLTIP_OFFSET_X
        tooltip_y: float = self.pos().y()
        self._tooltip_panel.setPos(tooltip_x, tooltip_y)
        
        self.scene().addItem(self._tooltip_panel)

    def _on_tooltip_manually_moved(self) -> None:
        """Handle tooltip being manually repositioned by user."""
        self._tooltip_manually_positioned = True
    
    def _on_tooltip_closed(self) -> None:
        """Handle tooltip being closed."""
        self._tooltip_panel = None
    
    def _hide_enhanced_tooltip(self) -> None:
        """Remove enhanced tooltip from scene."""
        if self._tooltip_panel and self.scene():
            self.scene().removeItem(self._tooltip_panel)
            self._tooltip_panel = None

    def _check_hide_tooltip(self) -> None:
        """Check if tooltip should be hidden after leaving person box."""
        if not self._tooltip_panel:
            return
        
        tooltip_is_hovered: bool = self._tooltip_panel.is_hovered
        tooltip_is_locked: bool = self._tooltip_panel.is_locked
        
        should_keep_tooltip: bool = tooltip_is_hovered or tooltip_is_locked
        
        if not should_keep_tooltip:
            self._hide_enhanced_tooltip()
    
    # ========================================
    # Qt Event Handlers
    # ========================================
    
    def boundingRect(self) -> QRectF:
        """Define widget bounds for Qt rendering system."""
        return QRectF(0, 0, self.box_width, self.box_height)
    
    def hoverEnterEvent(self, event) -> None:
        """Start tooltip delay timer when mouse enters box."""
        self._is_hovered = True
        self._tooltip_delay_timer.start(self.TOOLTIP_DELAY)
        self.update()
        super().hoverEnterEvent(event)
    
    def hoverMoveEvent(self, event) -> None:
        """Track hover state for name and star areas."""
        mouse_position: QPointF = event.pos()
        
        self._is_name_hovered = self._get_name_rect().contains(mouse_position)
        self._is_star_hovered = self._get_star_rect().contains(mouse_position)
        
        mouse_left_box: bool = not self._is_name_hovered
        tooltip_exists: bool = self._tooltip_panel is not None
        tooltip_unlocked: bool = not (self._tooltip_panel.is_locked if self._tooltip_panel else False)
        mouse_not_near_tooltip: bool = not self._is_mouse_near_tooltip(mouse_position)
        
        should_hide_tooltip: bool = (
            mouse_left_box and 
            tooltip_exists and 
            tooltip_unlocked and 
            mouse_not_near_tooltip
        )
        
        if should_hide_tooltip:
            self._hide_enhanced_tooltip()
        
        self.update()
        super().hoverMoveEvent(event)
    
    def hoverLeaveEvent(self, event) -> None:
        """Stop timers and potentially hide tooltip when mouse leaves."""
        self._is_hovered = False
        self._is_name_hovered = False
        self._is_star_hovered = False
        self._stop_tooltip_timer()
        
        tooltip_exists: bool = self._tooltip_panel is not None
        tooltip_is_unlocked: bool = not (self._tooltip_panel.is_locked if self._tooltip_panel else True)
        
        if tooltip_exists and tooltip_is_unlocked:
            QTimer.singleShot(200, self._check_hide_tooltip)
        
        self.update()
        super().hoverLeaveEvent(event)
    
    def mousePressEvent(self, event) -> None:
        """Handle clicks on star (favorite toggle) or box (drag start)."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        
        if not is_left_click:
            super().mousePressEvent(event)
            return
        
        click_position: QPointF = event.pos()
        clicked_on_star: bool = self._get_star_rect().contains(click_position)
        
        if clicked_on_star:
            self.is_favorite = not self.is_favorite
            self.favorite_toggled.emit(self.person_id, self.is_favorite)
            self._save_favorite_status()
            self.update()
            return
        
        self._is_dragging = True
        self._drag_start_pos = click_position
        self.person_selected.emit(self.person_id)
        self._stop_tooltip_timer()
        
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:
        """Handle dragging - move box and tooltip together if not manually positioned."""
        if not self._is_dragging:
            super().mouseMoveEvent(event)
            return
        
        self._stop_tooltip_timer()
        
        tooltip_exists: bool = self._tooltip_panel is not None

        if tooltip_exists and self._tooltip_panel:
            expected_x: float = self.pos().x() + self.box_width + self.TOOLTIP_OFFSET_X
            expected_y: float = self.pos().y()
            
            actual_x: float = self._tooltip_panel.pos().x()
            actual_y: float = self._tooltip_panel.pos().y()
            
            position_tolerance: int = 10
            x_difference: float = abs(actual_x - expected_x)
            y_difference: float = abs(actual_y - expected_y)
            
            is_in_default_position: bool = x_difference <= position_tolerance and y_difference <= position_tolerance
            should_move_tooltip: bool = is_in_default_position or not self._tooltip_manually_positioned
            
            if should_move_tooltip:
                self._tooltip_panel.setPos(expected_x, expected_y)
        
        super().mouseMoveEvent(event)
        
    def mouseReleaseEvent(self, event) -> None:
        """End drag operation."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        if is_left_click:
            self._is_dragging = False
        super().mouseReleaseEvent(event)
    
    def mouseDoubleClickEvent(self, event) -> None:
        """Emit signal on double-click."""
        is_left_click: bool = event.button() == Qt.MouseButton.LeftButton
        if is_left_click:
            self.person_double_clicked.emit(self.person_id)
        super().mouseDoubleClickEvent(event)
    
    def _save_favorite_status(self) -> None:
        """Persist favorite status to database."""
        if not self.db or not self.db.conn:
            return
        
        cursor = self.db.conn.cursor()
        favorite_value: int = 1 if self.is_favorite else 0
        cursor.execute(
            "UPDATE Person SET is_favorite = ? WHERE id = ?",
            (favorite_value, self.person_id)
        )
        self.db.conn.commit()

>> ðŸ“‹ views\tree_view\relationship_line.py (7 code lines)
"""Visual line connecting related people in the tree."""

from PySide6.QtWidgets import QGraphicsWidget


class RelationshipLine(QGraphicsWidget):
    """Line connecting parent to child or spouse to spouse."""

    def __init__(
        self,
        start_person_id: int,
        end_person_id: int,
        line_type: str,  # "parent", "marriage", "sibling"
    ) -> None:
        """Initialize the relationship line widget."""
        super().__init__()
        self.start_person_id = start_person_id
        self.end_person_id = end_person_id
        self.line_type = line_type
        # TODO: Draw line between two PersonBox widgets
        # TODO: Use different styles for different line types
        # TODO: Update position when PersonBox moves
        # TODO: Add hover highlighting
        pass

    def update_endpoints(self) -> None:
        """Recalculate line position based on connected boxes."""
        # TODO: Get current positions of connected PersonBox widgets
        # TODO: Redraw line with new coordinates
        pass


>> ðŸ“‹ views\tree_view\tree_canvas.py (1 code lines)
"""Main canvas for displaying the family tree."""

from PySide6.QtWidgets import QGraphicsView


class TreeCanvas(QGraphicsView):
    """Scrollable, zoomable canvas for displaying the family tree."""

    def __init__(self, parent: 'MainWindow') -> None:  # type: ignore
        """Initialize the tree canvas."""
        super().__init__(parent)
        # TODO: Create QGraphicsScene
        # TODO: Implement zoom functionality
        # TODO: Implement pan functionality
        # TODO: Add minimap (optional)
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WIDGETS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ widgets\__init__.py (0 code lines)


>> âœ… widgets\date_picker.py (72 code lines)
"""Custom date picker widget supporting flexible precision."""

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, 
    QSpinBox, QLabel, QCheckBox
)
from PySide6.QtCore import Signal


class MonthSpinBox(QSpinBox):
    """Custom spinbox that displays month names instead of just numbers."""
    
    yearAdjustNeeded = Signal(int)
    
    MONTH_NAMES = [
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ]
    
    def __init__(self, parent=None):
        """Initialize month spinbox."""
        super().__init__(parent)
        self.setWrapping(True)
    
    def textFromValue(self, value: int) -> str:
        """Convert internal value (1-12) to display text."""
        if 1 <= value <= 12:
            return f"{self.MONTH_NAMES[value - 1]} ({value})"
        return str(value)
    
    def valueFromText(self, text: str) -> int:
        """Convert display text back to internal value (1-12)."""
        if "(" in text and ")" in text:
            try:
                return int(text.split("(")[1].split(")")[0])
            except (ValueError, IndexError):
                pass
        
        text_lower = text.lower().strip()
        for i, month in enumerate(self.MONTH_NAMES, start=1):
            if month.lower().startswith(text_lower):
                return i
        
        try:
            return int(text)
        except ValueError:
            return 1
    
    def stepBy(self, steps: int) -> None:
        """Override step behavior to handle year adjustment on wrap."""
        old_value = self.value()
        super().stepBy(steps)
        new_value = self.value()
        
        if steps > 0 and old_value == 12 and new_value == 1:
            self.yearAdjustNeeded.emit(1)
        elif steps < 0 and old_value == 1 and new_value == 12:
            self.yearAdjustNeeded.emit(-1)


class DatePicker(QWidget):
    """Widget for entering dates with flexible precision (Year + Month)."""
    
    dateChanged = Signal()
    
    def __init__(self, parent: QWidget | None = None) -> None:
        """Initialize the date picker widget."""
        super().__init__(parent)
        
        self.min_year: int | None = None
        self.min_month: int | None = None
        
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # Year Section
        year_layout = QVBoxLayout()
        year_label = QLabel("Year", self)
        self.year_spin = QSpinBox(self)
        self.year_spin.setRange(1500, 2000)
        self.year_spin.setValue(1721)
        self.year_spin.valueChanged.connect(self._on_date_changed)
        
        year_layout.addWidget(year_label)
        year_layout.addWidget(self.year_spin)
        
        # Month Section
        month_layout = QVBoxLayout()
        month_label = QLabel("Month", self)
        
        month_controls = QHBoxLayout()
        self.month_spin = MonthSpinBox(self)
        self.month_spin.setRange(1, 12)
        self.month_spin.setValue(1)
        self.month_spin.valueChanged.connect(self._on_date_changed)
        self.month_spin.yearAdjustNeeded.connect(self._on_year_adjust)
        
        self.unknown_check = QCheckBox("Unknown", self)
        self.unknown_check.setChecked(False)
        self.unknown_check.stateChanged.connect(self._on_unknown_toggled)
        
        month_controls.addWidget(self.month_spin)
        month_controls.addWidget(self.unknown_check)
        
        month_layout.addWidget(month_label)
        month_layout.addLayout(month_controls)
        
        main_layout.addLayout(year_layout)
        main_layout.addLayout(month_layout)
        main_layout.addStretch()
        
        self._update_month_state()
    
    def set_min_date(self, min_year: int, min_month: int | None = None) -> None:
        """Set minimum allowable date."""
        self.min_year = min_year
        self.min_month = min_month if min_month else 1
        
        if self.min_year:
            self.year_spin.setMinimum(self.min_year)
    
    def _on_year_adjust(self, direction: int) -> None:
        """Adjust year when month wraps around."""
        current_year = self.year_spin.value()
        new_year = current_year + direction
        
        if self.year_spin.minimum() <= new_year <= self.year_spin.maximum():
            self.year_spin.setValue(new_year)
    
    def _on_unknown_toggled(self) -> None:
        """Handle unknown checkbox state change."""
        self._update_month_state()
        self._on_date_changed()
    
    def _update_month_state(self) -> None:
        """Enable or disable month spinbox based on unknown checkbox."""
        is_unknown = self.unknown_check.isChecked()
        self.month_spin.setEnabled(not is_unknown)
    
    def _on_date_changed(self) -> None:
        """Internal handler when date changes - emits signal."""
        self.dateChanged.emit()
    
    def get_date(self) -> tuple[int, int | None]:
        """Get the selected date as (year, month) tuple."""
        year = self.year_spin.value()
        
        if self.unknown_check.isChecked():
            return (year, None)
        else:
            return (year, self.month_spin.value())
    
    def set_date(self, year: int, month: int | str | None = None) -> None:
        """Set the date to specific values."""
        self.year_spin.setValue(year)
        
        if month is None or month == "":
            self.unknown_check.setChecked(True)
        else:
            self.unknown_check.setChecked(False)
            
            if isinstance(month, str):
                month_num = self._month_name_to_number(month)
                if month_num is not None:
                    self.month_spin.setValue(month_num)
                else:
                    self.unknown_check.setChecked(True)
            else:
                self.month_spin.setValue(int(month))
        
        self._update_month_state()

    def _month_name_to_number(self, month_name: str) -> int | None:
        """Convert month name to number (1-12)."""
        month_map = {
            'january': 1, 'february': 2, 'march': 3, 'april': 4,
            'may': 5, 'june': 6, 'july': 7, 'august': 8,
            'september': 9, 'october': 10, 'november': 11, 'december': 12
        }
        return month_map.get(month_name.lower())
    
    def clear(self) -> None:
        """Reset to default values (1721, Unknown)."""
        self.set_date(1721, None)

>> ðŸ“‹ widgets\extended_details_panel.py (2 code lines)
"""Panel widget for displaying detailed person information."""

from PySide6.QtWidgets import QWidget


class ExtendedDetailsPanel(QWidget):
    """Panel showing comprehensive person details and relationships."""

    def __init__(self, person_id: int | None = None) -> None:
        """Initialize the extended details panel."""
        super().__init__()
        self.person_id = person_id
        # TODO: Display full person information
        # TODO: Show all marriages with dates
        # TODO: Show all children with clickable links
        # TODO: Show all events in chronological order
        # TODO: Show portrait gallery
        # TODO: Add edit button for each section
        # TODO: Add relationship path calculator
        pass

    def set_person(self, person_id: int) -> None:
        """Update panel to show different person."""
        # TODO: Clear current display
        # TODO: Load new person data
        # TODO: Refresh all sections
        pass


>> âœ… widgets\person_selector.py (39 code lines)
"""Widget for selecting a person from the database with autocomplete."""

import unicodedata
from PySide6.QtWidgets import QWidget, QLineEdit, QVBoxLayout, QCompleter
from PySide6.QtCore import Signal, Qt, QStringListModel

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository


class PersonSelector(QWidget):
    """Autocomplete text field for selecting a person from the database."""
    
    # Signal emitted when a person is selected (emits person_id)
    personSelected = Signal(int)
    # Signal emitted when selection is cleared
    selectionCleared = Signal()
    
    def __init__(self, db_manager: DatabaseManager, parent: QWidget | None = None) -> None:
        """Initialize the person selector widget."""
        super().__init__(parent)
        
        self.db_manager = db_manager
        self.person_repo = PersonRepository(db_manager)

        self.gender_filter: str | None = None

        self._name_to_id: dict[str, int] = {}

        self._selected_person_id: int | None = None
        
        self._setup_ui()
        self._load_people()
    
    def _setup_ui(self) -> None:
        """Create the autocomplete text field."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Create text field
        self.text_field = QLineEdit(self)
        self.text_field.setPlaceholderText("Type to search for a person...")
        self.text_field.setClearButtonEnabled(True)
        
        # Create completer
        self.completer = QCompleter(self)
        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
        self.completer.setMaxVisibleItems(10)
        
        # Attach completer to text field
        self.text_field.setCompleter(self.completer)
        
        # Connect signals
        self.completer.activated.connect(self._on_person_selected)
        self.text_field.textChanged.connect(self._on_text_changed)
        
        layout.addWidget(self.text_field)
    
    def _load_people(self) -> None:
        """Load all people from database and populate completer."""
        if not self.db_manager.is_open:
            return

        all_people = self.person_repo.get_all()

        if hasattr(self, 'gender_filter') and self.gender_filter:
            all_people = [p for p in all_people if p.gender in (self.gender_filter, "Unknown")]

        self._name_to_id.clear()

        display_names = []
        
        for person in all_people:
            if person.id is None:
                continue
            
            display_name = self._format_person_display(person)
            display_names.append(display_name)
            self._name_to_id[display_name] = person.id

        display_names.sort()

        from PySide6.QtCore import QStringListModel
        model = QStringListModel(display_names)
        self.completer.setModel(model)
    
    def _format_person_display(self, person) -> str:
        """Format a person's info for display in the dropdown."""
        name = person.display_name

        if person.death_year:
            date_str = f"{person.birth_year or '?'}-{person.death_year}"
        elif person.birth_year:
            date_str = f"b. {person.birth_year}"
        else:
            date_str = "dates unknown"
        
        return f"{name} ({date_str})"
    
    def _normalize_text(self, text: str) -> str:
        """Normalize text for searching (handle special characters)."""
        text = text.lower()
        
        # Unicode normalization: Ã¡ â†’ a, Ã½ â†’ y, etc.
        normalized = unicodedata.normalize('NFD', text)
        ascii_text = ''.join(
            char for char in normalized 
            if unicodedata.category(char) != 'Mn'
        )
        
        return ascii_text
    
    def _on_person_selected(self, display_name: str) -> None:
        """Handle person selection from dropdown."""
        person_id = self._name_to_id.get(display_name)
        
        if person_id is not None:
            self._selected_person_id = person_id
            self.personSelected.emit(person_id)
    
    def _on_text_changed(self, text: str) -> None:
        """Handle text field changes."""
        if not text.strip():
            self._selected_person_id = None
            self.selectionCleared.emit()
    
    def get_person_id(self) -> int | None:
        """Get the currently selected person's ID."""
        return self._selected_person_id
    
    def set_person(self, person_id: int | None) -> None:
        """Set the selected person by ID."""
        if person_id is None:
            self.clear()
            return

        for display_name, pid in self._name_to_id.items():
            if pid == person_id:
                self.text_field.setText(display_name)
                self._selected_person_id = person_id
                return

        self.clear()
    
    def clear(self) -> None:
        """Clear the selection."""
        self.text_field.clear()
        self._selected_person_id = None
        self.selectionCleared.emit()
    
    def refresh(self) -> None:
        """Reload people from database (call after adding/editing people)."""
        current_id = self._selected_person_id
        self._load_people()

        if current_id is not None:
            self.set_person(current_id)
    
    def set_filter(self, gender: str | None = None) -> None:
        """Filter the displayed people by gender."""
        self.gender_filter = gender
        self._load_people()

>> ðŸ“‹ widgets\portrait_gallery.py (1 code lines)
"""Widget for displaying and managing person portraits."""

from PySide6.QtWidgets import QWidget


class PortraitGallery(QWidget):
    """Gallery widget for viewing and selecting portraits."""

    def __init__(self, person_id: int) -> None:
        """Initialize the portrait gallery widget."""
        super().__init__()
        self.person_id = person_id
        # TODO: Load portraits from Portrait table
        # TODO: Display portraits in grid layout
        # TODO: Add portrait selection highlighting
        # TODO: Add upload new portrait button
        # TODO: Add delete portrait button
        # TODO: Emit signal on portrait selection
        pass


>> ðŸ“‹ widgets\search_bar.py (2 code lines)
"""Search bar widget for finding people by name."""

from PySide6.QtWidgets import QWidget


class SearchBar(QWidget):
    """Search widget with autocomplete for finding people."""

    def __init__(self) -> None:
        """Initialize the search bar widget."""
        super().__init__()
        # TODO: Add QLineEdit for search input
        # TODO: Implement autocomplete using QCompleter
        # TODO: Load all person names from database
        # TODO: Add search icon/button
        # TODO: Add clear button
        # TODO: Emit signal when person is selected
        # TODO: Support fuzzy matching (optional)
        pass

    def update_completions(self) -> None:
        """Refresh autocomplete list from database."""
        # TODO: Reload all person names
        # TODO: Update QCompleter model
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UTILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> ðŸ“‹ utils\__init__.py (0 code lines)
"""Utility modules for calculations and helpers."""


>> ðŸ“‹ utils\color_manager.py (5 code lines)
"""Color utilities for UI elements."""

from PySide6.QtGui import QColor


class ColorManager:
    """Manage colors for various UI elements."""

    def __init__(self) -> None:
        """Initialize the color manager."""
        # TODO: Define color palettes
        # TODO: Define gender-specific colors
        # TODO: Define generation band colors
        # TODO: Define event type colors
        pass

    def get_person_color(self, gender: str | None) -> QColor: # type: ignore 
        """Get color for person based on gender."""
        # TODO: Return blue for male
        # TODO: Return pink for female
        # TODO: Return gray for unknown
        pass

    def get_generation_color(self, generation: int) -> QColor: # type: ignore 
        """Get alternating color for generation bands."""
        # TODO: Return alternating colors based on generation number
        pass

    def get_event_color(self, event_type: str) -> QColor: # type: ignore 
        """Get color for event type."""
        # TODO: Return different colors for different event types
        # TODO: Birth, death, marriage, arrival, etc.
        pass

    def interpolate_color(self, color1: QColor, color2: QColor, ratio: float) -> QColor: # type: ignore 
        """Blend two colors together."""
        # TODO: Calculate intermediate color
        # TODO: Return blended QColor
        pass


>> ðŸ“‹ utils\csv_importer.py (4 code lines)
"""CSV import utility for bulk data loading."""

import csv


class CSVImporter:
    """Import genealogy data from CSV files."""

    def __init__(self, database_connection) -> None:
        """Initialize the CSV importer."""
        self.db = database_connection

    def import_people(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import people from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert people into database
        # TODO: Return count of imported people
        pass

    def import_marriages(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import marriages from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data (check person IDs exist)
        # TODO: Insert marriages into database
        # TODO: Return count of imported marriages
        pass

    def import_events(self, csv_path: str, column_mapping: dict[str, str]) -> int:
        """Import events from CSV file."""
        # TODO: Open and read CSV file
        # TODO: Map CSV columns to database fields
        # TODO: Validate data
        # TODO: Insert events into database
        # TODO: Return count of imported events
        pass


>> ðŸ“‹ utils\generation_calculator.py (2 code lines)
"""Calculate generation levels for all people."""


class GenerationCalculator:
    """Compute generation levels for genealogical hierarchy."""

    def __init__(self, database_connection) -> None:
        """Initialize the generation calculator."""
        self.db = database_connection

    def recompute_all_generations(self) -> None:
        """Recalculate generation levels for all people."""
        # TODO: Find all founders (no parents)
        # TODO: Run BFS from founders
        # TODO: Assign generation numbers
        # TODO: Handle edge cases (adoptions, step-relations)
        pass


>> ðŸ“‹ utils\relationship_calculator.py (3 code lines)
"""Calculate relationships between people using graph traversal."""


class RelationshipCalculator:
    """Calculate familial relationships between two people."""

    def __init__(self, database_connection) -> None:
        """Initialize the relationship calculator."""
        self.db = database_connection

    def find_relationship_path(self, person1_id: int, person2_id: int) -> list[int] | None:
        """Find the shortest relationship path between two people."""
        # TODO: Implement BFS graph traversal
        # TODO: Return list of person IDs in the path
        pass

    def describe_relationship(self, person1_id: int, person2_id: int) -> str:
        """Return a human-readable relationship description."""
        # TODO: Implement relationship naming logic
        # TODO: Handle parents, siblings, cousins, etc.
        # TODO: Handle "removed" relationships
        pass


>> âœ… utils\settings_manager.py (96 code lines)
"""User preferences and settings management."""

from __future__ import annotations
from typing import Any
from PySide6.QtCore import QSettings

class SettingsManager:
    """Manages user preferences and disk persistence."""

    DEFAULTS = {
        "shortcuts": {
            # File Menu shortcuts
            "file.new": "Ctrl+N",
            "file.open": "Ctrl+O",
            "file.save": "Ctrl+S",
            "file.save_as": "Ctrl+Shift+S",
            "file.exit": "Ctrl+Q",

            # Edit Menu shortcuts
            "edit.undo": "Ctrl+Z",
            "edit.redo": "Ctrl+Y",
            "edit.add_person": "Ctrl+P",
            "edit.remove_person": "Del",
            "edit.add_new_family": "Ctrl+F",

            # View Menu shortcuts
            "view.family_trees": "Ctrl+1",
            "view.timeline": "Ctrl+2",
            "view.dynasty": "Ctrl+3",
            "view.data_table": "Ctrl+4",

            # Tools Menu shortcuts
            "tools.rebuild_scene": "F5",
            "tools.recompute_generations": "Ctrl+R",
            "tools.validate_marriages": "Ctrl+M",
            "tools.validate_parentage": "Ctrl+Shift+P",

            # Settings Menu shortcuts
            "settings.settings": "Ctrl+,",
            "settings.general": "",
            "settings.shortcuts": "",
            "settings.display": "",
            "settings.appearance": "",
            "settings.formats": "",

            # Help Menu shortcuts
            "help.about": "F1",
        },

        "general": {
            # TODO: Define general settings defaults
            # e.g., autosave interval, default file paths, etc.
            # including different header sections as above
        },

        "display": {
            # TODO: Define display settings defaults
            # e.g., default zoom level, layout preferences, etc.
            # including different header sections as above
            # window size, position, maximized state, fonts, themes etc.
        },

        "appearance": {
            # TODO: Define appearance settings defaults
            # e.g., color schemes, node styles, edge styles, Colorblindness modes,
            # Male/Female/Unknown color preferences, generation band colors, genetic line styles, etc.
            # including different header sections as above to keep things organized
        },

        "formats": {
            # TODO: Define format settings defaults
            # e.g., date formats, name display formats, event display formats, etc.
            # Undo/Redo stack size, autosave file format, import/export preferences, etc.
            # including different header sections as above
        },
    }

    def __init__(self) -> None:
        """Initialize settings manager and load user settings."""
        
        self.qsettings = QSettings("DynastyVizualizer", "DynastyVisualizer")

        self.custom_shortcuts: dict[str, str | None] = {}
        self.custom_general: dict[str, Any] = {}
        self.custom_display: dict[str, Any] = {}
        self.custom_appearance: dict[str, Any] = {}
        self.custom_formats: dict[str, Any] = {}
    
        self._load_from_disk()

    # ------------------------------------------------------------------
    # Helper Methods
    # ------------------------------------------------------------------

    def _get_custom_dict(self, category: str) -> dict[str, Any]:
        """Get the custom dictionary for a given category."""
        category_map = {
            "shortcuts": self.custom_shortcuts,
            "general": self.custom_general,
            "display": self.custom_display,
            "appearance": self.custom_appearance,
            "formats": self.custom_formats,
        }
        return category_map.get(category, {})

    def _load_from_disk(self) -> None:
        """Load user's saved settings from disk."""
        for category in self.DEFAULTS.keys():
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if self.qsettings.contains(key):
                    value = self.qsettings.value(key)
                    custom_dict[key] = value if value else None
            
            self.qsettings.endGroup()
    def _save_to_disk(self) -> None:
        """Save user's custom settings to disk."""
        for category in self.DEFAULTS.keys():
            # Clear existing category on disk
            self.qsettings.beginGroup(category)
            self.qsettings.remove("")
            self.qsettings.endGroup()
            
            # Save only settings that exist in current DEFAULTS
            self.qsettings.beginGroup(category)
            custom_dict = self._get_custom_dict(category)
            
            for key in self.DEFAULTS[category].keys():
                if key in custom_dict:  
                    value = custom_dict[key]
                    default = self.DEFAULTS[category][key]

                    if value != default:
                        self.qsettings.setValue(key, value if value else "")
            
            self.qsettings.endGroup()
        
        self.qsettings.sync()

    # ------------------------------------------------------------------
    # Shortcut Operations (Specific, Type-Safe)
    # ------------------------------------------------------------------

    def get_shortcut(self, action_name: str) -> str:
        """Get the shortcut for a given action, falling back to default if not customized."""
        return self.get_setting("shortcuts", action_name)

    def set_shortcut(self, action_name: str, shortcut: str) -> None:
        """Set custom shortcut in memory without saving to disk."""
        self.set_setting("shortcuts", action_name, shortcut)

        if shortcut:
            for other_action in list(self.custom_shortcuts.keys()):
                if other_action != action_name:
                    if self.custom_shortcuts[other_action] == shortcut:
                        self.custom_shortcuts[other_action] = None


    # ------------------------------------------------------------------
    # Generic Settings Operations
    # ------------------------------------------------------------------

    def get_setting(self, category: str, key: str) -> Any:
        """Get setting from any category, checking custom then default."""
        # Check custom value first
        custom_dict = self._get_custom_dict(category)
        if key in custom_dict:
            value = custom_dict[key]
            return value if value is not None else ""
        
        # Fall back to default
        if category in self.DEFAULTS and key in self.DEFAULTS[category]:
            return self.DEFAULTS[category][key]
        
        return ""
    
    def set_setting(self, category: str, key: str, value: Any) -> None:
        """Set setting in any category (memory only, not saved to disk)."""
        custom_dict = self._get_custom_dict(category)
        custom_dict[key] = value if value else None

    # ------------------------------------------------------------------
    # Save/Discard/Reset Operations
    # ------------------------------------------------------------------

    def save(self) -> None:
        """Save all custom settings to disk."""
        self._save_to_disk()

    def discard_changes(self) -> None:
        """Discard unsaved changes by reloading from disk."""
        self.custom_shortcuts.clear()
        self.custom_general.clear()
        self.custom_display.clear()
        self.custom_appearance.clear()
        self.custom_formats.clear()
        self._load_from_disk()

    def reset_category_to_defaults(self, category: str) -> None:
        """Reset one category to defaults and save to disk."""
        custom_dict = self._get_custom_dict(category)
        custom_dict.clear()
        self._save_to_disk()

    def reset_all_to_defaults(self) -> None:
        """Reset all categories to defaults and save to disk."""
        for category in self.DEFAULTS.keys():
            self.reset_category_to_defaults(category)

    # ------------------------------------------------------------------
    # Recent Files Operations
    # ------------------------------------------------------------------

    def get_recent_files(self) -> list[str]:
        """Get list of recent file paths."""
        self.qsettings.beginGroup("recent_files")
        size = self.qsettings.beginReadArray("files")
        recent = []
        for i in range(size):
            self.qsettings.setArrayIndex(i)
            path = self.qsettings.value("path")
            if path:
                recent.append(path)
        self.qsettings.endArray()
        self.qsettings.endGroup()
        return recent

    def add_recent_file(self, file_path: str) -> None:
        """Add file to recent files list (most recent first)."""
        recent = self.get_recent_files()

        if file_path in recent:
            recent.remove(file_path)
        
        recent.insert(0, file_path)

        recent = recent[:10]

        self.qsettings.beginGroup("recent_files")
        self.qsettings.beginWriteArray("files")
        for i, path in enumerate(recent):
            self.qsettings.setArrayIndex(i)
            self.qsettings.setValue("path", path)
        self.qsettings.endArray()
        self.qsettings.endGroup()
        self.qsettings.sync()

    def clear_recent_files(self) -> None:
        """Clear all recent files."""
        self.qsettings.beginGroup("recent_files")
        self.qsettings.remove("")
        self.qsettings.endGroup()
        self.qsettings.sync()

>> ðŸ“‹ utils\skin_manager.py (4 code lines)
"""Skin/theme management for UI customization."""

from PySide6.QtWidgets import QApplication


class SkinManager:
    """Manage application color schemes and themes."""

    def __init__(self) -> None:
        """Initialize the skin manager with built-in themes."""
        self.skins: dict[str, dict[str, str]] = {}
        # TODO: Define default skin
        # TODO: Define dark mode skin
        # TODO: Define light mode skin
        # TODO: Define custom color schemes
        pass

    def load_skin(self, skin_name: str) -> None:
        """Apply a color scheme to the application."""
        # TODO: Get color definitions for skin_name
        # TODO: Generate QSS stylesheet
        # TODO: Apply to QApplication
        pass

    def get_available_skins(self) -> list[str]:
        """Get list of available skin names."""
        # TODO: Return list of skin keys
        pass

    def create_custom_skin(self, name: str, colors: dict[str, str]) -> None:
        """Create a new custom color scheme."""
        # TODO: Validate color values
        # TODO: Store in skins dictionary
        # TODO: Optionally save to Settings table
        pass


>> ðŸ“‹ utils\validators.py (5 code lines)
"""Data validation tools for detecting inconsistencies."""


class MarriageValidator:
    """Validate marriage data for inconsistencies."""

    def __init__(self, database_connection) -> None:
        """Initialize the marriage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all marriages for issues."""
        # TODO: Check for overlapping marriages
        # TODO: Check for invalid dates
        # TODO: Check for self-marriages
        # TODO: Return list of issues
        pass


class ParentageValidator:
    """Validate parent-child relationships."""

    def __init__(self, database_connection) -> None:
        """Initialize the parentage validator."""
        self.db = database_connection

    def validate_all(self) -> list[dict]:
        """Check all parentage relationships for issues."""
        # TODO: Check for circular parentage
        # TODO: Check for impossible dates
        # TODO: Return list of issues
        pass



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCRIPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> âœ… scripts\create_codebase_summary.py (119 code lines)
"""
Generate dynasty_codebase.txt - Complete codebase snapshot optimized for LLMs.

Creates a token-efficient snapshot of ALL source code that LLMs can use to
understand the complete project state in a single context window.

Usage:
    python scripts/create_codebase_summary.py

Output:
    dynasty_codebase.txt - Complete codebase, LLM-optimized

Features:
    - Token-efficient: Minimal headers, maximum code density
    - Complete: ALL Python files included
    - Organized: Grouped by category for easy parsing
    - Compact: No visual trees, just clean code listings
    - Smart encoding: Handles UTF-8, UTF-16
"""

import os
from pathlib import Path
from datetime import datetime
from typing import List, Tuple


# Configuration
OUTPUT_FILE = "dynasty_codebase.txt"
PROJECT_NAME = "DynastyVizualizer"

# Files/directories to ignore
IGNORE_PATTERNS = {
    "__pycache__", ".git", ".pytest_cache", ".venv", "venv", "env",
    ".env", "*.pyc", "*.pyo", "*.pyd", ".DS_Store", "*.egg-info",
    "dist", "build", ".idea", ".vscode", "*.dyn", "*.backup",
    "node_modules", "*.md", "dynasty_codebase.txt"
}

# File extensions to include
SOURCE_EXTENSIONS = {".py"}

# Config files to include
CONFIG_FILES = {"requirements.txt"}


def should_ignore(path: Path) -> bool:
    """Check if path or any parent should be ignored."""
    path_str = str(path)
    
    # Check if any part of the path matches ignore patterns
    for part in path.parts:
        if part in IGNORE_PATTERNS:
            return True
    
    # Check filename patterns
    name = path.name
    for pattern in IGNORE_PATTERNS:
        if "*" in pattern:
            ext = pattern.replace("*", "")
            if path_str.endswith(ext):
                return True
    
    if name == OUTPUT_FILE:
        return True
    
    return False

def count_code_lines(filepath: Path) -> int:
    """Count non-empty, non-comment lines."""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            count = 0
            in_multiline = False

            for line in f:
                stripped = line.strip()
                if not stripped:
                    continue

                if '"""' in stripped or "'''" in stripped:
                    in_multiline = not in_multiline
                    continue

                if in_multiline or stripped.startswith('#'):
                    continue

                count += 1

            return count
    except Exception:
        return 0


def discover_files(root_dir: Path) -> Tuple[List[Path], List[Path]]:
    """Discover all source and config files."""
    source_files = []
    config_files = []

    for path in sorted(root_dir.rglob("*")):
        if path.is_dir() or should_ignore(path):
            continue

        if path.suffix in SOURCE_EXTENSIONS:
            source_files.append(path)
        elif path.name in CONFIG_FILES:
            config_files.append(path)

    return source_files, config_files


def get_relative_path(filepath: Path, root: Path) -> str:
    """Get path relative to project root."""
    try:
        return str(filepath.relative_to(root))
    except ValueError:
        return str(filepath)


def read_file_content(filepath: Path) -> str:
    """Read file content with multiple encoding support."""
    for encoding in ['utf-8', 'utf-16', 'utf-16-le', 'latin-1']:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                content = f.read()
                if '\x00' not in content or encoding.startswith('utf-16'):
                    return content
        except (UnicodeDecodeError, Exception):
            continue

    try:
        with open(filepath, 'rb') as f:
            return f.read().decode('utf-8', errors='replace')
    except Exception as e:
        return f"[Error: {e}]"


def categorize_files(source_files: List[Path], root: Path) -> dict:
    """Organize files by category."""
    categories = {
        "Core": [], "Database": [], "Models": [], "Actions": [],
        "Commands": [], "Dialogs": [], "Views": [], "Widgets": [],
        "Utils": [], "Scripts": []
    }

    for f in source_files:
        rel_path = get_relative_path(f, root)
        parent = str(Path(rel_path).parent)

        if rel_path == "main.py":
            categories["Core"].append(f)
        elif "database" in parent:
            categories["Database"].append(f)
        elif "models" in parent:
            categories["Models"].append(f)
        elif "actions" in parent:
            categories["Actions"].append(f)
        elif "commands" in parent:
            categories["Commands"].append(f)
        elif "dialogs" in parent:
            categories["Dialogs"].append(f)
        elif "views" in parent:
            categories["Views"].append(f)
        elif "widgets" in parent:
            categories["Widgets"].append(f)
        elif "utils" in parent:
            categories["Utils"].append(f)
        elif "scripts" in parent:
            categories["Scripts"].append(f)
        else:
            categories["Core"].append(f)

    return categories


def generate_summary(root_dir: Path) -> None:
    """Generate the token-efficient codebase snapshot."""

    print(f"ðŸ” Discovering files in {PROJECT_NAME}...")
    source_files, config_files = discover_files(root_dir)

    total_files = len(source_files)
    implemented = sum(1 for f in source_files if count_code_lines(f) > 20)
    code_lines = sum(count_code_lines(f) for f in source_files)

    print(f"ðŸ“Š Found {total_files} files ({implemented} implemented, {code_lines} code lines)")

    categories = categorize_files(source_files, root_dir)
    output_path = root_dir / OUTPUT_FILE

    with open(output_path, 'w', encoding='utf-8') as out:
        # Compact header
        out.write(f"{'='*70}\n")
        out.write(f"{PROJECT_NAME} - Complete Codebase\n")
        out.write(f"{'='*70}\n")
        out.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        out.write(f"Files: {implemented}/{total_files} implemented | {code_lines} code lines\n")
        out.write(f"Tech: PySide6, SQLite, Python 3.10+ | MVC + Command pattern\n")
        out.write(f"Status: Phase 1 Complete, Phase 2 ~35% (Add Person done)\n")
        out.write(f"{'='*70}\n\n")

        # Quick context
        out.write("QUICK CONTEXT:\n")
        out.write("Family tree/genealogy GUI for gaming (Ostriv). Features: Person CRUD,\n")
        out.write("undo/redo, flexible dates, special char support, DB migration.\n")
        out.write("Pattern: User Action â†’ Dialog â†’ Command â†’ Repository â†’ Database\n\n")

        # File index (compact)
        out.write("FILE INDEX:\n")
        for category, files in categories.items():
            if files:
                out.write(f"{category}: ")
                file_names = [get_relative_path(f, root_dir) for f in sorted(files)]
                out.write(", ".join(file_names[:50]))
                if len(files) > 50:
                    out.write(f", ... ({len(files)} total)")
                out.write("\n")
        out.write(f"\n{'='*70}\n")
        out.write("COMPLETE SOURCE CODE\n")
        out.write(f"{'='*70}\n\n")

        # Output code by category (compact format)
        for category, files in categories.items():
            if not files:
                continue

            out.write(f"\n{'â”€'*70}\n")
            out.write(f"{category.upper()}\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in sorted(files):
                rel_path = get_relative_path(filepath, root_dir)
                lines = count_code_lines(filepath)
                status = "âœ…" if lines > 20 else "ðŸ“‹"

                # Compact file header
                out.write(f">> {status} {rel_path} ({lines} code lines)\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

                print(f"âœ… {rel_path} ({lines} lines)")

        # Config files
        if config_files:
            out.write(f"\n{'â”€'*70}\n")
            out.write("CONFIGURATION\n")
            out.write(f"{'â”€'*70}\n\n")

            for filepath in config_files:
                rel_path = get_relative_path(filepath, root_dir)
                out.write(f">> {rel_path}\n")
                out.write(read_file_content(filepath))
                out.write("\n\n")

        # Compact footer
        out.write(f"\n{'='*70}\n")
        out.write(f"END - {implemented}/{total_files} files, {code_lines} code lines\n")
        out.write(f"{'='*70}\n")

    print(f"\nâœ… Generated {OUTPUT_FILE}")
    print(f"ðŸ“Š {implemented}/{total_files} files, {code_lines:,} code lines")
    print(f"ðŸ“„ Output: {output_path}")
    print(f"ðŸ¤– Token-optimized for LLM consumption!\n")


if __name__ == "__main__":
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)

    print(f"{'='*60}")
    print(f"  {PROJECT_NAME} - Codebase Generator")
    print(f"{'='*60}\n")

    generate_summary(project_root)


>> âœ… scripts\migrate_database.py (57 code lines)
"""
Migration script to upgrade existing .dyn files to the new schema.

This script safely adds:
1. Day fields to all date columns (birth, death, arrival, etc.)
2. New tables (Portrait, Family, MajorEvent, PersonPosition, Settings)
3. Additional Person fields (maiden_name, family_id, notes)
4. Marriage type field

Usage:
    python scripts/migrate_database.py <path_to_dynasty_file.dyn>

Example:
    python scripts/migrate_database.py "MyDynasty.dyn"

This migration is SAFE:
- Existing data is preserved (new columns are NULL)
- No data is deleted or modified
- Backup is created before migration
"""

import sqlite3
import shutil
import sys
from pathlib import Path


def backup_database(file_path: str) -> str:
    """Create a backup of the database before migration."""
    backup_path = f"{file_path}.backup"
    shutil.copy2(file_path, backup_path)
    print(f"âœ… Backup created: {backup_path}")
    return backup_path


def get_existing_columns(cursor: sqlite3.Cursor, table_name: str) -> list[str]:
    """Get list of existing columns in a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return [row[1] for row in cursor.fetchall()]


def migrate_database(file_path: str) -> None:
    """Migrate an existing .dyn database to the new schema."""

    if not Path(file_path).exists():
        print(f"âŒ Error: File '{file_path}' not found")
        sys.exit(1)

    print(f"Migrating database: {file_path}")
    print("=" * 60)

    # Create backup
    backup_path = backup_database(file_path)

    try:
        # Connect to database
        conn = sqlite3.connect(file_path)
        conn.execute("PRAGMA foreign_keys = ON;")
        cursor = conn.cursor()

        # Migrate Person table
        print("\nðŸ“ Migrating Person table...")
        person_columns = get_existing_columns(cursor, "Person")

        person_migrations = [
            ("birth_day", "ALTER TABLE Person ADD COLUMN birth_day INTEGER"),
            ("death_day", "ALTER TABLE Person ADD COLUMN death_day INTEGER"),
            ("arrival_day", "ALTER TABLE Person ADD COLUMN arrival_day INTEGER"),
            ("moved_out_day", "ALTER TABLE Person ADD COLUMN moved_out_day INTEGER"),
            ("maiden_name", "ALTER TABLE Person ADD COLUMN maiden_name TEXT"),
            ("family_id", "ALTER TABLE Person ADD COLUMN family_id INTEGER REFERENCES Family(id) ON DELETE SET NULL"),
            ("notes", "ALTER TABLE Person ADD COLUMN notes TEXT"),
            ("middle_name", "ALTER TABLE Person ADD COLUMN middle_name TEXT DEFAULT ''"),
            ("nickname", "ALTER TABLE Person ADD COLUMN nickname TEXT DEFAULT ''"),
            ("dynasty_id", "ALTER TABLE Person ADD COLUMN dynasty_id INTEGER DEFAULT 1"),
            ("is_founder", "ALTER TABLE Person ADD COLUMN is_founder INTEGER DEFAULT 0"),
            ("education", "ALTER TABLE Person ADD COLUMN education INTEGER DEFAULT 0"),
        ]

        for col_name, sql in person_migrations:
            if col_name not in person_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Event table
        print("\nðŸ“ Migrating Event table...")
        event_columns = get_existing_columns(cursor, "Event")

        event_migrations = [
            ("start_day", "ALTER TABLE Event ADD COLUMN start_day INTEGER"),
            ("end_day", "ALTER TABLE Event ADD COLUMN end_day INTEGER"),
        ]

        for col_name, sql in event_migrations:
            if col_name not in event_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Migrate Marriage table
        print("\nðŸ“ Migrating Marriage table...")
        marriage_columns = get_existing_columns(cursor, "Marriage")

        marriage_migrations = [
            ("marriage_day", "ALTER TABLE Marriage ADD COLUMN marriage_day INTEGER"),
            ("dissolution_day", "ALTER TABLE Marriage ADD COLUMN dissolution_day INTEGER"),
            ("marriage_type", "ALTER TABLE Marriage ADD COLUMN marriage_type TEXT DEFAULT 'spouse'"),
        ]

        for col_name, sql in marriage_migrations:
            if col_name not in marriage_columns:
                cursor.execute(sql)
                print(f"  âœ… Added column: {col_name}")
            else:
                print(f"  â­ï¸  Column already exists: {col_name}")

        # Create new tables
        print("\nðŸ“ Creating new tables...")

        new_tables = {
            "Portrait": """
                CREATE TABLE IF NOT EXISTS Portrait (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    person_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    valid_from_year INTEGER,
                    valid_from_month INTEGER,
                    valid_from_day INTEGER,
                    valid_to_year INTEGER,
                    valid_to_month INTEGER,
                    valid_to_day INTEGER,
                    is_primary INTEGER DEFAULT 0,
                    display_order INTEGER DEFAULT 0,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Family": """
                CREATE TABLE IF NOT EXISTS Family (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    surname TEXT NOT NULL,
                    move_in_year INTEGER,
                    move_in_month INTEGER,
                    move_in_day INTEGER,
                    coat_of_arms_path TEXT,
                    family_color TEXT,
                    is_extinct INTEGER DEFAULT 0,
                    notes TEXT
                )
            """,
            "MajorEvent": """
                CREATE TABLE IF NOT EXISTS MajorEvent (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_name TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    start_year INTEGER NOT NULL,
                    start_month INTEGER,
                    start_day INTEGER,
                    end_year INTEGER,
                    end_month INTEGER,
                    end_day INTEGER,
                    description TEXT,
                    color TEXT
                )
            """,
            "PersonPosition": """
                CREATE TABLE IF NOT EXISTS PersonPosition (
                    person_id INTEGER PRIMARY KEY,
                    view_type TEXT NOT NULL,
                    x_position REAL NOT NULL,
                    y_position REAL NOT NULL,
                    FOREIGN KEY(person_id) REFERENCES Person(id) ON DELETE CASCADE
                )
            """,
            "Settings": """
                CREATE TABLE IF NOT EXISTS Settings (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL
                )
            """
        }

        for table_name, create_sql in new_tables.items():
            # Check if table exists
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (table_name,)
            )
            if cursor.fetchone():
                print(f"  â­ï¸  Table already exists: {table_name}")
            else:
                cursor.execute(create_sql)
                print(f"  âœ… Created table: {table_name}")

        # Commit all changes
        conn.commit()
        conn.close()

        print("\n" + "=" * 60)
        print("âœ… Migration completed successfully!")
        print(f"âœ… Original database backed up to: {backup_path}")
        print(f"âœ… Migrated database: {file_path}")
        print("\nYour database is now ready for the full feature set!")
        print("All existing data has been preserved.")

    except Exception as e:
        print(f"\nâŒ Migration failed: {e}")
        print(f"Restoring from backup: {backup_path}")
        shutil.copy2(backup_path, file_path)
        print("âœ… Database restored to original state")
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/migrate_database.py <path_to_dynasty_file.dyn>")
        print("\nExample:")
        print('  python scripts/migrate_database.py "MyDynasty.dyn"')
        sys.exit(1)

    dynasty_file = sys.argv[1]
    migrate_database(dynasty_file)


>> âœ… scripts\test_edit_person_dialog.py (21 code lines)
import sys
from PySide6.QtWidgets import QApplication

from database.db_manager import DatabaseManager
from database.person_repository import PersonRepository
from dialogs.edit_person_dialog import EditPersonDialog

app = QApplication(sys.argv)

# Open database
db = DatabaseManager(None)
db.open_database("Struggberg Family Tree 1.dyn")  # Use your actual .dyn file

# Get a person to edit
repo = PersonRepository(db)
people = repo.get_all()

if people:
    person = people[0]  # Edit the first person
    
    dialog = EditPersonDialog(db, person)
    result = dialog.exec()
    
    if result:
        print("User clicked Save")
    else:
        print("User clicked Cancel")
else:
    print("No people in database!")

sys.exit(0)

>> ðŸ“‹ scripts\test_person_box.py (17 code lines)
"""Test script to visualize PersonBox widgets."""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from PySide6.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QMainWindow, QVBoxLayout, QWidget
from PySide6.QtGui import QBrush, QColor, QPainter


class TestWindow(QMainWindow):
    """Simple test window to display PersonBox widgets."""
    
    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.setWindowTitle("PersonBox Test")
        self.setGeometry(100, 100, 1200, 800)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        self.scene = QGraphicsScene()
        self.view = QGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setBackgroundBrush(QBrush(QColor(240, 240, 240)))
        
        layout.addWidget(self.view)
        
        self._add_test_person_boxes()
    
    def _add_test_person_boxes(self):
        """Add a few PersonBox widgets to test the display."""
        if not self.db or not self.db.conn:
            print("No database connection!")
            return
        
        # Import here to avoid issues
        from views.tree_view.person_box import PersonBox
        
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT id FROM Person LIMIT 6")
        people = cursor.fetchall()
        
        x = 50
        y = 50
        spacing_x = 320
        spacing_y = 150
        
        for i, person_row in enumerate(people):
            person_id = person_row['id']
            
            person_box = PersonBox(person_id, self.db)
            
            # Connect signals
            person_box.person_double_clicked.connect(self.on_person_double_clicked)
            person_box.person_selected.connect(self.on_person_selected)
            
            col = i % 3
            row = i // 3
            person_box.setPos(x + col * spacing_x, y + row * spacing_y)
            
            self.scene.addItem(person_box)
        
        self.scene.setSceneRect(0, 0, 1100, 600)
    
    def on_person_double_clicked(self, person_id: int):
        """Handle person double-click."""
        print(f"Double-clicked person ID: {person_id}")
    
    def on_person_selected(self, person_id: int):
        """Handle person selection."""
        print(f"Selected person ID: {person_id}")


if __name__ == "__main__":
    print("PersonBox Test")
    print("-" * 50)
    
    db_file = r"D:\Programs\DynastyVizualizer\Struggberg Family Tree 1.dyn"
    
    from database.db_manager import DatabaseManager
    
    db = DatabaseManager(None)
    db.open_database(db_file)
    
    app = QApplication(sys.argv)
    window = TestWindow(db)
    window.show()
    sys.exit(app.exec())
    
    from database.db_manager import DatabaseManager
    
    db = DatabaseManager(None)
    db.open_database(db_file)
    
    app = QApplication(sys.argv)
    window = TestWindow(db)
    window.show()
    sys.exit(app.exec())


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONFIGURATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

>> requirements.txt
packaging==25.0
PySide6==6.10.1
PySide6_Addons==6.10.1
PySide6_Essentials==6.10.1
QtPy==2.4.3
shiboken6==6.10.1



======================================================================
END - 30/105 files, 2967 code lines
======================================================================
